/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
"use strict";

var $protobuf = require("protobufjs/minimal");

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.Common = (function() {

    /**
     * Namespace Common.
     * @exports Common
     * @namespace
     */
    var Common = {};

    /**
     * RetType enum.
     * @name Common.RetType
     * @enum {string}
     * @property {number} RetType_Succeed=0 RetType_Succeed value
     * @property {number} RetType_Failed=-1 RetType_Failed value
     * @property {number} RetType_TimeOut=-100 RetType_TimeOut value
     * @property {number} RetType_Unknown=-400 RetType_Unknown value
     */
    Common.RetType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "RetType_Succeed"] = 0;
        values[valuesById[-1] = "RetType_Failed"] = -1;
        values[valuesById[-100] = "RetType_TimeOut"] = -100;
        values[valuesById[-400] = "RetType_Unknown"] = -400;
        return values;
    })();

    /**
     * PacketEncAlgo enum.
     * @name Common.PacketEncAlgo
     * @enum {string}
     * @property {number} PacketEncAlgo_FTAES_ECB=0 PacketEncAlgo_FTAES_ECB value
     * @property {number} PacketEncAlgo_None=-1 PacketEncAlgo_None value
     * @property {number} PacketEncAlgo_AES_ECB=1 PacketEncAlgo_AES_ECB value
     */
    Common.PacketEncAlgo = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "PacketEncAlgo_FTAES_ECB"] = 0;
        values[valuesById[-1] = "PacketEncAlgo_None"] = -1;
        values[valuesById[1] = "PacketEncAlgo_AES_ECB"] = 1;
        return values;
    })();

    Common.PacketID = (function() {

        /**
         * Properties of a PacketID.
         * @memberof Common
         * @interface IPacketID
         * @property {number|Long} connID PacketID connID
         * @property {number} serialNo PacketID serialNo
         */

        /**
         * Constructs a new PacketID.
         * @memberof Common
         * @classdesc Represents a PacketID.
         * @implements IPacketID
         * @constructor
         * @param {Common.IPacketID=} [properties] Properties to set
         */
        function PacketID(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PacketID connID.
         * @member {number|Long} connID
         * @memberof Common.PacketID
         * @instance
         */
        PacketID.prototype.connID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * PacketID serialNo.
         * @member {number} serialNo
         * @memberof Common.PacketID
         * @instance
         */
        PacketID.prototype.serialNo = 0;

        /**
         * Creates a new PacketID instance using the specified properties.
         * @function create
         * @memberof Common.PacketID
         * @static
         * @param {Common.IPacketID=} [properties] Properties to set
         * @returns {Common.PacketID} PacketID instance
         */
        PacketID.create = function create(properties) {
            return new PacketID(properties);
        };

        /**
         * Encodes the specified PacketID message. Does not implicitly {@link Common.PacketID.verify|verify} messages.
         * @function encode
         * @memberof Common.PacketID
         * @static
         * @param {Common.IPacketID} message PacketID message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PacketID.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.connID);
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.serialNo);
            return writer;
        };

        /**
         * Encodes the specified PacketID message, length delimited. Does not implicitly {@link Common.PacketID.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Common.PacketID
         * @static
         * @param {Common.IPacketID} message PacketID message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PacketID.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PacketID message from the specified reader or buffer.
         * @function decode
         * @memberof Common.PacketID
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Common.PacketID} PacketID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PacketID.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Common.PacketID();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.connID = reader.uint64();
                    break;
                case 2:
                    message.serialNo = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("connID"))
                throw $util.ProtocolError("missing required 'connID'", { instance: message });
            if (!message.hasOwnProperty("serialNo"))
                throw $util.ProtocolError("missing required 'serialNo'", { instance: message });
            return message;
        };

        /**
         * Decodes a PacketID message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Common.PacketID
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Common.PacketID} PacketID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PacketID.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PacketID message.
         * @function verify
         * @memberof Common.PacketID
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PacketID.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.connID) && !(message.connID && $util.isInteger(message.connID.low) && $util.isInteger(message.connID.high)))
                return "connID: integer|Long expected";
            if (!$util.isInteger(message.serialNo))
                return "serialNo: integer expected";
            return null;
        };

        /**
         * Creates a PacketID message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Common.PacketID
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Common.PacketID} PacketID
         */
        PacketID.fromObject = function fromObject(object) {
            if (object instanceof $root.Common.PacketID)
                return object;
            var message = new $root.Common.PacketID();
            if (object.connID != null)
                if ($util.Long)
                    (message.connID = $util.Long.fromValue(object.connID)).unsigned = true;
                else if (typeof object.connID === "string")
                    message.connID = parseInt(object.connID, 10);
                else if (typeof object.connID === "number")
                    message.connID = object.connID;
                else if (typeof object.connID === "object")
                    message.connID = new $util.LongBits(object.connID.low >>> 0, object.connID.high >>> 0).toNumber(true);
            if (object.serialNo != null)
                message.serialNo = object.serialNo >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a PacketID message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Common.PacketID
         * @static
         * @param {Common.PacketID} message PacketID
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PacketID.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.connID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.connID = options.longs === String ? "0" : 0;
                object.serialNo = 0;
            }
            if (message.connID != null && message.hasOwnProperty("connID"))
                if (typeof message.connID === "number")
                    object.connID = options.longs === String ? String(message.connID) : message.connID;
                else
                    object.connID = options.longs === String ? $util.Long.prototype.toString.call(message.connID) : options.longs === Number ? new $util.LongBits(message.connID.low >>> 0, message.connID.high >>> 0).toNumber(true) : message.connID;
            if (message.serialNo != null && message.hasOwnProperty("serialNo"))
                object.serialNo = message.serialNo;
            return object;
        };

        /**
         * Converts this PacketID to JSON.
         * @function toJSON
         * @memberof Common.PacketID
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PacketID.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PacketID;
    })();

    return Common;
})();

$root.GetGlobalState = (function() {

    /**
     * Namespace GetGlobalState.
     * @exports GetGlobalState
     * @namespace
     */
    var GetGlobalState = {};

    /**
     * ProgramStatusType enum.
     * @name GetGlobalState.ProgramStatusType
     * @enum {string}
     * @property {number} ProgramStatusType_None=0 ProgramStatusType_None value
     * @property {number} ProgramStatusType_Loaded=1 ProgramStatusType_Loaded value
     * @property {number} ProgramStatusType_Loging=2 ProgramStatusType_Loging value
     * @property {number} ProgramStatusType_NeedPicVerifyCode=3 ProgramStatusType_NeedPicVerifyCode value
     * @property {number} ProgramStatusType_NeedPhoneVerifyCode=4 ProgramStatusType_NeedPhoneVerifyCode value
     * @property {number} ProgramStatusType_LoginFailed=5 ProgramStatusType_LoginFailed value
     * @property {number} ProgramStatusType_ForceUpdate=6 ProgramStatusType_ForceUpdate value
     * @property {number} ProgramStatusType_NessaryDataPreparing=7 ProgramStatusType_NessaryDataPreparing value
     * @property {number} ProgramStatusType_NessaryDataMissing=8 ProgramStatusType_NessaryDataMissing value
     * @property {number} ProgramStatusType_UnAgreeDisclaimer=9 ProgramStatusType_UnAgreeDisclaimer value
     * @property {number} ProgramStatusType_Ready=10 ProgramStatusType_Ready value
     * @property {number} ProgramStatusType_ForceLogout=11 ProgramStatusType_ForceLogout value
     */
    GetGlobalState.ProgramStatusType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "ProgramStatusType_None"] = 0;
        values[valuesById[1] = "ProgramStatusType_Loaded"] = 1;
        values[valuesById[2] = "ProgramStatusType_Loging"] = 2;
        values[valuesById[3] = "ProgramStatusType_NeedPicVerifyCode"] = 3;
        values[valuesById[4] = "ProgramStatusType_NeedPhoneVerifyCode"] = 4;
        values[valuesById[5] = "ProgramStatusType_LoginFailed"] = 5;
        values[valuesById[6] = "ProgramStatusType_ForceUpdate"] = 6;
        values[valuesById[7] = "ProgramStatusType_NessaryDataPreparing"] = 7;
        values[valuesById[8] = "ProgramStatusType_NessaryDataMissing"] = 8;
        values[valuesById[9] = "ProgramStatusType_UnAgreeDisclaimer"] = 9;
        values[valuesById[10] = "ProgramStatusType_Ready"] = 10;
        values[valuesById[11] = "ProgramStatusType_ForceLogout"] = 11;
        return values;
    })();

    GetGlobalState.ProgramStatus = (function() {

        /**
         * Properties of a ProgramStatus.
         * @memberof GetGlobalState
         * @interface IProgramStatus
         * @property {GetGlobalState.ProgramStatusType} type ProgramStatus type
         * @property {string|null} [strExtDesc] ProgramStatus strExtDesc
         */

        /**
         * Constructs a new ProgramStatus.
         * @memberof GetGlobalState
         * @classdesc Represents a ProgramStatus.
         * @implements IProgramStatus
         * @constructor
         * @param {GetGlobalState.IProgramStatus=} [properties] Properties to set
         */
        function ProgramStatus(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProgramStatus type.
         * @member {GetGlobalState.ProgramStatusType} type
         * @memberof GetGlobalState.ProgramStatus
         * @instance
         */
        ProgramStatus.prototype.type = 0;

        /**
         * ProgramStatus strExtDesc.
         * @member {string} strExtDesc
         * @memberof GetGlobalState.ProgramStatus
         * @instance
         */
        ProgramStatus.prototype.strExtDesc = "";

        /**
         * Creates a new ProgramStatus instance using the specified properties.
         * @function create
         * @memberof GetGlobalState.ProgramStatus
         * @static
         * @param {GetGlobalState.IProgramStatus=} [properties] Properties to set
         * @returns {GetGlobalState.ProgramStatus} ProgramStatus instance
         */
        ProgramStatus.create = function create(properties) {
            return new ProgramStatus(properties);
        };

        /**
         * Encodes the specified ProgramStatus message. Does not implicitly {@link GetGlobalState.ProgramStatus.verify|verify} messages.
         * @function encode
         * @memberof GetGlobalState.ProgramStatus
         * @static
         * @param {GetGlobalState.IProgramStatus} message ProgramStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProgramStatus.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.strExtDesc != null && message.hasOwnProperty("strExtDesc"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.strExtDesc);
            return writer;
        };

        /**
         * Encodes the specified ProgramStatus message, length delimited. Does not implicitly {@link GetGlobalState.ProgramStatus.verify|verify} messages.
         * @function encodeDelimited
         * @memberof GetGlobalState.ProgramStatus
         * @static
         * @param {GetGlobalState.IProgramStatus} message ProgramStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProgramStatus.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProgramStatus message from the specified reader or buffer.
         * @function decode
         * @memberof GetGlobalState.ProgramStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {GetGlobalState.ProgramStatus} ProgramStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProgramStatus.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetGlobalState.ProgramStatus();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.strExtDesc = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("type"))
                throw $util.ProtocolError("missing required 'type'", { instance: message });
            return message;
        };

        /**
         * Decodes a ProgramStatus message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof GetGlobalState.ProgramStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {GetGlobalState.ProgramStatus} ProgramStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProgramStatus.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProgramStatus message.
         * @function verify
         * @memberof GetGlobalState.ProgramStatus
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProgramStatus.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            switch (message.type) {
            default:
                return "type: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
                break;
            }
            if (message.strExtDesc != null && message.hasOwnProperty("strExtDesc"))
                if (!$util.isString(message.strExtDesc))
                    return "strExtDesc: string expected";
            return null;
        };

        /**
         * Creates a ProgramStatus message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof GetGlobalState.ProgramStatus
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {GetGlobalState.ProgramStatus} ProgramStatus
         */
        ProgramStatus.fromObject = function fromObject(object) {
            if (object instanceof $root.GetGlobalState.ProgramStatus)
                return object;
            var message = new $root.GetGlobalState.ProgramStatus();
            switch (object.type) {
            case "ProgramStatusType_None":
            case 0:
                message.type = 0;
                break;
            case "ProgramStatusType_Loaded":
            case 1:
                message.type = 1;
                break;
            case "ProgramStatusType_Loging":
            case 2:
                message.type = 2;
                break;
            case "ProgramStatusType_NeedPicVerifyCode":
            case 3:
                message.type = 3;
                break;
            case "ProgramStatusType_NeedPhoneVerifyCode":
            case 4:
                message.type = 4;
                break;
            case "ProgramStatusType_LoginFailed":
            case 5:
                message.type = 5;
                break;
            case "ProgramStatusType_ForceUpdate":
            case 6:
                message.type = 6;
                break;
            case "ProgramStatusType_NessaryDataPreparing":
            case 7:
                message.type = 7;
                break;
            case "ProgramStatusType_NessaryDataMissing":
            case 8:
                message.type = 8;
                break;
            case "ProgramStatusType_UnAgreeDisclaimer":
            case 9:
                message.type = 9;
                break;
            case "ProgramStatusType_Ready":
            case 10:
                message.type = 10;
                break;
            case "ProgramStatusType_ForceLogout":
            case 11:
                message.type = 11;
                break;
            }
            if (object.strExtDesc != null)
                message.strExtDesc = String(object.strExtDesc);
            return message;
        };

        /**
         * Creates a plain object from a ProgramStatus message. Also converts values to other types if specified.
         * @function toObject
         * @memberof GetGlobalState.ProgramStatus
         * @static
         * @param {GetGlobalState.ProgramStatus} message ProgramStatus
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProgramStatus.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = options.enums === String ? "ProgramStatusType_None" : 0;
                object.strExtDesc = "";
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.GetGlobalState.ProgramStatusType[message.type] : message.type;
            if (message.strExtDesc != null && message.hasOwnProperty("strExtDesc"))
                object.strExtDesc = message.strExtDesc;
            return object;
        };

        /**
         * Converts this ProgramStatus to JSON.
         * @function toJSON
         * @memberof GetGlobalState.ProgramStatus
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProgramStatus.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProgramStatus;
    })();

    GetGlobalState.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof GetGlobalState
         * @interface IC2S
         * @property {number|Long} userID C2S userID
         */

        /**
         * Constructs a new C2S.
         * @memberof GetGlobalState
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {GetGlobalState.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S userID.
         * @member {number|Long} userID
         * @memberof GetGlobalState.C2S
         * @instance
         */
        C2S.prototype.userID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof GetGlobalState.C2S
         * @static
         * @param {GetGlobalState.IC2S=} [properties] Properties to set
         * @returns {GetGlobalState.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link GetGlobalState.C2S.verify|verify} messages.
         * @function encode
         * @memberof GetGlobalState.C2S
         * @static
         * @param {GetGlobalState.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.userID);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link GetGlobalState.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof GetGlobalState.C2S
         * @static
         * @param {GetGlobalState.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof GetGlobalState.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {GetGlobalState.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetGlobalState.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.userID = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("userID"))
                throw $util.ProtocolError("missing required 'userID'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof GetGlobalState.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {GetGlobalState.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof GetGlobalState.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.userID) && !(message.userID && $util.isInteger(message.userID.low) && $util.isInteger(message.userID.high)))
                return "userID: integer|Long expected";
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof GetGlobalState.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {GetGlobalState.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.GetGlobalState.C2S)
                return object;
            var message = new $root.GetGlobalState.C2S();
            if (object.userID != null)
                if ($util.Long)
                    (message.userID = $util.Long.fromValue(object.userID)).unsigned = true;
                else if (typeof object.userID === "string")
                    message.userID = parseInt(object.userID, 10);
                else if (typeof object.userID === "number")
                    message.userID = object.userID;
                else if (typeof object.userID === "object")
                    message.userID = new $util.LongBits(object.userID.low >>> 0, object.userID.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof GetGlobalState.C2S
         * @static
         * @param {GetGlobalState.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.userID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.userID = options.longs === String ? "0" : 0;
            if (message.userID != null && message.hasOwnProperty("userID"))
                if (typeof message.userID === "number")
                    object.userID = options.longs === String ? String(message.userID) : message.userID;
                else
                    object.userID = options.longs === String ? $util.Long.prototype.toString.call(message.userID) : options.longs === Number ? new $util.LongBits(message.userID.low >>> 0, message.userID.high >>> 0).toNumber(true) : message.userID;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof GetGlobalState.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    GetGlobalState.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof GetGlobalState
         * @interface IS2C
         * @property {number} marketHK S2C marketHK
         * @property {number} marketUS S2C marketUS
         * @property {number} marketSH S2C marketSH
         * @property {number} marketSZ S2C marketSZ
         * @property {number} marketHKFuture S2C marketHKFuture
         * @property {boolean} qotLogined S2C qotLogined
         * @property {boolean} trdLogined S2C trdLogined
         * @property {number} serverVer S2C serverVer
         * @property {number} serverBuildNo S2C serverBuildNo
         * @property {number|Long} time S2C time
         * @property {number|null} [localTime] S2C localTime
         * @property {GetGlobalState.IProgramStatus|null} [programStatus] S2C programStatus
         */

        /**
         * Constructs a new S2C.
         * @memberof GetGlobalState
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {GetGlobalState.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C marketHK.
         * @member {number} marketHK
         * @memberof GetGlobalState.S2C
         * @instance
         */
        S2C.prototype.marketHK = 0;

        /**
         * S2C marketUS.
         * @member {number} marketUS
         * @memberof GetGlobalState.S2C
         * @instance
         */
        S2C.prototype.marketUS = 0;

        /**
         * S2C marketSH.
         * @member {number} marketSH
         * @memberof GetGlobalState.S2C
         * @instance
         */
        S2C.prototype.marketSH = 0;

        /**
         * S2C marketSZ.
         * @member {number} marketSZ
         * @memberof GetGlobalState.S2C
         * @instance
         */
        S2C.prototype.marketSZ = 0;

        /**
         * S2C marketHKFuture.
         * @member {number} marketHKFuture
         * @memberof GetGlobalState.S2C
         * @instance
         */
        S2C.prototype.marketHKFuture = 0;

        /**
         * S2C qotLogined.
         * @member {boolean} qotLogined
         * @memberof GetGlobalState.S2C
         * @instance
         */
        S2C.prototype.qotLogined = false;

        /**
         * S2C trdLogined.
         * @member {boolean} trdLogined
         * @memberof GetGlobalState.S2C
         * @instance
         */
        S2C.prototype.trdLogined = false;

        /**
         * S2C serverVer.
         * @member {number} serverVer
         * @memberof GetGlobalState.S2C
         * @instance
         */
        S2C.prototype.serverVer = 0;

        /**
         * S2C serverBuildNo.
         * @member {number} serverBuildNo
         * @memberof GetGlobalState.S2C
         * @instance
         */
        S2C.prototype.serverBuildNo = 0;

        /**
         * S2C time.
         * @member {number|Long} time
         * @memberof GetGlobalState.S2C
         * @instance
         */
        S2C.prototype.time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * S2C localTime.
         * @member {number} localTime
         * @memberof GetGlobalState.S2C
         * @instance
         */
        S2C.prototype.localTime = 0;

        /**
         * S2C programStatus.
         * @member {GetGlobalState.IProgramStatus|null|undefined} programStatus
         * @memberof GetGlobalState.S2C
         * @instance
         */
        S2C.prototype.programStatus = null;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof GetGlobalState.S2C
         * @static
         * @param {GetGlobalState.IS2C=} [properties] Properties to set
         * @returns {GetGlobalState.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link GetGlobalState.S2C.verify|verify} messages.
         * @function encode
         * @memberof GetGlobalState.S2C
         * @static
         * @param {GetGlobalState.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.marketHK);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.marketUS);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.marketSH);
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.marketSZ);
            writer.uint32(/* id 5, wireType 0 =*/40).int32(message.marketHKFuture);
            writer.uint32(/* id 6, wireType 0 =*/48).bool(message.qotLogined);
            writer.uint32(/* id 7, wireType 0 =*/56).bool(message.trdLogined);
            writer.uint32(/* id 8, wireType 0 =*/64).int32(message.serverVer);
            writer.uint32(/* id 9, wireType 0 =*/72).int32(message.serverBuildNo);
            writer.uint32(/* id 10, wireType 0 =*/80).int64(message.time);
            if (message.localTime != null && message.hasOwnProperty("localTime"))
                writer.uint32(/* id 11, wireType 1 =*/89).double(message.localTime);
            if (message.programStatus != null && message.hasOwnProperty("programStatus"))
                $root.GetGlobalState.ProgramStatus.encode(message.programStatus, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link GetGlobalState.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof GetGlobalState.S2C
         * @static
         * @param {GetGlobalState.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof GetGlobalState.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {GetGlobalState.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetGlobalState.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.marketHK = reader.int32();
                    break;
                case 2:
                    message.marketUS = reader.int32();
                    break;
                case 3:
                    message.marketSH = reader.int32();
                    break;
                case 4:
                    message.marketSZ = reader.int32();
                    break;
                case 5:
                    message.marketHKFuture = reader.int32();
                    break;
                case 6:
                    message.qotLogined = reader.bool();
                    break;
                case 7:
                    message.trdLogined = reader.bool();
                    break;
                case 8:
                    message.serverVer = reader.int32();
                    break;
                case 9:
                    message.serverBuildNo = reader.int32();
                    break;
                case 10:
                    message.time = reader.int64();
                    break;
                case 11:
                    message.localTime = reader.double();
                    break;
                case 12:
                    message.programStatus = $root.GetGlobalState.ProgramStatus.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("marketHK"))
                throw $util.ProtocolError("missing required 'marketHK'", { instance: message });
            if (!message.hasOwnProperty("marketUS"))
                throw $util.ProtocolError("missing required 'marketUS'", { instance: message });
            if (!message.hasOwnProperty("marketSH"))
                throw $util.ProtocolError("missing required 'marketSH'", { instance: message });
            if (!message.hasOwnProperty("marketSZ"))
                throw $util.ProtocolError("missing required 'marketSZ'", { instance: message });
            if (!message.hasOwnProperty("marketHKFuture"))
                throw $util.ProtocolError("missing required 'marketHKFuture'", { instance: message });
            if (!message.hasOwnProperty("qotLogined"))
                throw $util.ProtocolError("missing required 'qotLogined'", { instance: message });
            if (!message.hasOwnProperty("trdLogined"))
                throw $util.ProtocolError("missing required 'trdLogined'", { instance: message });
            if (!message.hasOwnProperty("serverVer"))
                throw $util.ProtocolError("missing required 'serverVer'", { instance: message });
            if (!message.hasOwnProperty("serverBuildNo"))
                throw $util.ProtocolError("missing required 'serverBuildNo'", { instance: message });
            if (!message.hasOwnProperty("time"))
                throw $util.ProtocolError("missing required 'time'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof GetGlobalState.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {GetGlobalState.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof GetGlobalState.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.marketHK))
                return "marketHK: integer expected";
            if (!$util.isInteger(message.marketUS))
                return "marketUS: integer expected";
            if (!$util.isInteger(message.marketSH))
                return "marketSH: integer expected";
            if (!$util.isInteger(message.marketSZ))
                return "marketSZ: integer expected";
            if (!$util.isInteger(message.marketHKFuture))
                return "marketHKFuture: integer expected";
            if (typeof message.qotLogined !== "boolean")
                return "qotLogined: boolean expected";
            if (typeof message.trdLogined !== "boolean")
                return "trdLogined: boolean expected";
            if (!$util.isInteger(message.serverVer))
                return "serverVer: integer expected";
            if (!$util.isInteger(message.serverBuildNo))
                return "serverBuildNo: integer expected";
            if (!$util.isInteger(message.time) && !(message.time && $util.isInteger(message.time.low) && $util.isInteger(message.time.high)))
                return "time: integer|Long expected";
            if (message.localTime != null && message.hasOwnProperty("localTime"))
                if (typeof message.localTime !== "number")
                    return "localTime: number expected";
            if (message.programStatus != null && message.hasOwnProperty("programStatus")) {
                var error = $root.GetGlobalState.ProgramStatus.verify(message.programStatus);
                if (error)
                    return "programStatus." + error;
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof GetGlobalState.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {GetGlobalState.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.GetGlobalState.S2C)
                return object;
            var message = new $root.GetGlobalState.S2C();
            if (object.marketHK != null)
                message.marketHK = object.marketHK | 0;
            if (object.marketUS != null)
                message.marketUS = object.marketUS | 0;
            if (object.marketSH != null)
                message.marketSH = object.marketSH | 0;
            if (object.marketSZ != null)
                message.marketSZ = object.marketSZ | 0;
            if (object.marketHKFuture != null)
                message.marketHKFuture = object.marketHKFuture | 0;
            if (object.qotLogined != null)
                message.qotLogined = Boolean(object.qotLogined);
            if (object.trdLogined != null)
                message.trdLogined = Boolean(object.trdLogined);
            if (object.serverVer != null)
                message.serverVer = object.serverVer | 0;
            if (object.serverBuildNo != null)
                message.serverBuildNo = object.serverBuildNo | 0;
            if (object.time != null)
                if ($util.Long)
                    (message.time = $util.Long.fromValue(object.time)).unsigned = false;
                else if (typeof object.time === "string")
                    message.time = parseInt(object.time, 10);
                else if (typeof object.time === "number")
                    message.time = object.time;
                else if (typeof object.time === "object")
                    message.time = new $util.LongBits(object.time.low >>> 0, object.time.high >>> 0).toNumber();
            if (object.localTime != null)
                message.localTime = Number(object.localTime);
            if (object.programStatus != null) {
                if (typeof object.programStatus !== "object")
                    throw TypeError(".GetGlobalState.S2C.programStatus: object expected");
                message.programStatus = $root.GetGlobalState.ProgramStatus.fromObject(object.programStatus);
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof GetGlobalState.S2C
         * @static
         * @param {GetGlobalState.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.marketHK = 0;
                object.marketUS = 0;
                object.marketSH = 0;
                object.marketSZ = 0;
                object.marketHKFuture = 0;
                object.qotLogined = false;
                object.trdLogined = false;
                object.serverVer = 0;
                object.serverBuildNo = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.time = options.longs === String ? "0" : 0;
                object.localTime = 0;
                object.programStatus = null;
            }
            if (message.marketHK != null && message.hasOwnProperty("marketHK"))
                object.marketHK = message.marketHK;
            if (message.marketUS != null && message.hasOwnProperty("marketUS"))
                object.marketUS = message.marketUS;
            if (message.marketSH != null && message.hasOwnProperty("marketSH"))
                object.marketSH = message.marketSH;
            if (message.marketSZ != null && message.hasOwnProperty("marketSZ"))
                object.marketSZ = message.marketSZ;
            if (message.marketHKFuture != null && message.hasOwnProperty("marketHKFuture"))
                object.marketHKFuture = message.marketHKFuture;
            if (message.qotLogined != null && message.hasOwnProperty("qotLogined"))
                object.qotLogined = message.qotLogined;
            if (message.trdLogined != null && message.hasOwnProperty("trdLogined"))
                object.trdLogined = message.trdLogined;
            if (message.serverVer != null && message.hasOwnProperty("serverVer"))
                object.serverVer = message.serverVer;
            if (message.serverBuildNo != null && message.hasOwnProperty("serverBuildNo"))
                object.serverBuildNo = message.serverBuildNo;
            if (message.time != null && message.hasOwnProperty("time"))
                if (typeof message.time === "number")
                    object.time = options.longs === String ? String(message.time) : message.time;
                else
                    object.time = options.longs === String ? $util.Long.prototype.toString.call(message.time) : options.longs === Number ? new $util.LongBits(message.time.low >>> 0, message.time.high >>> 0).toNumber() : message.time;
            if (message.localTime != null && message.hasOwnProperty("localTime"))
                object.localTime = options.json && !isFinite(message.localTime) ? String(message.localTime) : message.localTime;
            if (message.programStatus != null && message.hasOwnProperty("programStatus"))
                object.programStatus = $root.GetGlobalState.ProgramStatus.toObject(message.programStatus, options);
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof GetGlobalState.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    GetGlobalState.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof GetGlobalState
         * @interface IRequest
         * @property {GetGlobalState.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof GetGlobalState
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {GetGlobalState.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {GetGlobalState.IC2S} c2s
         * @memberof GetGlobalState.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof GetGlobalState.Request
         * @static
         * @param {GetGlobalState.IRequest=} [properties] Properties to set
         * @returns {GetGlobalState.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link GetGlobalState.Request.verify|verify} messages.
         * @function encode
         * @memberof GetGlobalState.Request
         * @static
         * @param {GetGlobalState.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.GetGlobalState.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link GetGlobalState.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof GetGlobalState.Request
         * @static
         * @param {GetGlobalState.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof GetGlobalState.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {GetGlobalState.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetGlobalState.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.GetGlobalState.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof GetGlobalState.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {GetGlobalState.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof GetGlobalState.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.GetGlobalState.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof GetGlobalState.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {GetGlobalState.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.GetGlobalState.Request)
                return object;
            var message = new $root.GetGlobalState.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".GetGlobalState.Request.c2s: object expected");
                message.c2s = $root.GetGlobalState.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof GetGlobalState.Request
         * @static
         * @param {GetGlobalState.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.GetGlobalState.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof GetGlobalState.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    GetGlobalState.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof GetGlobalState
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {GetGlobalState.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof GetGlobalState
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {GetGlobalState.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof GetGlobalState.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof GetGlobalState.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof GetGlobalState.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {GetGlobalState.IS2C|null|undefined} s2c
         * @memberof GetGlobalState.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof GetGlobalState.Response
         * @static
         * @param {GetGlobalState.IResponse=} [properties] Properties to set
         * @returns {GetGlobalState.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link GetGlobalState.Response.verify|verify} messages.
         * @function encode
         * @memberof GetGlobalState.Response
         * @static
         * @param {GetGlobalState.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.GetGlobalState.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link GetGlobalState.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof GetGlobalState.Response
         * @static
         * @param {GetGlobalState.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof GetGlobalState.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {GetGlobalState.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetGlobalState.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.GetGlobalState.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof GetGlobalState.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {GetGlobalState.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof GetGlobalState.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.GetGlobalState.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof GetGlobalState.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {GetGlobalState.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.GetGlobalState.Response)
                return object;
            var message = new $root.GetGlobalState.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".GetGlobalState.Response.s2c: object expected");
                message.s2c = $root.GetGlobalState.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof GetGlobalState.Response
         * @static
         * @param {GetGlobalState.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.GetGlobalState.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof GetGlobalState.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return GetGlobalState;
})();

$root.Qot_Common = (function() {

    /**
     * Namespace Qot_Common.
     * @exports Qot_Common
     * @namespace
     */
    var Qot_Common = {};

    /**
     * QotMarket enum.
     * @name Qot_Common.QotMarket
     * @enum {string}
     * @property {number} QotMarket_Unknown=0 QotMarket_Unknown value
     * @property {number} QotMarket_HK_Security=1 QotMarket_HK_Security value
     * @property {number} QotMarket_HK_Future=2 QotMarket_HK_Future value
     * @property {number} QotMarket_US_Security=11 QotMarket_US_Security value
     * @property {number} QotMarket_CNSH_Security=21 QotMarket_CNSH_Security value
     * @property {number} QotMarket_CNSZ_Security=22 QotMarket_CNSZ_Security value
     */
    Qot_Common.QotMarket = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "QotMarket_Unknown"] = 0;
        values[valuesById[1] = "QotMarket_HK_Security"] = 1;
        values[valuesById[2] = "QotMarket_HK_Future"] = 2;
        values[valuesById[11] = "QotMarket_US_Security"] = 11;
        values[valuesById[21] = "QotMarket_CNSH_Security"] = 21;
        values[valuesById[22] = "QotMarket_CNSZ_Security"] = 22;
        return values;
    })();

    /**
     * SecurityType enum.
     * @name Qot_Common.SecurityType
     * @enum {string}
     * @property {number} SecurityType_Unknown=0 SecurityType_Unknown value
     * @property {number} SecurityType_Bond=1 SecurityType_Bond value
     * @property {number} SecurityType_Bwrt=2 SecurityType_Bwrt value
     * @property {number} SecurityType_Eqty=3 SecurityType_Eqty value
     * @property {number} SecurityType_Trust=4 SecurityType_Trust value
     * @property {number} SecurityType_Warrant=5 SecurityType_Warrant value
     * @property {number} SecurityType_Index=6 SecurityType_Index value
     * @property {number} SecurityType_Plate=7 SecurityType_Plate value
     * @property {number} SecurityType_Drvt=8 SecurityType_Drvt value
     * @property {number} SecurityType_PlateSet=9 SecurityType_PlateSet value
     */
    Qot_Common.SecurityType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "SecurityType_Unknown"] = 0;
        values[valuesById[1] = "SecurityType_Bond"] = 1;
        values[valuesById[2] = "SecurityType_Bwrt"] = 2;
        values[valuesById[3] = "SecurityType_Eqty"] = 3;
        values[valuesById[4] = "SecurityType_Trust"] = 4;
        values[valuesById[5] = "SecurityType_Warrant"] = 5;
        values[valuesById[6] = "SecurityType_Index"] = 6;
        values[valuesById[7] = "SecurityType_Plate"] = 7;
        values[valuesById[8] = "SecurityType_Drvt"] = 8;
        values[valuesById[9] = "SecurityType_PlateSet"] = 9;
        return values;
    })();

    /**
     * PlateSetType enum.
     * @name Qot_Common.PlateSetType
     * @enum {string}
     * @property {number} PlateSetType_All=0 PlateSetType_All value
     * @property {number} PlateSetType_Industry=1 PlateSetType_Industry value
     * @property {number} PlateSetType_Region=2 PlateSetType_Region value
     * @property {number} PlateSetType_Concept=3 PlateSetType_Concept value
     * @property {number} PlateSetType_Other=4 PlateSetType_Other value
     */
    Qot_Common.PlateSetType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "PlateSetType_All"] = 0;
        values[valuesById[1] = "PlateSetType_Industry"] = 1;
        values[valuesById[2] = "PlateSetType_Region"] = 2;
        values[valuesById[3] = "PlateSetType_Concept"] = 3;
        values[valuesById[4] = "PlateSetType_Other"] = 4;
        return values;
    })();

    /**
     * WarrantType enum.
     * @name Qot_Common.WarrantType
     * @enum {string}
     * @property {number} WarrantType_Unknown=0 WarrantType_Unknown value
     * @property {number} WarrantType_Buy=1 WarrantType_Buy value
     * @property {number} WarrantType_Sell=2 WarrantType_Sell value
     * @property {number} WarrantType_Bull=3 WarrantType_Bull value
     * @property {number} WarrantType_Bear=4 WarrantType_Bear value
     */
    Qot_Common.WarrantType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "WarrantType_Unknown"] = 0;
        values[valuesById[1] = "WarrantType_Buy"] = 1;
        values[valuesById[2] = "WarrantType_Sell"] = 2;
        values[valuesById[3] = "WarrantType_Bull"] = 3;
        values[valuesById[4] = "WarrantType_Bear"] = 4;
        return values;
    })();

    /**
     * OptionType enum.
     * @name Qot_Common.OptionType
     * @enum {string}
     * @property {number} OptionType_Unknown=0 OptionType_Unknown value
     * @property {number} OptionType_Call=1 OptionType_Call value
     * @property {number} OptionType_Put=2 OptionType_Put value
     */
    Qot_Common.OptionType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "OptionType_Unknown"] = 0;
        values[valuesById[1] = "OptionType_Call"] = 1;
        values[valuesById[2] = "OptionType_Put"] = 2;
        return values;
    })();

    /**
     * QotMarketState enum.
     * @name Qot_Common.QotMarketState
     * @enum {string}
     * @property {number} QotMarketState_None=0 QotMarketState_None value
     * @property {number} QotMarketState_Auction=1 QotMarketState_Auction value
     * @property {number} QotMarketState_WaitingOpen=2 QotMarketState_WaitingOpen value
     * @property {number} QotMarketState_Morning=3 QotMarketState_Morning value
     * @property {number} QotMarketState_Rest=4 QotMarketState_Rest value
     * @property {number} QotMarketState_Afternoon=5 QotMarketState_Afternoon value
     * @property {number} QotMarketState_Closed=6 QotMarketState_Closed value
     * @property {number} QotMarketState_PreMarketBegin=8 QotMarketState_PreMarketBegin value
     * @property {number} QotMarketState_PreMarketEnd=9 QotMarketState_PreMarketEnd value
     * @property {number} QotMarketState_AfterHoursBegin=10 QotMarketState_AfterHoursBegin value
     * @property {number} QotMarketState_AfterHoursEnd=11 QotMarketState_AfterHoursEnd value
     * @property {number} QotMarketState_NightOpen=13 QotMarketState_NightOpen value
     * @property {number} QotMarketState_NightEnd=14 QotMarketState_NightEnd value
     * @property {number} QotMarketState_FutureDayOpen=15 QotMarketState_FutureDayOpen value
     * @property {number} QotMarketState_FutureDayBreak=16 QotMarketState_FutureDayBreak value
     * @property {number} QotMarketState_FutureDayClose=17 QotMarketState_FutureDayClose value
     * @property {number} QotMarketState_FutureDayWaitForOpen=18 QotMarketState_FutureDayWaitForOpen value
     * @property {number} QotMarketState_HkCas=19 QotMarketState_HkCas value
     */
    Qot_Common.QotMarketState = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "QotMarketState_None"] = 0;
        values[valuesById[1] = "QotMarketState_Auction"] = 1;
        values[valuesById[2] = "QotMarketState_WaitingOpen"] = 2;
        values[valuesById[3] = "QotMarketState_Morning"] = 3;
        values[valuesById[4] = "QotMarketState_Rest"] = 4;
        values[valuesById[5] = "QotMarketState_Afternoon"] = 5;
        values[valuesById[6] = "QotMarketState_Closed"] = 6;
        values[valuesById[8] = "QotMarketState_PreMarketBegin"] = 8;
        values[valuesById[9] = "QotMarketState_PreMarketEnd"] = 9;
        values[valuesById[10] = "QotMarketState_AfterHoursBegin"] = 10;
        values[valuesById[11] = "QotMarketState_AfterHoursEnd"] = 11;
        values[valuesById[13] = "QotMarketState_NightOpen"] = 13;
        values[valuesById[14] = "QotMarketState_NightEnd"] = 14;
        values[valuesById[15] = "QotMarketState_FutureDayOpen"] = 15;
        values[valuesById[16] = "QotMarketState_FutureDayBreak"] = 16;
        values[valuesById[17] = "QotMarketState_FutureDayClose"] = 17;
        values[valuesById[18] = "QotMarketState_FutureDayWaitForOpen"] = 18;
        values[valuesById[19] = "QotMarketState_HkCas"] = 19;
        return values;
    })();

    /**
     * TradeDateType enum.
     * @name Qot_Common.TradeDateType
     * @enum {string}
     * @property {number} TradeDateType_Whole=0 TradeDateType_Whole value
     * @property {number} TradeDateType_Morning=1 TradeDateType_Morning value
     * @property {number} TradeDateType_Afternoon=2 TradeDateType_Afternoon value
     */
    Qot_Common.TradeDateType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "TradeDateType_Whole"] = 0;
        values[valuesById[1] = "TradeDateType_Morning"] = 1;
        values[valuesById[2] = "TradeDateType_Afternoon"] = 2;
        return values;
    })();

    /**
     * RehabType enum.
     * @name Qot_Common.RehabType
     * @enum {string}
     * @property {number} RehabType_None=0 RehabType_None value
     * @property {number} RehabType_Forward=1 RehabType_Forward value
     * @property {number} RehabType_Backward=2 RehabType_Backward value
     */
    Qot_Common.RehabType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "RehabType_None"] = 0;
        values[valuesById[1] = "RehabType_Forward"] = 1;
        values[valuesById[2] = "RehabType_Backward"] = 2;
        return values;
    })();

    /**
     * KLType enum.
     * @name Qot_Common.KLType
     * @enum {string}
     * @property {number} KLType_Unknown=0 KLType_Unknown value
     * @property {number} KLType_1Min=1 KLType_1Min value
     * @property {number} KLType_Day=2 KLType_Day value
     * @property {number} KLType_Week=3 KLType_Week value
     * @property {number} KLType_Month=4 KLType_Month value
     * @property {number} KLType_Year=5 KLType_Year value
     * @property {number} KLType_5Min=6 KLType_5Min value
     * @property {number} KLType_15Min=7 KLType_15Min value
     * @property {number} KLType_30Min=8 KLType_30Min value
     * @property {number} KLType_60Min=9 KLType_60Min value
     * @property {number} KLType_3Min=10 KLType_3Min value
     * @property {number} KLType_Quarter=11 KLType_Quarter value
     */
    Qot_Common.KLType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "KLType_Unknown"] = 0;
        values[valuesById[1] = "KLType_1Min"] = 1;
        values[valuesById[2] = "KLType_Day"] = 2;
        values[valuesById[3] = "KLType_Week"] = 3;
        values[valuesById[4] = "KLType_Month"] = 4;
        values[valuesById[5] = "KLType_Year"] = 5;
        values[valuesById[6] = "KLType_5Min"] = 6;
        values[valuesById[7] = "KLType_15Min"] = 7;
        values[valuesById[8] = "KLType_30Min"] = 8;
        values[valuesById[9] = "KLType_60Min"] = 9;
        values[valuesById[10] = "KLType_3Min"] = 10;
        values[valuesById[11] = "KLType_Quarter"] = 11;
        return values;
    })();

    /**
     * KLFields enum.
     * @name Qot_Common.KLFields
     * @enum {string}
     * @property {number} KLFields_None=0 KLFields_None value
     * @property {number} KLFields_High=1 KLFields_High value
     * @property {number} KLFields_Open=2 KLFields_Open value
     * @property {number} KLFields_Low=4 KLFields_Low value
     * @property {number} KLFields_Close=8 KLFields_Close value
     * @property {number} KLFields_LastClose=16 KLFields_LastClose value
     * @property {number} KLFields_Volume=32 KLFields_Volume value
     * @property {number} KLFields_Turnover=64 KLFields_Turnover value
     * @property {number} KLFields_TurnoverRate=128 KLFields_TurnoverRate value
     * @property {number} KLFields_PE=256 KLFields_PE value
     * @property {number} KLFields_ChangeRate=512 KLFields_ChangeRate value
     */
    Qot_Common.KLFields = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "KLFields_None"] = 0;
        values[valuesById[1] = "KLFields_High"] = 1;
        values[valuesById[2] = "KLFields_Open"] = 2;
        values[valuesById[4] = "KLFields_Low"] = 4;
        values[valuesById[8] = "KLFields_Close"] = 8;
        values[valuesById[16] = "KLFields_LastClose"] = 16;
        values[valuesById[32] = "KLFields_Volume"] = 32;
        values[valuesById[64] = "KLFields_Turnover"] = 64;
        values[valuesById[128] = "KLFields_TurnoverRate"] = 128;
        values[valuesById[256] = "KLFields_PE"] = 256;
        values[valuesById[512] = "KLFields_ChangeRate"] = 512;
        return values;
    })();

    /**
     * SubType enum.
     * @name Qot_Common.SubType
     * @enum {string}
     * @property {number} SubType_None=0 SubType_None value
     * @property {number} SubType_Basic=1 SubType_Basic value
     * @property {number} SubType_OrderBook=2 SubType_OrderBook value
     * @property {number} SubType_Ticker=4 SubType_Ticker value
     * @property {number} SubType_RT=5 SubType_RT value
     * @property {number} SubType_KL_Day=6 SubType_KL_Day value
     * @property {number} SubType_KL_5Min=7 SubType_KL_5Min value
     * @property {number} SubType_KL_15Min=8 SubType_KL_15Min value
     * @property {number} SubType_KL_30Min=9 SubType_KL_30Min value
     * @property {number} SubType_KL_60Min=10 SubType_KL_60Min value
     * @property {number} SubType_KL_1Min=11 SubType_KL_1Min value
     * @property {number} SubType_KL_Week=12 SubType_KL_Week value
     * @property {number} SubType_KL_Month=13 SubType_KL_Month value
     * @property {number} SubType_Broker=14 SubType_Broker value
     * @property {number} SubType_KL_Qurater=15 SubType_KL_Qurater value
     * @property {number} SubType_KL_Year=16 SubType_KL_Year value
     * @property {number} SubType_KL_3Min=17 SubType_KL_3Min value
     * @property {number} SubType_OrderDetail=18 SubType_OrderDetail value
     */
    Qot_Common.SubType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "SubType_None"] = 0;
        values[valuesById[1] = "SubType_Basic"] = 1;
        values[valuesById[2] = "SubType_OrderBook"] = 2;
        values[valuesById[4] = "SubType_Ticker"] = 4;
        values[valuesById[5] = "SubType_RT"] = 5;
        values[valuesById[6] = "SubType_KL_Day"] = 6;
        values[valuesById[7] = "SubType_KL_5Min"] = 7;
        values[valuesById[8] = "SubType_KL_15Min"] = 8;
        values[valuesById[9] = "SubType_KL_30Min"] = 9;
        values[valuesById[10] = "SubType_KL_60Min"] = 10;
        values[valuesById[11] = "SubType_KL_1Min"] = 11;
        values[valuesById[12] = "SubType_KL_Week"] = 12;
        values[valuesById[13] = "SubType_KL_Month"] = 13;
        values[valuesById[14] = "SubType_Broker"] = 14;
        values[valuesById[15] = "SubType_KL_Qurater"] = 15;
        values[valuesById[16] = "SubType_KL_Year"] = 16;
        values[valuesById[17] = "SubType_KL_3Min"] = 17;
        values[valuesById[18] = "SubType_OrderDetail"] = 18;
        return values;
    })();

    /**
     * TickerDirection enum.
     * @name Qot_Common.TickerDirection
     * @enum {string}
     * @property {number} TickerDirection_Unknown=0 TickerDirection_Unknown value
     * @property {number} TickerDirection_Bid=1 TickerDirection_Bid value
     * @property {number} TickerDirection_Ask=2 TickerDirection_Ask value
     * @property {number} TickerDirection_Neutral=3 TickerDirection_Neutral value
     */
    Qot_Common.TickerDirection = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "TickerDirection_Unknown"] = 0;
        values[valuesById[1] = "TickerDirection_Bid"] = 1;
        values[valuesById[2] = "TickerDirection_Ask"] = 2;
        values[valuesById[3] = "TickerDirection_Neutral"] = 3;
        return values;
    })();

    /**
     * TickerType enum.
     * @name Qot_Common.TickerType
     * @enum {string}
     * @property {number} TickerType_Unknown=0 TickerType_Unknown value
     * @property {number} TickerType_Automatch=1 TickerType_Automatch value
     * @property {number} TickerType_Late=2 TickerType_Late value
     * @property {number} TickerType_NoneAutomatch=3 TickerType_NoneAutomatch value
     * @property {number} TickerType_InterAutomatch=4 TickerType_InterAutomatch value
     * @property {number} TickerType_InterNoneAutomatch=5 TickerType_InterNoneAutomatch value
     * @property {number} TickerType_OddLot=6 TickerType_OddLot value
     * @property {number} TickerType_Auction=7 TickerType_Auction value
     * @property {number} TickerType_Bulk=8 TickerType_Bulk value
     * @property {number} TickerType_Crash=9 TickerType_Crash value
     * @property {number} TickerType_CrossMarket=10 TickerType_CrossMarket value
     * @property {number} TickerType_BulkSold=11 TickerType_BulkSold value
     * @property {number} TickerType_FreeOnBoard=12 TickerType_FreeOnBoard value
     * @property {number} TickerType_Rule127Or155=13 TickerType_Rule127Or155 value
     * @property {number} TickerType_Delay=14 TickerType_Delay value
     * @property {number} TickerType_MarketCenterClosePrice=15 TickerType_MarketCenterClosePrice value
     * @property {number} TickerType_NextDay=16 TickerType_NextDay value
     * @property {number} TickerType_MarketCenterOpening=17 TickerType_MarketCenterOpening value
     * @property {number} TickerType_PriorReferencePrice=18 TickerType_PriorReferencePrice value
     * @property {number} TickerType_MarketCenterOpenPrice=19 TickerType_MarketCenterOpenPrice value
     * @property {number} TickerType_Seller=20 TickerType_Seller value
     * @property {number} TickerType_T=21 TickerType_T value
     * @property {number} TickerType_ExtendedTradingHours=22 TickerType_ExtendedTradingHours value
     * @property {number} TickerType_Contingent=23 TickerType_Contingent value
     * @property {number} TickerType_AveragePrice=24 TickerType_AveragePrice value
     * @property {number} TickerType_OTCSold=25 TickerType_OTCSold value
     * @property {number} TickerType_OddLotCrossMarket=26 TickerType_OddLotCrossMarket value
     * @property {number} TickerType_DerivativelyPriced=27 TickerType_DerivativelyPriced value
     * @property {number} TickerType_ReOpeningPriced=28 TickerType_ReOpeningPriced value
     * @property {number} TickerType_ClosingPriced=29 TickerType_ClosingPriced value
     * @property {number} TickerType_ComprehensiveDelayPrice=30 TickerType_ComprehensiveDelayPrice value
     */
    Qot_Common.TickerType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "TickerType_Unknown"] = 0;
        values[valuesById[1] = "TickerType_Automatch"] = 1;
        values[valuesById[2] = "TickerType_Late"] = 2;
        values[valuesById[3] = "TickerType_NoneAutomatch"] = 3;
        values[valuesById[4] = "TickerType_InterAutomatch"] = 4;
        values[valuesById[5] = "TickerType_InterNoneAutomatch"] = 5;
        values[valuesById[6] = "TickerType_OddLot"] = 6;
        values[valuesById[7] = "TickerType_Auction"] = 7;
        values[valuesById[8] = "TickerType_Bulk"] = 8;
        values[valuesById[9] = "TickerType_Crash"] = 9;
        values[valuesById[10] = "TickerType_CrossMarket"] = 10;
        values[valuesById[11] = "TickerType_BulkSold"] = 11;
        values[valuesById[12] = "TickerType_FreeOnBoard"] = 12;
        values[valuesById[13] = "TickerType_Rule127Or155"] = 13;
        values[valuesById[14] = "TickerType_Delay"] = 14;
        values[valuesById[15] = "TickerType_MarketCenterClosePrice"] = 15;
        values[valuesById[16] = "TickerType_NextDay"] = 16;
        values[valuesById[17] = "TickerType_MarketCenterOpening"] = 17;
        values[valuesById[18] = "TickerType_PriorReferencePrice"] = 18;
        values[valuesById[19] = "TickerType_MarketCenterOpenPrice"] = 19;
        values[valuesById[20] = "TickerType_Seller"] = 20;
        values[valuesById[21] = "TickerType_T"] = 21;
        values[valuesById[22] = "TickerType_ExtendedTradingHours"] = 22;
        values[valuesById[23] = "TickerType_Contingent"] = 23;
        values[valuesById[24] = "TickerType_AveragePrice"] = 24;
        values[valuesById[25] = "TickerType_OTCSold"] = 25;
        values[valuesById[26] = "TickerType_OddLotCrossMarket"] = 26;
        values[valuesById[27] = "TickerType_DerivativelyPriced"] = 27;
        values[valuesById[28] = "TickerType_ReOpeningPriced"] = 28;
        values[valuesById[29] = "TickerType_ClosingPriced"] = 29;
        values[valuesById[30] = "TickerType_ComprehensiveDelayPrice"] = 30;
        return values;
    })();

    /**
     * DarkStatus enum.
     * @name Qot_Common.DarkStatus
     * @enum {string}
     * @property {number} DarkStatus_None=0 DarkStatus_None value
     * @property {number} DarkStatus_Trading=1 DarkStatus_Trading value
     * @property {number} DarkStatus_End=2 DarkStatus_End value
     */
    Qot_Common.DarkStatus = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DarkStatus_None"] = 0;
        values[valuesById[1] = "DarkStatus_Trading"] = 1;
        values[valuesById[2] = "DarkStatus_End"] = 2;
        return values;
    })();

    /**
     * HolderCategory enum.
     * @name Qot_Common.HolderCategory
     * @enum {string}
     * @property {number} HolderCategory_Unknow=0 HolderCategory_Unknow value
     * @property {number} HolderCategory_Agency=1 HolderCategory_Agency value
     * @property {number} HolderCategory_Fund=2 HolderCategory_Fund value
     * @property {number} HolderCategory_SeniorManager=3 HolderCategory_SeniorManager value
     */
    Qot_Common.HolderCategory = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "HolderCategory_Unknow"] = 0;
        values[valuesById[1] = "HolderCategory_Agency"] = 1;
        values[valuesById[2] = "HolderCategory_Fund"] = 2;
        values[valuesById[3] = "HolderCategory_SeniorManager"] = 3;
        return values;
    })();

    /**
     * PushDataType enum.
     * @name Qot_Common.PushDataType
     * @enum {string}
     * @property {number} PushDataType_Unknow=0 PushDataType_Unknow value
     * @property {number} PushDataType_Realtime=1 PushDataType_Realtime value
     * @property {number} PushDataType_ByDisConn=2 PushDataType_ByDisConn value
     * @property {number} PushDataType_Cache=3 PushDataType_Cache value
     */
    Qot_Common.PushDataType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "PushDataType_Unknow"] = 0;
        values[valuesById[1] = "PushDataType_Realtime"] = 1;
        values[valuesById[2] = "PushDataType_ByDisConn"] = 2;
        values[valuesById[3] = "PushDataType_Cache"] = 3;
        return values;
    })();

    /**
     * SortField enum.
     * @name Qot_Common.SortField
     * @enum {string}
     * @property {number} SortField_Unknow=0 SortField_Unknow value
     * @property {number} SortField_Code=1 SortField_Code value
     * @property {number} SortField_CurPrice=2 SortField_CurPrice value
     * @property {number} SortField_PriceChangeVal=3 SortField_PriceChangeVal value
     * @property {number} SortField_ChangeRate=4 SortField_ChangeRate value
     * @property {number} SortField_Status=5 SortField_Status value
     * @property {number} SortField_BidPrice=6 SortField_BidPrice value
     * @property {number} SortField_AskPrice=7 SortField_AskPrice value
     * @property {number} SortField_BidVol=8 SortField_BidVol value
     * @property {number} SortField_AskVol=9 SortField_AskVol value
     * @property {number} SortField_Volume=10 SortField_Volume value
     * @property {number} SortField_Turnover=11 SortField_Turnover value
     * @property {number} SortField_Score=12 SortField_Score value
     * @property {number} SortField_Premium=13 SortField_Premium value
     * @property {number} SortField_EffectiveLeverage=14 SortField_EffectiveLeverage value
     * @property {number} SortField_Delta=15 SortField_Delta value
     * @property {number} SortField_ImpliedVolatility=16 SortField_ImpliedVolatility value
     * @property {number} SortField_Type=17 SortField_Type value
     * @property {number} SortField_StrikePrice=18 SortField_StrikePrice value
     * @property {number} SortField_BreakEvenPoint=19 SortField_BreakEvenPoint value
     * @property {number} SortField_MaturityTime=20 SortField_MaturityTime value
     * @property {number} SortField_ListTime=21 SortField_ListTime value
     * @property {number} SortField_LastTradeTime=22 SortField_LastTradeTime value
     * @property {number} SortField_Leverage=23 SortField_Leverage value
     * @property {number} SortField_InOutMoney=24 SortField_InOutMoney value
     * @property {number} SortField_RecoveryPrice=25 SortField_RecoveryPrice value
     * @property {number} SortField_ChangePrice=26 SortField_ChangePrice value
     * @property {number} SortField_Change=27 SortField_Change value
     * @property {number} SortField_StreetRate=28 SortField_StreetRate value
     * @property {number} SortField_StreetVol=29 SortField_StreetVol value
     * @property {number} SortField_Amplitude=30 SortField_Amplitude value
     * @property {number} SortField_WarrantName=31 SortField_WarrantName value
     * @property {number} SortField_Issuer=32 SortField_Issuer value
     * @property {number} SortField_LotSize=33 SortField_LotSize value
     * @property {number} SortField_IssueSize=34 SortField_IssueSize value
     */
    Qot_Common.SortField = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "SortField_Unknow"] = 0;
        values[valuesById[1] = "SortField_Code"] = 1;
        values[valuesById[2] = "SortField_CurPrice"] = 2;
        values[valuesById[3] = "SortField_PriceChangeVal"] = 3;
        values[valuesById[4] = "SortField_ChangeRate"] = 4;
        values[valuesById[5] = "SortField_Status"] = 5;
        values[valuesById[6] = "SortField_BidPrice"] = 6;
        values[valuesById[7] = "SortField_AskPrice"] = 7;
        values[valuesById[8] = "SortField_BidVol"] = 8;
        values[valuesById[9] = "SortField_AskVol"] = 9;
        values[valuesById[10] = "SortField_Volume"] = 10;
        values[valuesById[11] = "SortField_Turnover"] = 11;
        values[valuesById[12] = "SortField_Score"] = 12;
        values[valuesById[13] = "SortField_Premium"] = 13;
        values[valuesById[14] = "SortField_EffectiveLeverage"] = 14;
        values[valuesById[15] = "SortField_Delta"] = 15;
        values[valuesById[16] = "SortField_ImpliedVolatility"] = 16;
        values[valuesById[17] = "SortField_Type"] = 17;
        values[valuesById[18] = "SortField_StrikePrice"] = 18;
        values[valuesById[19] = "SortField_BreakEvenPoint"] = 19;
        values[valuesById[20] = "SortField_MaturityTime"] = 20;
        values[valuesById[21] = "SortField_ListTime"] = 21;
        values[valuesById[22] = "SortField_LastTradeTime"] = 22;
        values[valuesById[23] = "SortField_Leverage"] = 23;
        values[valuesById[24] = "SortField_InOutMoney"] = 24;
        values[valuesById[25] = "SortField_RecoveryPrice"] = 25;
        values[valuesById[26] = "SortField_ChangePrice"] = 26;
        values[valuesById[27] = "SortField_Change"] = 27;
        values[valuesById[28] = "SortField_StreetRate"] = 28;
        values[valuesById[29] = "SortField_StreetVol"] = 29;
        values[valuesById[30] = "SortField_Amplitude"] = 30;
        values[valuesById[31] = "SortField_WarrantName"] = 31;
        values[valuesById[32] = "SortField_Issuer"] = 32;
        values[valuesById[33] = "SortField_LotSize"] = 33;
        values[valuesById[34] = "SortField_IssueSize"] = 34;
        return values;
    })();

    /**
     * Issuer enum.
     * @name Qot_Common.Issuer
     * @enum {string}
     * @property {number} Issuer_Unknow=0 Issuer_Unknow value
     * @property {number} Issuer_SG=1 Issuer_SG value
     * @property {number} Issuer_BP=2 Issuer_BP value
     * @property {number} Issuer_CS=3 Issuer_CS value
     * @property {number} Issuer_CT=4 Issuer_CT value
     * @property {number} Issuer_EA=5 Issuer_EA value
     * @property {number} Issuer_GS=6 Issuer_GS value
     * @property {number} Issuer_HS=7 Issuer_HS value
     * @property {number} Issuer_JP=8 Issuer_JP value
     * @property {number} Issuer_MB=9 Issuer_MB value
     * @property {number} Issuer_SC=10 Issuer_SC value
     * @property {number} Issuer_UB=11 Issuer_UB value
     * @property {number} Issuer_BI=12 Issuer_BI value
     * @property {number} Issuer_DB=13 Issuer_DB value
     * @property {number} Issuer_DC=14 Issuer_DC value
     * @property {number} Issuer_ML=15 Issuer_ML value
     * @property {number} Issuer_NM=16 Issuer_NM value
     * @property {number} Issuer_RB=17 Issuer_RB value
     * @property {number} Issuer_RS=18 Issuer_RS value
     * @property {number} Issuer_BC=19 Issuer_BC value
     * @property {number} Issuer_HT=20 Issuer_HT value
     * @property {number} Issuer_VT=21 Issuer_VT value
     * @property {number} Issuer_KC=22 Issuer_KC value
     */
    Qot_Common.Issuer = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "Issuer_Unknow"] = 0;
        values[valuesById[1] = "Issuer_SG"] = 1;
        values[valuesById[2] = "Issuer_BP"] = 2;
        values[valuesById[3] = "Issuer_CS"] = 3;
        values[valuesById[4] = "Issuer_CT"] = 4;
        values[valuesById[5] = "Issuer_EA"] = 5;
        values[valuesById[6] = "Issuer_GS"] = 6;
        values[valuesById[7] = "Issuer_HS"] = 7;
        values[valuesById[8] = "Issuer_JP"] = 8;
        values[valuesById[9] = "Issuer_MB"] = 9;
        values[valuesById[10] = "Issuer_SC"] = 10;
        values[valuesById[11] = "Issuer_UB"] = 11;
        values[valuesById[12] = "Issuer_BI"] = 12;
        values[valuesById[13] = "Issuer_DB"] = 13;
        values[valuesById[14] = "Issuer_DC"] = 14;
        values[valuesById[15] = "Issuer_ML"] = 15;
        values[valuesById[16] = "Issuer_NM"] = 16;
        values[valuesById[17] = "Issuer_RB"] = 17;
        values[valuesById[18] = "Issuer_RS"] = 18;
        values[valuesById[19] = "Issuer_BC"] = 19;
        values[valuesById[20] = "Issuer_HT"] = 20;
        values[valuesById[21] = "Issuer_VT"] = 21;
        values[valuesById[22] = "Issuer_KC"] = 22;
        return values;
    })();

    /**
     * IpoPeriod enum.
     * @name Qot_Common.IpoPeriod
     * @enum {string}
     * @property {number} IpoPeriod_Unknow=0 IpoPeriod_Unknow value
     * @property {number} IpoPeriod_Today=1 IpoPeriod_Today value
     * @property {number} IpoPeriod_Tomorrow=2 IpoPeriod_Tomorrow value
     * @property {number} IpoPeriod_Nextweek=3 IpoPeriod_Nextweek value
     * @property {number} IpoPeriod_Lastweek=4 IpoPeriod_Lastweek value
     * @property {number} IpoPeriod_Lastmonth=5 IpoPeriod_Lastmonth value
     */
    Qot_Common.IpoPeriod = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "IpoPeriod_Unknow"] = 0;
        values[valuesById[1] = "IpoPeriod_Today"] = 1;
        values[valuesById[2] = "IpoPeriod_Tomorrow"] = 2;
        values[valuesById[3] = "IpoPeriod_Nextweek"] = 3;
        values[valuesById[4] = "IpoPeriod_Lastweek"] = 4;
        values[valuesById[5] = "IpoPeriod_Lastmonth"] = 5;
        return values;
    })();

    /**
     * PriceType enum.
     * @name Qot_Common.PriceType
     * @enum {string}
     * @property {number} PriceType_Unknow=0 PriceType_Unknow value
     * @property {number} PriceType_Outside=1 PriceType_Outside value
     * @property {number} PriceType_WithIn=2 PriceType_WithIn value
     */
    Qot_Common.PriceType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "PriceType_Unknow"] = 0;
        values[valuesById[1] = "PriceType_Outside"] = 1;
        values[valuesById[2] = "PriceType_WithIn"] = 2;
        return values;
    })();

    /**
     * WarrantStatus enum.
     * @name Qot_Common.WarrantStatus
     * @enum {string}
     * @property {number} WarrantStatus_Unknow=0 WarrantStatus_Unknow value
     * @property {number} WarrantStatus_Normal=1 WarrantStatus_Normal value
     * @property {number} WarrantStatus_Suspend=2 WarrantStatus_Suspend value
     * @property {number} WarrantStatus_StopTrade=3 WarrantStatus_StopTrade value
     * @property {number} WarrantStatus_PendingListing=4 WarrantStatus_PendingListing value
     */
    Qot_Common.WarrantStatus = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "WarrantStatus_Unknow"] = 0;
        values[valuesById[1] = "WarrantStatus_Normal"] = 1;
        values[valuesById[2] = "WarrantStatus_Suspend"] = 2;
        values[valuesById[3] = "WarrantStatus_StopTrade"] = 3;
        values[valuesById[4] = "WarrantStatus_PendingListing"] = 4;
        return values;
    })();

    /**
     * CompanyAct enum.
     * @name Qot_Common.CompanyAct
     * @enum {string}
     * @property {number} CompanyAct_None=0 CompanyAct_None value
     * @property {number} CompanyAct_Split=1 CompanyAct_Split value
     * @property {number} CompanyAct_Join=2 CompanyAct_Join value
     * @property {number} CompanyAct_Bonus=4 CompanyAct_Bonus value
     * @property {number} CompanyAct_Transfer=8 CompanyAct_Transfer value
     * @property {number} CompanyAct_Allot=16 CompanyAct_Allot value
     * @property {number} CompanyAct_Add=32 CompanyAct_Add value
     * @property {number} CompanyAct_Dividend=64 CompanyAct_Dividend value
     * @property {number} CompanyAct_SPDividend=128 CompanyAct_SPDividend value
     */
    Qot_Common.CompanyAct = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "CompanyAct_None"] = 0;
        values[valuesById[1] = "CompanyAct_Split"] = 1;
        values[valuesById[2] = "CompanyAct_Join"] = 2;
        values[valuesById[4] = "CompanyAct_Bonus"] = 4;
        values[valuesById[8] = "CompanyAct_Transfer"] = 8;
        values[valuesById[16] = "CompanyAct_Allot"] = 16;
        values[valuesById[32] = "CompanyAct_Add"] = 32;
        values[valuesById[64] = "CompanyAct_Dividend"] = 64;
        values[valuesById[128] = "CompanyAct_SPDividend"] = 128;
        return values;
    })();

    Qot_Common.Security = (function() {

        /**
         * Properties of a Security.
         * @memberof Qot_Common
         * @interface ISecurity
         * @property {number} market Security market
         * @property {string} code Security code
         */

        /**
         * Constructs a new Security.
         * @memberof Qot_Common
         * @classdesc Represents a Security.
         * @implements ISecurity
         * @constructor
         * @param {Qot_Common.ISecurity=} [properties] Properties to set
         */
        function Security(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Security market.
         * @member {number} market
         * @memberof Qot_Common.Security
         * @instance
         */
        Security.prototype.market = 0;

        /**
         * Security code.
         * @member {string} code
         * @memberof Qot_Common.Security
         * @instance
         */
        Security.prototype.code = "";

        /**
         * Creates a new Security instance using the specified properties.
         * @function create
         * @memberof Qot_Common.Security
         * @static
         * @param {Qot_Common.ISecurity=} [properties] Properties to set
         * @returns {Qot_Common.Security} Security instance
         */
        Security.create = function create(properties) {
            return new Security(properties);
        };

        /**
         * Encodes the specified Security message. Does not implicitly {@link Qot_Common.Security.verify|verify} messages.
         * @function encode
         * @memberof Qot_Common.Security
         * @static
         * @param {Qot_Common.ISecurity} message Security message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Security.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.market);
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.code);
            return writer;
        };

        /**
         * Encodes the specified Security message, length delimited. Does not implicitly {@link Qot_Common.Security.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_Common.Security
         * @static
         * @param {Qot_Common.ISecurity} message Security message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Security.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Security message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_Common.Security
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_Common.Security} Security
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Security.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_Common.Security();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.market = reader.int32();
                    break;
                case 2:
                    message.code = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("market"))
                throw $util.ProtocolError("missing required 'market'", { instance: message });
            if (!message.hasOwnProperty("code"))
                throw $util.ProtocolError("missing required 'code'", { instance: message });
            return message;
        };

        /**
         * Decodes a Security message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_Common.Security
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_Common.Security} Security
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Security.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Security message.
         * @function verify
         * @memberof Qot_Common.Security
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Security.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.market))
                return "market: integer expected";
            if (!$util.isString(message.code))
                return "code: string expected";
            return null;
        };

        /**
         * Creates a Security message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_Common.Security
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_Common.Security} Security
         */
        Security.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_Common.Security)
                return object;
            var message = new $root.Qot_Common.Security();
            if (object.market != null)
                message.market = object.market | 0;
            if (object.code != null)
                message.code = String(object.code);
            return message;
        };

        /**
         * Creates a plain object from a Security message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_Common.Security
         * @static
         * @param {Qot_Common.Security} message Security
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Security.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.market = 0;
                object.code = "";
            }
            if (message.market != null && message.hasOwnProperty("market"))
                object.market = message.market;
            if (message.code != null && message.hasOwnProperty("code"))
                object.code = message.code;
            return object;
        };

        /**
         * Converts this Security to JSON.
         * @function toJSON
         * @memberof Qot_Common.Security
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Security.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Security;
    })();

    Qot_Common.KLine = (function() {

        /**
         * Properties of a KLine.
         * @memberof Qot_Common
         * @interface IKLine
         * @property {string} time KLine time
         * @property {boolean} isBlank KLine isBlank
         * @property {number|null} [highPrice] KLine highPrice
         * @property {number|null} [openPrice] KLine openPrice
         * @property {number|null} [lowPrice] KLine lowPrice
         * @property {number|null} [closePrice] KLine closePrice
         * @property {number|null} [lastClosePrice] KLine lastClosePrice
         * @property {number|Long|null} [volume] KLine volume
         * @property {number|null} [turnover] KLine turnover
         * @property {number|null} [turnoverRate] KLine turnoverRate
         * @property {number|null} [pe] KLine pe
         * @property {number|null} [changeRate] KLine changeRate
         * @property {number|null} [timestamp] KLine timestamp
         */

        /**
         * Constructs a new KLine.
         * @memberof Qot_Common
         * @classdesc Represents a KLine.
         * @implements IKLine
         * @constructor
         * @param {Qot_Common.IKLine=} [properties] Properties to set
         */
        function KLine(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * KLine time.
         * @member {string} time
         * @memberof Qot_Common.KLine
         * @instance
         */
        KLine.prototype.time = "";

        /**
         * KLine isBlank.
         * @member {boolean} isBlank
         * @memberof Qot_Common.KLine
         * @instance
         */
        KLine.prototype.isBlank = false;

        /**
         * KLine highPrice.
         * @member {number} highPrice
         * @memberof Qot_Common.KLine
         * @instance
         */
        KLine.prototype.highPrice = 0;

        /**
         * KLine openPrice.
         * @member {number} openPrice
         * @memberof Qot_Common.KLine
         * @instance
         */
        KLine.prototype.openPrice = 0;

        /**
         * KLine lowPrice.
         * @member {number} lowPrice
         * @memberof Qot_Common.KLine
         * @instance
         */
        KLine.prototype.lowPrice = 0;

        /**
         * KLine closePrice.
         * @member {number} closePrice
         * @memberof Qot_Common.KLine
         * @instance
         */
        KLine.prototype.closePrice = 0;

        /**
         * KLine lastClosePrice.
         * @member {number} lastClosePrice
         * @memberof Qot_Common.KLine
         * @instance
         */
        KLine.prototype.lastClosePrice = 0;

        /**
         * KLine volume.
         * @member {number|Long} volume
         * @memberof Qot_Common.KLine
         * @instance
         */
        KLine.prototype.volume = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * KLine turnover.
         * @member {number} turnover
         * @memberof Qot_Common.KLine
         * @instance
         */
        KLine.prototype.turnover = 0;

        /**
         * KLine turnoverRate.
         * @member {number} turnoverRate
         * @memberof Qot_Common.KLine
         * @instance
         */
        KLine.prototype.turnoverRate = 0;

        /**
         * KLine pe.
         * @member {number} pe
         * @memberof Qot_Common.KLine
         * @instance
         */
        KLine.prototype.pe = 0;

        /**
         * KLine changeRate.
         * @member {number} changeRate
         * @memberof Qot_Common.KLine
         * @instance
         */
        KLine.prototype.changeRate = 0;

        /**
         * KLine timestamp.
         * @member {number} timestamp
         * @memberof Qot_Common.KLine
         * @instance
         */
        KLine.prototype.timestamp = 0;

        /**
         * Creates a new KLine instance using the specified properties.
         * @function create
         * @memberof Qot_Common.KLine
         * @static
         * @param {Qot_Common.IKLine=} [properties] Properties to set
         * @returns {Qot_Common.KLine} KLine instance
         */
        KLine.create = function create(properties) {
            return new KLine(properties);
        };

        /**
         * Encodes the specified KLine message. Does not implicitly {@link Qot_Common.KLine.verify|verify} messages.
         * @function encode
         * @memberof Qot_Common.KLine
         * @static
         * @param {Qot_Common.IKLine} message KLine message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KLine.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.time);
            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isBlank);
            if (message.highPrice != null && message.hasOwnProperty("highPrice"))
                writer.uint32(/* id 3, wireType 1 =*/25).double(message.highPrice);
            if (message.openPrice != null && message.hasOwnProperty("openPrice"))
                writer.uint32(/* id 4, wireType 1 =*/33).double(message.openPrice);
            if (message.lowPrice != null && message.hasOwnProperty("lowPrice"))
                writer.uint32(/* id 5, wireType 1 =*/41).double(message.lowPrice);
            if (message.closePrice != null && message.hasOwnProperty("closePrice"))
                writer.uint32(/* id 6, wireType 1 =*/49).double(message.closePrice);
            if (message.lastClosePrice != null && message.hasOwnProperty("lastClosePrice"))
                writer.uint32(/* id 7, wireType 1 =*/57).double(message.lastClosePrice);
            if (message.volume != null && message.hasOwnProperty("volume"))
                writer.uint32(/* id 8, wireType 0 =*/64).int64(message.volume);
            if (message.turnover != null && message.hasOwnProperty("turnover"))
                writer.uint32(/* id 9, wireType 1 =*/73).double(message.turnover);
            if (message.turnoverRate != null && message.hasOwnProperty("turnoverRate"))
                writer.uint32(/* id 10, wireType 1 =*/81).double(message.turnoverRate);
            if (message.pe != null && message.hasOwnProperty("pe"))
                writer.uint32(/* id 11, wireType 1 =*/89).double(message.pe);
            if (message.changeRate != null && message.hasOwnProperty("changeRate"))
                writer.uint32(/* id 12, wireType 1 =*/97).double(message.changeRate);
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                writer.uint32(/* id 13, wireType 1 =*/105).double(message.timestamp);
            return writer;
        };

        /**
         * Encodes the specified KLine message, length delimited. Does not implicitly {@link Qot_Common.KLine.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_Common.KLine
         * @static
         * @param {Qot_Common.IKLine} message KLine message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KLine.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a KLine message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_Common.KLine
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_Common.KLine} KLine
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KLine.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_Common.KLine();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.time = reader.string();
                    break;
                case 2:
                    message.isBlank = reader.bool();
                    break;
                case 3:
                    message.highPrice = reader.double();
                    break;
                case 4:
                    message.openPrice = reader.double();
                    break;
                case 5:
                    message.lowPrice = reader.double();
                    break;
                case 6:
                    message.closePrice = reader.double();
                    break;
                case 7:
                    message.lastClosePrice = reader.double();
                    break;
                case 8:
                    message.volume = reader.int64();
                    break;
                case 9:
                    message.turnover = reader.double();
                    break;
                case 10:
                    message.turnoverRate = reader.double();
                    break;
                case 11:
                    message.pe = reader.double();
                    break;
                case 12:
                    message.changeRate = reader.double();
                    break;
                case 13:
                    message.timestamp = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("time"))
                throw $util.ProtocolError("missing required 'time'", { instance: message });
            if (!message.hasOwnProperty("isBlank"))
                throw $util.ProtocolError("missing required 'isBlank'", { instance: message });
            return message;
        };

        /**
         * Decodes a KLine message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_Common.KLine
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_Common.KLine} KLine
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KLine.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a KLine message.
         * @function verify
         * @memberof Qot_Common.KLine
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        KLine.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.time))
                return "time: string expected";
            if (typeof message.isBlank !== "boolean")
                return "isBlank: boolean expected";
            if (message.highPrice != null && message.hasOwnProperty("highPrice"))
                if (typeof message.highPrice !== "number")
                    return "highPrice: number expected";
            if (message.openPrice != null && message.hasOwnProperty("openPrice"))
                if (typeof message.openPrice !== "number")
                    return "openPrice: number expected";
            if (message.lowPrice != null && message.hasOwnProperty("lowPrice"))
                if (typeof message.lowPrice !== "number")
                    return "lowPrice: number expected";
            if (message.closePrice != null && message.hasOwnProperty("closePrice"))
                if (typeof message.closePrice !== "number")
                    return "closePrice: number expected";
            if (message.lastClosePrice != null && message.hasOwnProperty("lastClosePrice"))
                if (typeof message.lastClosePrice !== "number")
                    return "lastClosePrice: number expected";
            if (message.volume != null && message.hasOwnProperty("volume"))
                if (!$util.isInteger(message.volume) && !(message.volume && $util.isInteger(message.volume.low) && $util.isInteger(message.volume.high)))
                    return "volume: integer|Long expected";
            if (message.turnover != null && message.hasOwnProperty("turnover"))
                if (typeof message.turnover !== "number")
                    return "turnover: number expected";
            if (message.turnoverRate != null && message.hasOwnProperty("turnoverRate"))
                if (typeof message.turnoverRate !== "number")
                    return "turnoverRate: number expected";
            if (message.pe != null && message.hasOwnProperty("pe"))
                if (typeof message.pe !== "number")
                    return "pe: number expected";
            if (message.changeRate != null && message.hasOwnProperty("changeRate"))
                if (typeof message.changeRate !== "number")
                    return "changeRate: number expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp !== "number")
                    return "timestamp: number expected";
            return null;
        };

        /**
         * Creates a KLine message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_Common.KLine
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_Common.KLine} KLine
         */
        KLine.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_Common.KLine)
                return object;
            var message = new $root.Qot_Common.KLine();
            if (object.time != null)
                message.time = String(object.time);
            if (object.isBlank != null)
                message.isBlank = Boolean(object.isBlank);
            if (object.highPrice != null)
                message.highPrice = Number(object.highPrice);
            if (object.openPrice != null)
                message.openPrice = Number(object.openPrice);
            if (object.lowPrice != null)
                message.lowPrice = Number(object.lowPrice);
            if (object.closePrice != null)
                message.closePrice = Number(object.closePrice);
            if (object.lastClosePrice != null)
                message.lastClosePrice = Number(object.lastClosePrice);
            if (object.volume != null)
                if ($util.Long)
                    (message.volume = $util.Long.fromValue(object.volume)).unsigned = false;
                else if (typeof object.volume === "string")
                    message.volume = parseInt(object.volume, 10);
                else if (typeof object.volume === "number")
                    message.volume = object.volume;
                else if (typeof object.volume === "object")
                    message.volume = new $util.LongBits(object.volume.low >>> 0, object.volume.high >>> 0).toNumber();
            if (object.turnover != null)
                message.turnover = Number(object.turnover);
            if (object.turnoverRate != null)
                message.turnoverRate = Number(object.turnoverRate);
            if (object.pe != null)
                message.pe = Number(object.pe);
            if (object.changeRate != null)
                message.changeRate = Number(object.changeRate);
            if (object.timestamp != null)
                message.timestamp = Number(object.timestamp);
            return message;
        };

        /**
         * Creates a plain object from a KLine message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_Common.KLine
         * @static
         * @param {Qot_Common.KLine} message KLine
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        KLine.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.time = "";
                object.isBlank = false;
                object.highPrice = 0;
                object.openPrice = 0;
                object.lowPrice = 0;
                object.closePrice = 0;
                object.lastClosePrice = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.volume = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.volume = options.longs === String ? "0" : 0;
                object.turnover = 0;
                object.turnoverRate = 0;
                object.pe = 0;
                object.changeRate = 0;
                object.timestamp = 0;
            }
            if (message.time != null && message.hasOwnProperty("time"))
                object.time = message.time;
            if (message.isBlank != null && message.hasOwnProperty("isBlank"))
                object.isBlank = message.isBlank;
            if (message.highPrice != null && message.hasOwnProperty("highPrice"))
                object.highPrice = options.json && !isFinite(message.highPrice) ? String(message.highPrice) : message.highPrice;
            if (message.openPrice != null && message.hasOwnProperty("openPrice"))
                object.openPrice = options.json && !isFinite(message.openPrice) ? String(message.openPrice) : message.openPrice;
            if (message.lowPrice != null && message.hasOwnProperty("lowPrice"))
                object.lowPrice = options.json && !isFinite(message.lowPrice) ? String(message.lowPrice) : message.lowPrice;
            if (message.closePrice != null && message.hasOwnProperty("closePrice"))
                object.closePrice = options.json && !isFinite(message.closePrice) ? String(message.closePrice) : message.closePrice;
            if (message.lastClosePrice != null && message.hasOwnProperty("lastClosePrice"))
                object.lastClosePrice = options.json && !isFinite(message.lastClosePrice) ? String(message.lastClosePrice) : message.lastClosePrice;
            if (message.volume != null && message.hasOwnProperty("volume"))
                if (typeof message.volume === "number")
                    object.volume = options.longs === String ? String(message.volume) : message.volume;
                else
                    object.volume = options.longs === String ? $util.Long.prototype.toString.call(message.volume) : options.longs === Number ? new $util.LongBits(message.volume.low >>> 0, message.volume.high >>> 0).toNumber() : message.volume;
            if (message.turnover != null && message.hasOwnProperty("turnover"))
                object.turnover = options.json && !isFinite(message.turnover) ? String(message.turnover) : message.turnover;
            if (message.turnoverRate != null && message.hasOwnProperty("turnoverRate"))
                object.turnoverRate = options.json && !isFinite(message.turnoverRate) ? String(message.turnoverRate) : message.turnoverRate;
            if (message.pe != null && message.hasOwnProperty("pe"))
                object.pe = options.json && !isFinite(message.pe) ? String(message.pe) : message.pe;
            if (message.changeRate != null && message.hasOwnProperty("changeRate"))
                object.changeRate = options.json && !isFinite(message.changeRate) ? String(message.changeRate) : message.changeRate;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                object.timestamp = options.json && !isFinite(message.timestamp) ? String(message.timestamp) : message.timestamp;
            return object;
        };

        /**
         * Converts this KLine to JSON.
         * @function toJSON
         * @memberof Qot_Common.KLine
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        KLine.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return KLine;
    })();

    Qot_Common.OptionBasicQotExData = (function() {

        /**
         * Properties of an OptionBasicQotExData.
         * @memberof Qot_Common
         * @interface IOptionBasicQotExData
         * @property {number} strikePrice OptionBasicQotExData strikePrice
         * @property {number} contractSize OptionBasicQotExData contractSize
         * @property {number} openInterest OptionBasicQotExData openInterest
         * @property {number} impliedVolatility OptionBasicQotExData impliedVolatility
         * @property {number} premium OptionBasicQotExData premium
         * @property {number} delta OptionBasicQotExData delta
         * @property {number} gamma OptionBasicQotExData gamma
         * @property {number} vega OptionBasicQotExData vega
         * @property {number} theta OptionBasicQotExData theta
         * @property {number} rho OptionBasicQotExData rho
         */

        /**
         * Constructs a new OptionBasicQotExData.
         * @memberof Qot_Common
         * @classdesc Represents an OptionBasicQotExData.
         * @implements IOptionBasicQotExData
         * @constructor
         * @param {Qot_Common.IOptionBasicQotExData=} [properties] Properties to set
         */
        function OptionBasicQotExData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OptionBasicQotExData strikePrice.
         * @member {number} strikePrice
         * @memberof Qot_Common.OptionBasicQotExData
         * @instance
         */
        OptionBasicQotExData.prototype.strikePrice = 0;

        /**
         * OptionBasicQotExData contractSize.
         * @member {number} contractSize
         * @memberof Qot_Common.OptionBasicQotExData
         * @instance
         */
        OptionBasicQotExData.prototype.contractSize = 0;

        /**
         * OptionBasicQotExData openInterest.
         * @member {number} openInterest
         * @memberof Qot_Common.OptionBasicQotExData
         * @instance
         */
        OptionBasicQotExData.prototype.openInterest = 0;

        /**
         * OptionBasicQotExData impliedVolatility.
         * @member {number} impliedVolatility
         * @memberof Qot_Common.OptionBasicQotExData
         * @instance
         */
        OptionBasicQotExData.prototype.impliedVolatility = 0;

        /**
         * OptionBasicQotExData premium.
         * @member {number} premium
         * @memberof Qot_Common.OptionBasicQotExData
         * @instance
         */
        OptionBasicQotExData.prototype.premium = 0;

        /**
         * OptionBasicQotExData delta.
         * @member {number} delta
         * @memberof Qot_Common.OptionBasicQotExData
         * @instance
         */
        OptionBasicQotExData.prototype.delta = 0;

        /**
         * OptionBasicQotExData gamma.
         * @member {number} gamma
         * @memberof Qot_Common.OptionBasicQotExData
         * @instance
         */
        OptionBasicQotExData.prototype.gamma = 0;

        /**
         * OptionBasicQotExData vega.
         * @member {number} vega
         * @memberof Qot_Common.OptionBasicQotExData
         * @instance
         */
        OptionBasicQotExData.prototype.vega = 0;

        /**
         * OptionBasicQotExData theta.
         * @member {number} theta
         * @memberof Qot_Common.OptionBasicQotExData
         * @instance
         */
        OptionBasicQotExData.prototype.theta = 0;

        /**
         * OptionBasicQotExData rho.
         * @member {number} rho
         * @memberof Qot_Common.OptionBasicQotExData
         * @instance
         */
        OptionBasicQotExData.prototype.rho = 0;

        /**
         * Creates a new OptionBasicQotExData instance using the specified properties.
         * @function create
         * @memberof Qot_Common.OptionBasicQotExData
         * @static
         * @param {Qot_Common.IOptionBasicQotExData=} [properties] Properties to set
         * @returns {Qot_Common.OptionBasicQotExData} OptionBasicQotExData instance
         */
        OptionBasicQotExData.create = function create(properties) {
            return new OptionBasicQotExData(properties);
        };

        /**
         * Encodes the specified OptionBasicQotExData message. Does not implicitly {@link Qot_Common.OptionBasicQotExData.verify|verify} messages.
         * @function encode
         * @memberof Qot_Common.OptionBasicQotExData
         * @static
         * @param {Qot_Common.IOptionBasicQotExData} message OptionBasicQotExData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OptionBasicQotExData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 1 =*/9).double(message.strikePrice);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.contractSize);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.openInterest);
            writer.uint32(/* id 4, wireType 1 =*/33).double(message.impliedVolatility);
            writer.uint32(/* id 5, wireType 1 =*/41).double(message.premium);
            writer.uint32(/* id 6, wireType 1 =*/49).double(message.delta);
            writer.uint32(/* id 7, wireType 1 =*/57).double(message.gamma);
            writer.uint32(/* id 8, wireType 1 =*/65).double(message.vega);
            writer.uint32(/* id 9, wireType 1 =*/73).double(message.theta);
            writer.uint32(/* id 10, wireType 1 =*/81).double(message.rho);
            return writer;
        };

        /**
         * Encodes the specified OptionBasicQotExData message, length delimited. Does not implicitly {@link Qot_Common.OptionBasicQotExData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_Common.OptionBasicQotExData
         * @static
         * @param {Qot_Common.IOptionBasicQotExData} message OptionBasicQotExData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OptionBasicQotExData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OptionBasicQotExData message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_Common.OptionBasicQotExData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_Common.OptionBasicQotExData} OptionBasicQotExData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OptionBasicQotExData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_Common.OptionBasicQotExData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.strikePrice = reader.double();
                    break;
                case 2:
                    message.contractSize = reader.int32();
                    break;
                case 3:
                    message.openInterest = reader.int32();
                    break;
                case 4:
                    message.impliedVolatility = reader.double();
                    break;
                case 5:
                    message.premium = reader.double();
                    break;
                case 6:
                    message.delta = reader.double();
                    break;
                case 7:
                    message.gamma = reader.double();
                    break;
                case 8:
                    message.vega = reader.double();
                    break;
                case 9:
                    message.theta = reader.double();
                    break;
                case 10:
                    message.rho = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("strikePrice"))
                throw $util.ProtocolError("missing required 'strikePrice'", { instance: message });
            if (!message.hasOwnProperty("contractSize"))
                throw $util.ProtocolError("missing required 'contractSize'", { instance: message });
            if (!message.hasOwnProperty("openInterest"))
                throw $util.ProtocolError("missing required 'openInterest'", { instance: message });
            if (!message.hasOwnProperty("impliedVolatility"))
                throw $util.ProtocolError("missing required 'impliedVolatility'", { instance: message });
            if (!message.hasOwnProperty("premium"))
                throw $util.ProtocolError("missing required 'premium'", { instance: message });
            if (!message.hasOwnProperty("delta"))
                throw $util.ProtocolError("missing required 'delta'", { instance: message });
            if (!message.hasOwnProperty("gamma"))
                throw $util.ProtocolError("missing required 'gamma'", { instance: message });
            if (!message.hasOwnProperty("vega"))
                throw $util.ProtocolError("missing required 'vega'", { instance: message });
            if (!message.hasOwnProperty("theta"))
                throw $util.ProtocolError("missing required 'theta'", { instance: message });
            if (!message.hasOwnProperty("rho"))
                throw $util.ProtocolError("missing required 'rho'", { instance: message });
            return message;
        };

        /**
         * Decodes an OptionBasicQotExData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_Common.OptionBasicQotExData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_Common.OptionBasicQotExData} OptionBasicQotExData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OptionBasicQotExData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OptionBasicQotExData message.
         * @function verify
         * @memberof Qot_Common.OptionBasicQotExData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OptionBasicQotExData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (typeof message.strikePrice !== "number")
                return "strikePrice: number expected";
            if (!$util.isInteger(message.contractSize))
                return "contractSize: integer expected";
            if (!$util.isInteger(message.openInterest))
                return "openInterest: integer expected";
            if (typeof message.impliedVolatility !== "number")
                return "impliedVolatility: number expected";
            if (typeof message.premium !== "number")
                return "premium: number expected";
            if (typeof message.delta !== "number")
                return "delta: number expected";
            if (typeof message.gamma !== "number")
                return "gamma: number expected";
            if (typeof message.vega !== "number")
                return "vega: number expected";
            if (typeof message.theta !== "number")
                return "theta: number expected";
            if (typeof message.rho !== "number")
                return "rho: number expected";
            return null;
        };

        /**
         * Creates an OptionBasicQotExData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_Common.OptionBasicQotExData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_Common.OptionBasicQotExData} OptionBasicQotExData
         */
        OptionBasicQotExData.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_Common.OptionBasicQotExData)
                return object;
            var message = new $root.Qot_Common.OptionBasicQotExData();
            if (object.strikePrice != null)
                message.strikePrice = Number(object.strikePrice);
            if (object.contractSize != null)
                message.contractSize = object.contractSize | 0;
            if (object.openInterest != null)
                message.openInterest = object.openInterest | 0;
            if (object.impliedVolatility != null)
                message.impliedVolatility = Number(object.impliedVolatility);
            if (object.premium != null)
                message.premium = Number(object.premium);
            if (object.delta != null)
                message.delta = Number(object.delta);
            if (object.gamma != null)
                message.gamma = Number(object.gamma);
            if (object.vega != null)
                message.vega = Number(object.vega);
            if (object.theta != null)
                message.theta = Number(object.theta);
            if (object.rho != null)
                message.rho = Number(object.rho);
            return message;
        };

        /**
         * Creates a plain object from an OptionBasicQotExData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_Common.OptionBasicQotExData
         * @static
         * @param {Qot_Common.OptionBasicQotExData} message OptionBasicQotExData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OptionBasicQotExData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.strikePrice = 0;
                object.contractSize = 0;
                object.openInterest = 0;
                object.impliedVolatility = 0;
                object.premium = 0;
                object.delta = 0;
                object.gamma = 0;
                object.vega = 0;
                object.theta = 0;
                object.rho = 0;
            }
            if (message.strikePrice != null && message.hasOwnProperty("strikePrice"))
                object.strikePrice = options.json && !isFinite(message.strikePrice) ? String(message.strikePrice) : message.strikePrice;
            if (message.contractSize != null && message.hasOwnProperty("contractSize"))
                object.contractSize = message.contractSize;
            if (message.openInterest != null && message.hasOwnProperty("openInterest"))
                object.openInterest = message.openInterest;
            if (message.impliedVolatility != null && message.hasOwnProperty("impliedVolatility"))
                object.impliedVolatility = options.json && !isFinite(message.impliedVolatility) ? String(message.impliedVolatility) : message.impliedVolatility;
            if (message.premium != null && message.hasOwnProperty("premium"))
                object.premium = options.json && !isFinite(message.premium) ? String(message.premium) : message.premium;
            if (message.delta != null && message.hasOwnProperty("delta"))
                object.delta = options.json && !isFinite(message.delta) ? String(message.delta) : message.delta;
            if (message.gamma != null && message.hasOwnProperty("gamma"))
                object.gamma = options.json && !isFinite(message.gamma) ? String(message.gamma) : message.gamma;
            if (message.vega != null && message.hasOwnProperty("vega"))
                object.vega = options.json && !isFinite(message.vega) ? String(message.vega) : message.vega;
            if (message.theta != null && message.hasOwnProperty("theta"))
                object.theta = options.json && !isFinite(message.theta) ? String(message.theta) : message.theta;
            if (message.rho != null && message.hasOwnProperty("rho"))
                object.rho = options.json && !isFinite(message.rho) ? String(message.rho) : message.rho;
            return object;
        };

        /**
         * Converts this OptionBasicQotExData to JSON.
         * @function toJSON
         * @memberof Qot_Common.OptionBasicQotExData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OptionBasicQotExData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return OptionBasicQotExData;
    })();

    Qot_Common.BasicQot = (function() {

        /**
         * Properties of a BasicQot.
         * @memberof Qot_Common
         * @interface IBasicQot
         * @property {Qot_Common.ISecurity} security BasicQot security
         * @property {boolean} isSuspended BasicQot isSuspended
         * @property {string} listTime BasicQot listTime
         * @property {number} priceSpread BasicQot priceSpread
         * @property {string} updateTime BasicQot updateTime
         * @property {number} highPrice BasicQot highPrice
         * @property {number} openPrice BasicQot openPrice
         * @property {number} lowPrice BasicQot lowPrice
         * @property {number} curPrice BasicQot curPrice
         * @property {number} lastClosePrice BasicQot lastClosePrice
         * @property {number|Long} volume BasicQot volume
         * @property {number} turnover BasicQot turnover
         * @property {number} turnoverRate BasicQot turnoverRate
         * @property {number} amplitude BasicQot amplitude
         * @property {number|null} [darkStatus] BasicQot darkStatus
         * @property {number|null} [listTimestamp] BasicQot listTimestamp
         * @property {number|null} [updateTimestamp] BasicQot updateTimestamp
         * @property {Qot_Common.IOptionBasicQotExData|null} [optionExData] BasicQot optionExData
         */

        /**
         * Constructs a new BasicQot.
         * @memberof Qot_Common
         * @classdesc Represents a BasicQot.
         * @implements IBasicQot
         * @constructor
         * @param {Qot_Common.IBasicQot=} [properties] Properties to set
         */
        function BasicQot(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BasicQot security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_Common.BasicQot
         * @instance
         */
        BasicQot.prototype.security = null;

        /**
         * BasicQot isSuspended.
         * @member {boolean} isSuspended
         * @memberof Qot_Common.BasicQot
         * @instance
         */
        BasicQot.prototype.isSuspended = false;

        /**
         * BasicQot listTime.
         * @member {string} listTime
         * @memberof Qot_Common.BasicQot
         * @instance
         */
        BasicQot.prototype.listTime = "";

        /**
         * BasicQot priceSpread.
         * @member {number} priceSpread
         * @memberof Qot_Common.BasicQot
         * @instance
         */
        BasicQot.prototype.priceSpread = 0;

        /**
         * BasicQot updateTime.
         * @member {string} updateTime
         * @memberof Qot_Common.BasicQot
         * @instance
         */
        BasicQot.prototype.updateTime = "";

        /**
         * BasicQot highPrice.
         * @member {number} highPrice
         * @memberof Qot_Common.BasicQot
         * @instance
         */
        BasicQot.prototype.highPrice = 0;

        /**
         * BasicQot openPrice.
         * @member {number} openPrice
         * @memberof Qot_Common.BasicQot
         * @instance
         */
        BasicQot.prototype.openPrice = 0;

        /**
         * BasicQot lowPrice.
         * @member {number} lowPrice
         * @memberof Qot_Common.BasicQot
         * @instance
         */
        BasicQot.prototype.lowPrice = 0;

        /**
         * BasicQot curPrice.
         * @member {number} curPrice
         * @memberof Qot_Common.BasicQot
         * @instance
         */
        BasicQot.prototype.curPrice = 0;

        /**
         * BasicQot lastClosePrice.
         * @member {number} lastClosePrice
         * @memberof Qot_Common.BasicQot
         * @instance
         */
        BasicQot.prototype.lastClosePrice = 0;

        /**
         * BasicQot volume.
         * @member {number|Long} volume
         * @memberof Qot_Common.BasicQot
         * @instance
         */
        BasicQot.prototype.volume = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * BasicQot turnover.
         * @member {number} turnover
         * @memberof Qot_Common.BasicQot
         * @instance
         */
        BasicQot.prototype.turnover = 0;

        /**
         * BasicQot turnoverRate.
         * @member {number} turnoverRate
         * @memberof Qot_Common.BasicQot
         * @instance
         */
        BasicQot.prototype.turnoverRate = 0;

        /**
         * BasicQot amplitude.
         * @member {number} amplitude
         * @memberof Qot_Common.BasicQot
         * @instance
         */
        BasicQot.prototype.amplitude = 0;

        /**
         * BasicQot darkStatus.
         * @member {number} darkStatus
         * @memberof Qot_Common.BasicQot
         * @instance
         */
        BasicQot.prototype.darkStatus = 0;

        /**
         * BasicQot listTimestamp.
         * @member {number} listTimestamp
         * @memberof Qot_Common.BasicQot
         * @instance
         */
        BasicQot.prototype.listTimestamp = 0;

        /**
         * BasicQot updateTimestamp.
         * @member {number} updateTimestamp
         * @memberof Qot_Common.BasicQot
         * @instance
         */
        BasicQot.prototype.updateTimestamp = 0;

        /**
         * BasicQot optionExData.
         * @member {Qot_Common.IOptionBasicQotExData|null|undefined} optionExData
         * @memberof Qot_Common.BasicQot
         * @instance
         */
        BasicQot.prototype.optionExData = null;

        /**
         * Creates a new BasicQot instance using the specified properties.
         * @function create
         * @memberof Qot_Common.BasicQot
         * @static
         * @param {Qot_Common.IBasicQot=} [properties] Properties to set
         * @returns {Qot_Common.BasicQot} BasicQot instance
         */
        BasicQot.create = function create(properties) {
            return new BasicQot(properties);
        };

        /**
         * Encodes the specified BasicQot message. Does not implicitly {@link Qot_Common.BasicQot.verify|verify} messages.
         * @function encode
         * @memberof Qot_Common.BasicQot
         * @static
         * @param {Qot_Common.IBasicQot} message BasicQot message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BasicQot.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isSuspended);
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.listTime);
            writer.uint32(/* id 4, wireType 1 =*/33).double(message.priceSpread);
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.updateTime);
            writer.uint32(/* id 6, wireType 1 =*/49).double(message.highPrice);
            writer.uint32(/* id 7, wireType 1 =*/57).double(message.openPrice);
            writer.uint32(/* id 8, wireType 1 =*/65).double(message.lowPrice);
            writer.uint32(/* id 9, wireType 1 =*/73).double(message.curPrice);
            writer.uint32(/* id 10, wireType 1 =*/81).double(message.lastClosePrice);
            writer.uint32(/* id 11, wireType 0 =*/88).int64(message.volume);
            writer.uint32(/* id 12, wireType 1 =*/97).double(message.turnover);
            writer.uint32(/* id 13, wireType 1 =*/105).double(message.turnoverRate);
            writer.uint32(/* id 14, wireType 1 =*/113).double(message.amplitude);
            if (message.darkStatus != null && message.hasOwnProperty("darkStatus"))
                writer.uint32(/* id 15, wireType 0 =*/120).int32(message.darkStatus);
            if (message.optionExData != null && message.hasOwnProperty("optionExData"))
                $root.Qot_Common.OptionBasicQotExData.encode(message.optionExData, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
            if (message.listTimestamp != null && message.hasOwnProperty("listTimestamp"))
                writer.uint32(/* id 17, wireType 1 =*/137).double(message.listTimestamp);
            if (message.updateTimestamp != null && message.hasOwnProperty("updateTimestamp"))
                writer.uint32(/* id 18, wireType 1 =*/145).double(message.updateTimestamp);
            return writer;
        };

        /**
         * Encodes the specified BasicQot message, length delimited. Does not implicitly {@link Qot_Common.BasicQot.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_Common.BasicQot
         * @static
         * @param {Qot_Common.IBasicQot} message BasicQot message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BasicQot.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BasicQot message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_Common.BasicQot
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_Common.BasicQot} BasicQot
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BasicQot.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_Common.BasicQot();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.isSuspended = reader.bool();
                    break;
                case 3:
                    message.listTime = reader.string();
                    break;
                case 4:
                    message.priceSpread = reader.double();
                    break;
                case 5:
                    message.updateTime = reader.string();
                    break;
                case 6:
                    message.highPrice = reader.double();
                    break;
                case 7:
                    message.openPrice = reader.double();
                    break;
                case 8:
                    message.lowPrice = reader.double();
                    break;
                case 9:
                    message.curPrice = reader.double();
                    break;
                case 10:
                    message.lastClosePrice = reader.double();
                    break;
                case 11:
                    message.volume = reader.int64();
                    break;
                case 12:
                    message.turnover = reader.double();
                    break;
                case 13:
                    message.turnoverRate = reader.double();
                    break;
                case 14:
                    message.amplitude = reader.double();
                    break;
                case 15:
                    message.darkStatus = reader.int32();
                    break;
                case 17:
                    message.listTimestamp = reader.double();
                    break;
                case 18:
                    message.updateTimestamp = reader.double();
                    break;
                case 16:
                    message.optionExData = $root.Qot_Common.OptionBasicQotExData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            if (!message.hasOwnProperty("isSuspended"))
                throw $util.ProtocolError("missing required 'isSuspended'", { instance: message });
            if (!message.hasOwnProperty("listTime"))
                throw $util.ProtocolError("missing required 'listTime'", { instance: message });
            if (!message.hasOwnProperty("priceSpread"))
                throw $util.ProtocolError("missing required 'priceSpread'", { instance: message });
            if (!message.hasOwnProperty("updateTime"))
                throw $util.ProtocolError("missing required 'updateTime'", { instance: message });
            if (!message.hasOwnProperty("highPrice"))
                throw $util.ProtocolError("missing required 'highPrice'", { instance: message });
            if (!message.hasOwnProperty("openPrice"))
                throw $util.ProtocolError("missing required 'openPrice'", { instance: message });
            if (!message.hasOwnProperty("lowPrice"))
                throw $util.ProtocolError("missing required 'lowPrice'", { instance: message });
            if (!message.hasOwnProperty("curPrice"))
                throw $util.ProtocolError("missing required 'curPrice'", { instance: message });
            if (!message.hasOwnProperty("lastClosePrice"))
                throw $util.ProtocolError("missing required 'lastClosePrice'", { instance: message });
            if (!message.hasOwnProperty("volume"))
                throw $util.ProtocolError("missing required 'volume'", { instance: message });
            if (!message.hasOwnProperty("turnover"))
                throw $util.ProtocolError("missing required 'turnover'", { instance: message });
            if (!message.hasOwnProperty("turnoverRate"))
                throw $util.ProtocolError("missing required 'turnoverRate'", { instance: message });
            if (!message.hasOwnProperty("amplitude"))
                throw $util.ProtocolError("missing required 'amplitude'", { instance: message });
            return message;
        };

        /**
         * Decodes a BasicQot message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_Common.BasicQot
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_Common.BasicQot} BasicQot
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BasicQot.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BasicQot message.
         * @function verify
         * @memberof Qot_Common.BasicQot
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BasicQot.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            if (typeof message.isSuspended !== "boolean")
                return "isSuspended: boolean expected";
            if (!$util.isString(message.listTime))
                return "listTime: string expected";
            if (typeof message.priceSpread !== "number")
                return "priceSpread: number expected";
            if (!$util.isString(message.updateTime))
                return "updateTime: string expected";
            if (typeof message.highPrice !== "number")
                return "highPrice: number expected";
            if (typeof message.openPrice !== "number")
                return "openPrice: number expected";
            if (typeof message.lowPrice !== "number")
                return "lowPrice: number expected";
            if (typeof message.curPrice !== "number")
                return "curPrice: number expected";
            if (typeof message.lastClosePrice !== "number")
                return "lastClosePrice: number expected";
            if (!$util.isInteger(message.volume) && !(message.volume && $util.isInteger(message.volume.low) && $util.isInteger(message.volume.high)))
                return "volume: integer|Long expected";
            if (typeof message.turnover !== "number")
                return "turnover: number expected";
            if (typeof message.turnoverRate !== "number")
                return "turnoverRate: number expected";
            if (typeof message.amplitude !== "number")
                return "amplitude: number expected";
            if (message.darkStatus != null && message.hasOwnProperty("darkStatus"))
                if (!$util.isInteger(message.darkStatus))
                    return "darkStatus: integer expected";
            if (message.listTimestamp != null && message.hasOwnProperty("listTimestamp"))
                if (typeof message.listTimestamp !== "number")
                    return "listTimestamp: number expected";
            if (message.updateTimestamp != null && message.hasOwnProperty("updateTimestamp"))
                if (typeof message.updateTimestamp !== "number")
                    return "updateTimestamp: number expected";
            if (message.optionExData != null && message.hasOwnProperty("optionExData")) {
                var error = $root.Qot_Common.OptionBasicQotExData.verify(message.optionExData);
                if (error)
                    return "optionExData." + error;
            }
            return null;
        };

        /**
         * Creates a BasicQot message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_Common.BasicQot
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_Common.BasicQot} BasicQot
         */
        BasicQot.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_Common.BasicQot)
                return object;
            var message = new $root.Qot_Common.BasicQot();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_Common.BasicQot.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            if (object.isSuspended != null)
                message.isSuspended = Boolean(object.isSuspended);
            if (object.listTime != null)
                message.listTime = String(object.listTime);
            if (object.priceSpread != null)
                message.priceSpread = Number(object.priceSpread);
            if (object.updateTime != null)
                message.updateTime = String(object.updateTime);
            if (object.highPrice != null)
                message.highPrice = Number(object.highPrice);
            if (object.openPrice != null)
                message.openPrice = Number(object.openPrice);
            if (object.lowPrice != null)
                message.lowPrice = Number(object.lowPrice);
            if (object.curPrice != null)
                message.curPrice = Number(object.curPrice);
            if (object.lastClosePrice != null)
                message.lastClosePrice = Number(object.lastClosePrice);
            if (object.volume != null)
                if ($util.Long)
                    (message.volume = $util.Long.fromValue(object.volume)).unsigned = false;
                else if (typeof object.volume === "string")
                    message.volume = parseInt(object.volume, 10);
                else if (typeof object.volume === "number")
                    message.volume = object.volume;
                else if (typeof object.volume === "object")
                    message.volume = new $util.LongBits(object.volume.low >>> 0, object.volume.high >>> 0).toNumber();
            if (object.turnover != null)
                message.turnover = Number(object.turnover);
            if (object.turnoverRate != null)
                message.turnoverRate = Number(object.turnoverRate);
            if (object.amplitude != null)
                message.amplitude = Number(object.amplitude);
            if (object.darkStatus != null)
                message.darkStatus = object.darkStatus | 0;
            if (object.listTimestamp != null)
                message.listTimestamp = Number(object.listTimestamp);
            if (object.updateTimestamp != null)
                message.updateTimestamp = Number(object.updateTimestamp);
            if (object.optionExData != null) {
                if (typeof object.optionExData !== "object")
                    throw TypeError(".Qot_Common.BasicQot.optionExData: object expected");
                message.optionExData = $root.Qot_Common.OptionBasicQotExData.fromObject(object.optionExData);
            }
            return message;
        };

        /**
         * Creates a plain object from a BasicQot message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_Common.BasicQot
         * @static
         * @param {Qot_Common.BasicQot} message BasicQot
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BasicQot.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.security = null;
                object.isSuspended = false;
                object.listTime = "";
                object.priceSpread = 0;
                object.updateTime = "";
                object.highPrice = 0;
                object.openPrice = 0;
                object.lowPrice = 0;
                object.curPrice = 0;
                object.lastClosePrice = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.volume = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.volume = options.longs === String ? "0" : 0;
                object.turnover = 0;
                object.turnoverRate = 0;
                object.amplitude = 0;
                object.darkStatus = 0;
                object.optionExData = null;
                object.listTimestamp = 0;
                object.updateTimestamp = 0;
            }
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            if (message.isSuspended != null && message.hasOwnProperty("isSuspended"))
                object.isSuspended = message.isSuspended;
            if (message.listTime != null && message.hasOwnProperty("listTime"))
                object.listTime = message.listTime;
            if (message.priceSpread != null && message.hasOwnProperty("priceSpread"))
                object.priceSpread = options.json && !isFinite(message.priceSpread) ? String(message.priceSpread) : message.priceSpread;
            if (message.updateTime != null && message.hasOwnProperty("updateTime"))
                object.updateTime = message.updateTime;
            if (message.highPrice != null && message.hasOwnProperty("highPrice"))
                object.highPrice = options.json && !isFinite(message.highPrice) ? String(message.highPrice) : message.highPrice;
            if (message.openPrice != null && message.hasOwnProperty("openPrice"))
                object.openPrice = options.json && !isFinite(message.openPrice) ? String(message.openPrice) : message.openPrice;
            if (message.lowPrice != null && message.hasOwnProperty("lowPrice"))
                object.lowPrice = options.json && !isFinite(message.lowPrice) ? String(message.lowPrice) : message.lowPrice;
            if (message.curPrice != null && message.hasOwnProperty("curPrice"))
                object.curPrice = options.json && !isFinite(message.curPrice) ? String(message.curPrice) : message.curPrice;
            if (message.lastClosePrice != null && message.hasOwnProperty("lastClosePrice"))
                object.lastClosePrice = options.json && !isFinite(message.lastClosePrice) ? String(message.lastClosePrice) : message.lastClosePrice;
            if (message.volume != null && message.hasOwnProperty("volume"))
                if (typeof message.volume === "number")
                    object.volume = options.longs === String ? String(message.volume) : message.volume;
                else
                    object.volume = options.longs === String ? $util.Long.prototype.toString.call(message.volume) : options.longs === Number ? new $util.LongBits(message.volume.low >>> 0, message.volume.high >>> 0).toNumber() : message.volume;
            if (message.turnover != null && message.hasOwnProperty("turnover"))
                object.turnover = options.json && !isFinite(message.turnover) ? String(message.turnover) : message.turnover;
            if (message.turnoverRate != null && message.hasOwnProperty("turnoverRate"))
                object.turnoverRate = options.json && !isFinite(message.turnoverRate) ? String(message.turnoverRate) : message.turnoverRate;
            if (message.amplitude != null && message.hasOwnProperty("amplitude"))
                object.amplitude = options.json && !isFinite(message.amplitude) ? String(message.amplitude) : message.amplitude;
            if (message.darkStatus != null && message.hasOwnProperty("darkStatus"))
                object.darkStatus = message.darkStatus;
            if (message.optionExData != null && message.hasOwnProperty("optionExData"))
                object.optionExData = $root.Qot_Common.OptionBasicQotExData.toObject(message.optionExData, options);
            if (message.listTimestamp != null && message.hasOwnProperty("listTimestamp"))
                object.listTimestamp = options.json && !isFinite(message.listTimestamp) ? String(message.listTimestamp) : message.listTimestamp;
            if (message.updateTimestamp != null && message.hasOwnProperty("updateTimestamp"))
                object.updateTimestamp = options.json && !isFinite(message.updateTimestamp) ? String(message.updateTimestamp) : message.updateTimestamp;
            return object;
        };

        /**
         * Converts this BasicQot to JSON.
         * @function toJSON
         * @memberof Qot_Common.BasicQot
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BasicQot.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BasicQot;
    })();

    Qot_Common.TimeShare = (function() {

        /**
         * Properties of a TimeShare.
         * @memberof Qot_Common
         * @interface ITimeShare
         * @property {string} time TimeShare time
         * @property {number} minute TimeShare minute
         * @property {boolean} isBlank TimeShare isBlank
         * @property {number|null} [price] TimeShare price
         * @property {number|null} [lastClosePrice] TimeShare lastClosePrice
         * @property {number|null} [avgPrice] TimeShare avgPrice
         * @property {number|Long|null} [volume] TimeShare volume
         * @property {number|null} [turnover] TimeShare turnover
         * @property {number|null} [timestamp] TimeShare timestamp
         */

        /**
         * Constructs a new TimeShare.
         * @memberof Qot_Common
         * @classdesc Represents a TimeShare.
         * @implements ITimeShare
         * @constructor
         * @param {Qot_Common.ITimeShare=} [properties] Properties to set
         */
        function TimeShare(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TimeShare time.
         * @member {string} time
         * @memberof Qot_Common.TimeShare
         * @instance
         */
        TimeShare.prototype.time = "";

        /**
         * TimeShare minute.
         * @member {number} minute
         * @memberof Qot_Common.TimeShare
         * @instance
         */
        TimeShare.prototype.minute = 0;

        /**
         * TimeShare isBlank.
         * @member {boolean} isBlank
         * @memberof Qot_Common.TimeShare
         * @instance
         */
        TimeShare.prototype.isBlank = false;

        /**
         * TimeShare price.
         * @member {number} price
         * @memberof Qot_Common.TimeShare
         * @instance
         */
        TimeShare.prototype.price = 0;

        /**
         * TimeShare lastClosePrice.
         * @member {number} lastClosePrice
         * @memberof Qot_Common.TimeShare
         * @instance
         */
        TimeShare.prototype.lastClosePrice = 0;

        /**
         * TimeShare avgPrice.
         * @member {number} avgPrice
         * @memberof Qot_Common.TimeShare
         * @instance
         */
        TimeShare.prototype.avgPrice = 0;

        /**
         * TimeShare volume.
         * @member {number|Long} volume
         * @memberof Qot_Common.TimeShare
         * @instance
         */
        TimeShare.prototype.volume = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TimeShare turnover.
         * @member {number} turnover
         * @memberof Qot_Common.TimeShare
         * @instance
         */
        TimeShare.prototype.turnover = 0;

        /**
         * TimeShare timestamp.
         * @member {number} timestamp
         * @memberof Qot_Common.TimeShare
         * @instance
         */
        TimeShare.prototype.timestamp = 0;

        /**
         * Creates a new TimeShare instance using the specified properties.
         * @function create
         * @memberof Qot_Common.TimeShare
         * @static
         * @param {Qot_Common.ITimeShare=} [properties] Properties to set
         * @returns {Qot_Common.TimeShare} TimeShare instance
         */
        TimeShare.create = function create(properties) {
            return new TimeShare(properties);
        };

        /**
         * Encodes the specified TimeShare message. Does not implicitly {@link Qot_Common.TimeShare.verify|verify} messages.
         * @function encode
         * @memberof Qot_Common.TimeShare
         * @static
         * @param {Qot_Common.ITimeShare} message TimeShare message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TimeShare.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.time);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.minute);
            writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isBlank);
            if (message.price != null && message.hasOwnProperty("price"))
                writer.uint32(/* id 4, wireType 1 =*/33).double(message.price);
            if (message.lastClosePrice != null && message.hasOwnProperty("lastClosePrice"))
                writer.uint32(/* id 5, wireType 1 =*/41).double(message.lastClosePrice);
            if (message.avgPrice != null && message.hasOwnProperty("avgPrice"))
                writer.uint32(/* id 6, wireType 1 =*/49).double(message.avgPrice);
            if (message.volume != null && message.hasOwnProperty("volume"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.volume);
            if (message.turnover != null && message.hasOwnProperty("turnover"))
                writer.uint32(/* id 8, wireType 1 =*/65).double(message.turnover);
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                writer.uint32(/* id 9, wireType 1 =*/73).double(message.timestamp);
            return writer;
        };

        /**
         * Encodes the specified TimeShare message, length delimited. Does not implicitly {@link Qot_Common.TimeShare.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_Common.TimeShare
         * @static
         * @param {Qot_Common.ITimeShare} message TimeShare message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TimeShare.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TimeShare message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_Common.TimeShare
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_Common.TimeShare} TimeShare
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TimeShare.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_Common.TimeShare();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.time = reader.string();
                    break;
                case 2:
                    message.minute = reader.int32();
                    break;
                case 3:
                    message.isBlank = reader.bool();
                    break;
                case 4:
                    message.price = reader.double();
                    break;
                case 5:
                    message.lastClosePrice = reader.double();
                    break;
                case 6:
                    message.avgPrice = reader.double();
                    break;
                case 7:
                    message.volume = reader.int64();
                    break;
                case 8:
                    message.turnover = reader.double();
                    break;
                case 9:
                    message.timestamp = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("time"))
                throw $util.ProtocolError("missing required 'time'", { instance: message });
            if (!message.hasOwnProperty("minute"))
                throw $util.ProtocolError("missing required 'minute'", { instance: message });
            if (!message.hasOwnProperty("isBlank"))
                throw $util.ProtocolError("missing required 'isBlank'", { instance: message });
            return message;
        };

        /**
         * Decodes a TimeShare message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_Common.TimeShare
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_Common.TimeShare} TimeShare
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TimeShare.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TimeShare message.
         * @function verify
         * @memberof Qot_Common.TimeShare
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TimeShare.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.time))
                return "time: string expected";
            if (!$util.isInteger(message.minute))
                return "minute: integer expected";
            if (typeof message.isBlank !== "boolean")
                return "isBlank: boolean expected";
            if (message.price != null && message.hasOwnProperty("price"))
                if (typeof message.price !== "number")
                    return "price: number expected";
            if (message.lastClosePrice != null && message.hasOwnProperty("lastClosePrice"))
                if (typeof message.lastClosePrice !== "number")
                    return "lastClosePrice: number expected";
            if (message.avgPrice != null && message.hasOwnProperty("avgPrice"))
                if (typeof message.avgPrice !== "number")
                    return "avgPrice: number expected";
            if (message.volume != null && message.hasOwnProperty("volume"))
                if (!$util.isInteger(message.volume) && !(message.volume && $util.isInteger(message.volume.low) && $util.isInteger(message.volume.high)))
                    return "volume: integer|Long expected";
            if (message.turnover != null && message.hasOwnProperty("turnover"))
                if (typeof message.turnover !== "number")
                    return "turnover: number expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp !== "number")
                    return "timestamp: number expected";
            return null;
        };

        /**
         * Creates a TimeShare message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_Common.TimeShare
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_Common.TimeShare} TimeShare
         */
        TimeShare.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_Common.TimeShare)
                return object;
            var message = new $root.Qot_Common.TimeShare();
            if (object.time != null)
                message.time = String(object.time);
            if (object.minute != null)
                message.minute = object.minute | 0;
            if (object.isBlank != null)
                message.isBlank = Boolean(object.isBlank);
            if (object.price != null)
                message.price = Number(object.price);
            if (object.lastClosePrice != null)
                message.lastClosePrice = Number(object.lastClosePrice);
            if (object.avgPrice != null)
                message.avgPrice = Number(object.avgPrice);
            if (object.volume != null)
                if ($util.Long)
                    (message.volume = $util.Long.fromValue(object.volume)).unsigned = false;
                else if (typeof object.volume === "string")
                    message.volume = parseInt(object.volume, 10);
                else if (typeof object.volume === "number")
                    message.volume = object.volume;
                else if (typeof object.volume === "object")
                    message.volume = new $util.LongBits(object.volume.low >>> 0, object.volume.high >>> 0).toNumber();
            if (object.turnover != null)
                message.turnover = Number(object.turnover);
            if (object.timestamp != null)
                message.timestamp = Number(object.timestamp);
            return message;
        };

        /**
         * Creates a plain object from a TimeShare message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_Common.TimeShare
         * @static
         * @param {Qot_Common.TimeShare} message TimeShare
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TimeShare.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.time = "";
                object.minute = 0;
                object.isBlank = false;
                object.price = 0;
                object.lastClosePrice = 0;
                object.avgPrice = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.volume = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.volume = options.longs === String ? "0" : 0;
                object.turnover = 0;
                object.timestamp = 0;
            }
            if (message.time != null && message.hasOwnProperty("time"))
                object.time = message.time;
            if (message.minute != null && message.hasOwnProperty("minute"))
                object.minute = message.minute;
            if (message.isBlank != null && message.hasOwnProperty("isBlank"))
                object.isBlank = message.isBlank;
            if (message.price != null && message.hasOwnProperty("price"))
                object.price = options.json && !isFinite(message.price) ? String(message.price) : message.price;
            if (message.lastClosePrice != null && message.hasOwnProperty("lastClosePrice"))
                object.lastClosePrice = options.json && !isFinite(message.lastClosePrice) ? String(message.lastClosePrice) : message.lastClosePrice;
            if (message.avgPrice != null && message.hasOwnProperty("avgPrice"))
                object.avgPrice = options.json && !isFinite(message.avgPrice) ? String(message.avgPrice) : message.avgPrice;
            if (message.volume != null && message.hasOwnProperty("volume"))
                if (typeof message.volume === "number")
                    object.volume = options.longs === String ? String(message.volume) : message.volume;
                else
                    object.volume = options.longs === String ? $util.Long.prototype.toString.call(message.volume) : options.longs === Number ? new $util.LongBits(message.volume.low >>> 0, message.volume.high >>> 0).toNumber() : message.volume;
            if (message.turnover != null && message.hasOwnProperty("turnover"))
                object.turnover = options.json && !isFinite(message.turnover) ? String(message.turnover) : message.turnover;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                object.timestamp = options.json && !isFinite(message.timestamp) ? String(message.timestamp) : message.timestamp;
            return object;
        };

        /**
         * Converts this TimeShare to JSON.
         * @function toJSON
         * @memberof Qot_Common.TimeShare
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TimeShare.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TimeShare;
    })();

    Qot_Common.SecurityStaticBasic = (function() {

        /**
         * Properties of a SecurityStaticBasic.
         * @memberof Qot_Common
         * @interface ISecurityStaticBasic
         * @property {Qot_Common.ISecurity} security SecurityStaticBasic security
         * @property {number|Long} id SecurityStaticBasic id
         * @property {number} lotSize SecurityStaticBasic lotSize
         * @property {number} secType SecurityStaticBasic secType
         * @property {string} name SecurityStaticBasic name
         * @property {string} listTime SecurityStaticBasic listTime
         * @property {boolean|null} [delisting] SecurityStaticBasic delisting
         * @property {number|null} [listTimestamp] SecurityStaticBasic listTimestamp
         */

        /**
         * Constructs a new SecurityStaticBasic.
         * @memberof Qot_Common
         * @classdesc Represents a SecurityStaticBasic.
         * @implements ISecurityStaticBasic
         * @constructor
         * @param {Qot_Common.ISecurityStaticBasic=} [properties] Properties to set
         */
        function SecurityStaticBasic(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SecurityStaticBasic security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_Common.SecurityStaticBasic
         * @instance
         */
        SecurityStaticBasic.prototype.security = null;

        /**
         * SecurityStaticBasic id.
         * @member {number|Long} id
         * @memberof Qot_Common.SecurityStaticBasic
         * @instance
         */
        SecurityStaticBasic.prototype.id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SecurityStaticBasic lotSize.
         * @member {number} lotSize
         * @memberof Qot_Common.SecurityStaticBasic
         * @instance
         */
        SecurityStaticBasic.prototype.lotSize = 0;

        /**
         * SecurityStaticBasic secType.
         * @member {number} secType
         * @memberof Qot_Common.SecurityStaticBasic
         * @instance
         */
        SecurityStaticBasic.prototype.secType = 0;

        /**
         * SecurityStaticBasic name.
         * @member {string} name
         * @memberof Qot_Common.SecurityStaticBasic
         * @instance
         */
        SecurityStaticBasic.prototype.name = "";

        /**
         * SecurityStaticBasic listTime.
         * @member {string} listTime
         * @memberof Qot_Common.SecurityStaticBasic
         * @instance
         */
        SecurityStaticBasic.prototype.listTime = "";

        /**
         * SecurityStaticBasic delisting.
         * @member {boolean} delisting
         * @memberof Qot_Common.SecurityStaticBasic
         * @instance
         */
        SecurityStaticBasic.prototype.delisting = false;

        /**
         * SecurityStaticBasic listTimestamp.
         * @member {number} listTimestamp
         * @memberof Qot_Common.SecurityStaticBasic
         * @instance
         */
        SecurityStaticBasic.prototype.listTimestamp = 0;

        /**
         * Creates a new SecurityStaticBasic instance using the specified properties.
         * @function create
         * @memberof Qot_Common.SecurityStaticBasic
         * @static
         * @param {Qot_Common.ISecurityStaticBasic=} [properties] Properties to set
         * @returns {Qot_Common.SecurityStaticBasic} SecurityStaticBasic instance
         */
        SecurityStaticBasic.create = function create(properties) {
            return new SecurityStaticBasic(properties);
        };

        /**
         * Encodes the specified SecurityStaticBasic message. Does not implicitly {@link Qot_Common.SecurityStaticBasic.verify|verify} messages.
         * @function encode
         * @memberof Qot_Common.SecurityStaticBasic
         * @static
         * @param {Qot_Common.ISecurityStaticBasic} message SecurityStaticBasic message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SecurityStaticBasic.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.id);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.lotSize);
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.secType);
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.name);
            writer.uint32(/* id 6, wireType 2 =*/50).string(message.listTime);
            if (message.delisting != null && message.hasOwnProperty("delisting"))
                writer.uint32(/* id 7, wireType 0 =*/56).bool(message.delisting);
            if (message.listTimestamp != null && message.hasOwnProperty("listTimestamp"))
                writer.uint32(/* id 8, wireType 1 =*/65).double(message.listTimestamp);
            return writer;
        };

        /**
         * Encodes the specified SecurityStaticBasic message, length delimited. Does not implicitly {@link Qot_Common.SecurityStaticBasic.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_Common.SecurityStaticBasic
         * @static
         * @param {Qot_Common.ISecurityStaticBasic} message SecurityStaticBasic message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SecurityStaticBasic.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SecurityStaticBasic message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_Common.SecurityStaticBasic
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_Common.SecurityStaticBasic} SecurityStaticBasic
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SecurityStaticBasic.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_Common.SecurityStaticBasic();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.id = reader.int64();
                    break;
                case 3:
                    message.lotSize = reader.int32();
                    break;
                case 4:
                    message.secType = reader.int32();
                    break;
                case 5:
                    message.name = reader.string();
                    break;
                case 6:
                    message.listTime = reader.string();
                    break;
                case 7:
                    message.delisting = reader.bool();
                    break;
                case 8:
                    message.listTimestamp = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            if (!message.hasOwnProperty("lotSize"))
                throw $util.ProtocolError("missing required 'lotSize'", { instance: message });
            if (!message.hasOwnProperty("secType"))
                throw $util.ProtocolError("missing required 'secType'", { instance: message });
            if (!message.hasOwnProperty("name"))
                throw $util.ProtocolError("missing required 'name'", { instance: message });
            if (!message.hasOwnProperty("listTime"))
                throw $util.ProtocolError("missing required 'listTime'", { instance: message });
            return message;
        };

        /**
         * Decodes a SecurityStaticBasic message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_Common.SecurityStaticBasic
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_Common.SecurityStaticBasic} SecurityStaticBasic
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SecurityStaticBasic.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SecurityStaticBasic message.
         * @function verify
         * @memberof Qot_Common.SecurityStaticBasic
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SecurityStaticBasic.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                return "id: integer|Long expected";
            if (!$util.isInteger(message.lotSize))
                return "lotSize: integer expected";
            if (!$util.isInteger(message.secType))
                return "secType: integer expected";
            if (!$util.isString(message.name))
                return "name: string expected";
            if (!$util.isString(message.listTime))
                return "listTime: string expected";
            if (message.delisting != null && message.hasOwnProperty("delisting"))
                if (typeof message.delisting !== "boolean")
                    return "delisting: boolean expected";
            if (message.listTimestamp != null && message.hasOwnProperty("listTimestamp"))
                if (typeof message.listTimestamp !== "number")
                    return "listTimestamp: number expected";
            return null;
        };

        /**
         * Creates a SecurityStaticBasic message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_Common.SecurityStaticBasic
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_Common.SecurityStaticBasic} SecurityStaticBasic
         */
        SecurityStaticBasic.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_Common.SecurityStaticBasic)
                return object;
            var message = new $root.Qot_Common.SecurityStaticBasic();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_Common.SecurityStaticBasic.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            if (object.id != null)
                if ($util.Long)
                    (message.id = $util.Long.fromValue(object.id)).unsigned = false;
                else if (typeof object.id === "string")
                    message.id = parseInt(object.id, 10);
                else if (typeof object.id === "number")
                    message.id = object.id;
                else if (typeof object.id === "object")
                    message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber();
            if (object.lotSize != null)
                message.lotSize = object.lotSize | 0;
            if (object.secType != null)
                message.secType = object.secType | 0;
            if (object.name != null)
                message.name = String(object.name);
            if (object.listTime != null)
                message.listTime = String(object.listTime);
            if (object.delisting != null)
                message.delisting = Boolean(object.delisting);
            if (object.listTimestamp != null)
                message.listTimestamp = Number(object.listTimestamp);
            return message;
        };

        /**
         * Creates a plain object from a SecurityStaticBasic message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_Common.SecurityStaticBasic
         * @static
         * @param {Qot_Common.SecurityStaticBasic} message SecurityStaticBasic
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SecurityStaticBasic.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.security = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.id = options.longs === String ? "0" : 0;
                object.lotSize = 0;
                object.secType = 0;
                object.name = "";
                object.listTime = "";
                object.delisting = false;
                object.listTimestamp = 0;
            }
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            if (message.id != null && message.hasOwnProperty("id"))
                if (typeof message.id === "number")
                    object.id = options.longs === String ? String(message.id) : message.id;
                else
                    object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber() : message.id;
            if (message.lotSize != null && message.hasOwnProperty("lotSize"))
                object.lotSize = message.lotSize;
            if (message.secType != null && message.hasOwnProperty("secType"))
                object.secType = message.secType;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.listTime != null && message.hasOwnProperty("listTime"))
                object.listTime = message.listTime;
            if (message.delisting != null && message.hasOwnProperty("delisting"))
                object.delisting = message.delisting;
            if (message.listTimestamp != null && message.hasOwnProperty("listTimestamp"))
                object.listTimestamp = options.json && !isFinite(message.listTimestamp) ? String(message.listTimestamp) : message.listTimestamp;
            return object;
        };

        /**
         * Converts this SecurityStaticBasic to JSON.
         * @function toJSON
         * @memberof Qot_Common.SecurityStaticBasic
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SecurityStaticBasic.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SecurityStaticBasic;
    })();

    Qot_Common.WarrantStaticExData = (function() {

        /**
         * Properties of a WarrantStaticExData.
         * @memberof Qot_Common
         * @interface IWarrantStaticExData
         * @property {number} type WarrantStaticExData type
         * @property {Qot_Common.ISecurity} owner WarrantStaticExData owner
         */

        /**
         * Constructs a new WarrantStaticExData.
         * @memberof Qot_Common
         * @classdesc Represents a WarrantStaticExData.
         * @implements IWarrantStaticExData
         * @constructor
         * @param {Qot_Common.IWarrantStaticExData=} [properties] Properties to set
         */
        function WarrantStaticExData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WarrantStaticExData type.
         * @member {number} type
         * @memberof Qot_Common.WarrantStaticExData
         * @instance
         */
        WarrantStaticExData.prototype.type = 0;

        /**
         * WarrantStaticExData owner.
         * @member {Qot_Common.ISecurity} owner
         * @memberof Qot_Common.WarrantStaticExData
         * @instance
         */
        WarrantStaticExData.prototype.owner = null;

        /**
         * Creates a new WarrantStaticExData instance using the specified properties.
         * @function create
         * @memberof Qot_Common.WarrantStaticExData
         * @static
         * @param {Qot_Common.IWarrantStaticExData=} [properties] Properties to set
         * @returns {Qot_Common.WarrantStaticExData} WarrantStaticExData instance
         */
        WarrantStaticExData.create = function create(properties) {
            return new WarrantStaticExData(properties);
        };

        /**
         * Encodes the specified WarrantStaticExData message. Does not implicitly {@link Qot_Common.WarrantStaticExData.verify|verify} messages.
         * @function encode
         * @memberof Qot_Common.WarrantStaticExData
         * @static
         * @param {Qot_Common.IWarrantStaticExData} message WarrantStaticExData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WarrantStaticExData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            $root.Qot_Common.Security.encode(message.owner, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified WarrantStaticExData message, length delimited. Does not implicitly {@link Qot_Common.WarrantStaticExData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_Common.WarrantStaticExData
         * @static
         * @param {Qot_Common.IWarrantStaticExData} message WarrantStaticExData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WarrantStaticExData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WarrantStaticExData message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_Common.WarrantStaticExData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_Common.WarrantStaticExData} WarrantStaticExData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WarrantStaticExData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_Common.WarrantStaticExData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.owner = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("type"))
                throw $util.ProtocolError("missing required 'type'", { instance: message });
            if (!message.hasOwnProperty("owner"))
                throw $util.ProtocolError("missing required 'owner'", { instance: message });
            return message;
        };

        /**
         * Decodes a WarrantStaticExData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_Common.WarrantStaticExData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_Common.WarrantStaticExData} WarrantStaticExData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WarrantStaticExData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WarrantStaticExData message.
         * @function verify
         * @memberof Qot_Common.WarrantStaticExData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WarrantStaticExData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.type))
                return "type: integer expected";
            {
                var error = $root.Qot_Common.Security.verify(message.owner);
                if (error)
                    return "owner." + error;
            }
            return null;
        };

        /**
         * Creates a WarrantStaticExData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_Common.WarrantStaticExData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_Common.WarrantStaticExData} WarrantStaticExData
         */
        WarrantStaticExData.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_Common.WarrantStaticExData)
                return object;
            var message = new $root.Qot_Common.WarrantStaticExData();
            if (object.type != null)
                message.type = object.type | 0;
            if (object.owner != null) {
                if (typeof object.owner !== "object")
                    throw TypeError(".Qot_Common.WarrantStaticExData.owner: object expected");
                message.owner = $root.Qot_Common.Security.fromObject(object.owner);
            }
            return message;
        };

        /**
         * Creates a plain object from a WarrantStaticExData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_Common.WarrantStaticExData
         * @static
         * @param {Qot_Common.WarrantStaticExData} message WarrantStaticExData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WarrantStaticExData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = 0;
                object.owner = null;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.owner != null && message.hasOwnProperty("owner"))
                object.owner = $root.Qot_Common.Security.toObject(message.owner, options);
            return object;
        };

        /**
         * Converts this WarrantStaticExData to JSON.
         * @function toJSON
         * @memberof Qot_Common.WarrantStaticExData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WarrantStaticExData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return WarrantStaticExData;
    })();

    Qot_Common.OptionStaticExData = (function() {

        /**
         * Properties of an OptionStaticExData.
         * @memberof Qot_Common
         * @interface IOptionStaticExData
         * @property {number} type OptionStaticExData type
         * @property {Qot_Common.ISecurity} owner OptionStaticExData owner
         * @property {string} strikeTime OptionStaticExData strikeTime
         * @property {number} strikePrice OptionStaticExData strikePrice
         * @property {boolean} suspend OptionStaticExData suspend
         * @property {string} market OptionStaticExData market
         * @property {number|null} [strikeTimestamp] OptionStaticExData strikeTimestamp
         */

        /**
         * Constructs a new OptionStaticExData.
         * @memberof Qot_Common
         * @classdesc Represents an OptionStaticExData.
         * @implements IOptionStaticExData
         * @constructor
         * @param {Qot_Common.IOptionStaticExData=} [properties] Properties to set
         */
        function OptionStaticExData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OptionStaticExData type.
         * @member {number} type
         * @memberof Qot_Common.OptionStaticExData
         * @instance
         */
        OptionStaticExData.prototype.type = 0;

        /**
         * OptionStaticExData owner.
         * @member {Qot_Common.ISecurity} owner
         * @memberof Qot_Common.OptionStaticExData
         * @instance
         */
        OptionStaticExData.prototype.owner = null;

        /**
         * OptionStaticExData strikeTime.
         * @member {string} strikeTime
         * @memberof Qot_Common.OptionStaticExData
         * @instance
         */
        OptionStaticExData.prototype.strikeTime = "";

        /**
         * OptionStaticExData strikePrice.
         * @member {number} strikePrice
         * @memberof Qot_Common.OptionStaticExData
         * @instance
         */
        OptionStaticExData.prototype.strikePrice = 0;

        /**
         * OptionStaticExData suspend.
         * @member {boolean} suspend
         * @memberof Qot_Common.OptionStaticExData
         * @instance
         */
        OptionStaticExData.prototype.suspend = false;

        /**
         * OptionStaticExData market.
         * @member {string} market
         * @memberof Qot_Common.OptionStaticExData
         * @instance
         */
        OptionStaticExData.prototype.market = "";

        /**
         * OptionStaticExData strikeTimestamp.
         * @member {number} strikeTimestamp
         * @memberof Qot_Common.OptionStaticExData
         * @instance
         */
        OptionStaticExData.prototype.strikeTimestamp = 0;

        /**
         * Creates a new OptionStaticExData instance using the specified properties.
         * @function create
         * @memberof Qot_Common.OptionStaticExData
         * @static
         * @param {Qot_Common.IOptionStaticExData=} [properties] Properties to set
         * @returns {Qot_Common.OptionStaticExData} OptionStaticExData instance
         */
        OptionStaticExData.create = function create(properties) {
            return new OptionStaticExData(properties);
        };

        /**
         * Encodes the specified OptionStaticExData message. Does not implicitly {@link Qot_Common.OptionStaticExData.verify|verify} messages.
         * @function encode
         * @memberof Qot_Common.OptionStaticExData
         * @static
         * @param {Qot_Common.IOptionStaticExData} message OptionStaticExData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OptionStaticExData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            $root.Qot_Common.Security.encode(message.owner, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.strikeTime);
            writer.uint32(/* id 4, wireType 1 =*/33).double(message.strikePrice);
            writer.uint32(/* id 5, wireType 0 =*/40).bool(message.suspend);
            writer.uint32(/* id 6, wireType 2 =*/50).string(message.market);
            if (message.strikeTimestamp != null && message.hasOwnProperty("strikeTimestamp"))
                writer.uint32(/* id 7, wireType 1 =*/57).double(message.strikeTimestamp);
            return writer;
        };

        /**
         * Encodes the specified OptionStaticExData message, length delimited. Does not implicitly {@link Qot_Common.OptionStaticExData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_Common.OptionStaticExData
         * @static
         * @param {Qot_Common.IOptionStaticExData} message OptionStaticExData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OptionStaticExData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OptionStaticExData message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_Common.OptionStaticExData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_Common.OptionStaticExData} OptionStaticExData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OptionStaticExData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_Common.OptionStaticExData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.owner = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.strikeTime = reader.string();
                    break;
                case 4:
                    message.strikePrice = reader.double();
                    break;
                case 5:
                    message.suspend = reader.bool();
                    break;
                case 6:
                    message.market = reader.string();
                    break;
                case 7:
                    message.strikeTimestamp = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("type"))
                throw $util.ProtocolError("missing required 'type'", { instance: message });
            if (!message.hasOwnProperty("owner"))
                throw $util.ProtocolError("missing required 'owner'", { instance: message });
            if (!message.hasOwnProperty("strikeTime"))
                throw $util.ProtocolError("missing required 'strikeTime'", { instance: message });
            if (!message.hasOwnProperty("strikePrice"))
                throw $util.ProtocolError("missing required 'strikePrice'", { instance: message });
            if (!message.hasOwnProperty("suspend"))
                throw $util.ProtocolError("missing required 'suspend'", { instance: message });
            if (!message.hasOwnProperty("market"))
                throw $util.ProtocolError("missing required 'market'", { instance: message });
            return message;
        };

        /**
         * Decodes an OptionStaticExData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_Common.OptionStaticExData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_Common.OptionStaticExData} OptionStaticExData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OptionStaticExData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OptionStaticExData message.
         * @function verify
         * @memberof Qot_Common.OptionStaticExData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OptionStaticExData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.type))
                return "type: integer expected";
            {
                var error = $root.Qot_Common.Security.verify(message.owner);
                if (error)
                    return "owner." + error;
            }
            if (!$util.isString(message.strikeTime))
                return "strikeTime: string expected";
            if (typeof message.strikePrice !== "number")
                return "strikePrice: number expected";
            if (typeof message.suspend !== "boolean")
                return "suspend: boolean expected";
            if (!$util.isString(message.market))
                return "market: string expected";
            if (message.strikeTimestamp != null && message.hasOwnProperty("strikeTimestamp"))
                if (typeof message.strikeTimestamp !== "number")
                    return "strikeTimestamp: number expected";
            return null;
        };

        /**
         * Creates an OptionStaticExData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_Common.OptionStaticExData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_Common.OptionStaticExData} OptionStaticExData
         */
        OptionStaticExData.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_Common.OptionStaticExData)
                return object;
            var message = new $root.Qot_Common.OptionStaticExData();
            if (object.type != null)
                message.type = object.type | 0;
            if (object.owner != null) {
                if (typeof object.owner !== "object")
                    throw TypeError(".Qot_Common.OptionStaticExData.owner: object expected");
                message.owner = $root.Qot_Common.Security.fromObject(object.owner);
            }
            if (object.strikeTime != null)
                message.strikeTime = String(object.strikeTime);
            if (object.strikePrice != null)
                message.strikePrice = Number(object.strikePrice);
            if (object.suspend != null)
                message.suspend = Boolean(object.suspend);
            if (object.market != null)
                message.market = String(object.market);
            if (object.strikeTimestamp != null)
                message.strikeTimestamp = Number(object.strikeTimestamp);
            return message;
        };

        /**
         * Creates a plain object from an OptionStaticExData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_Common.OptionStaticExData
         * @static
         * @param {Qot_Common.OptionStaticExData} message OptionStaticExData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OptionStaticExData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = 0;
                object.owner = null;
                object.strikeTime = "";
                object.strikePrice = 0;
                object.suspend = false;
                object.market = "";
                object.strikeTimestamp = 0;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.owner != null && message.hasOwnProperty("owner"))
                object.owner = $root.Qot_Common.Security.toObject(message.owner, options);
            if (message.strikeTime != null && message.hasOwnProperty("strikeTime"))
                object.strikeTime = message.strikeTime;
            if (message.strikePrice != null && message.hasOwnProperty("strikePrice"))
                object.strikePrice = options.json && !isFinite(message.strikePrice) ? String(message.strikePrice) : message.strikePrice;
            if (message.suspend != null && message.hasOwnProperty("suspend"))
                object.suspend = message.suspend;
            if (message.market != null && message.hasOwnProperty("market"))
                object.market = message.market;
            if (message.strikeTimestamp != null && message.hasOwnProperty("strikeTimestamp"))
                object.strikeTimestamp = options.json && !isFinite(message.strikeTimestamp) ? String(message.strikeTimestamp) : message.strikeTimestamp;
            return object;
        };

        /**
         * Converts this OptionStaticExData to JSON.
         * @function toJSON
         * @memberof Qot_Common.OptionStaticExData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OptionStaticExData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return OptionStaticExData;
    })();

    Qot_Common.SecurityStaticInfo = (function() {

        /**
         * Properties of a SecurityStaticInfo.
         * @memberof Qot_Common
         * @interface ISecurityStaticInfo
         * @property {Qot_Common.ISecurityStaticBasic} basic SecurityStaticInfo basic
         * @property {Qot_Common.IWarrantStaticExData|null} [warrantExData] SecurityStaticInfo warrantExData
         * @property {Qot_Common.IOptionStaticExData|null} [optionExData] SecurityStaticInfo optionExData
         */

        /**
         * Constructs a new SecurityStaticInfo.
         * @memberof Qot_Common
         * @classdesc Represents a SecurityStaticInfo.
         * @implements ISecurityStaticInfo
         * @constructor
         * @param {Qot_Common.ISecurityStaticInfo=} [properties] Properties to set
         */
        function SecurityStaticInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SecurityStaticInfo basic.
         * @member {Qot_Common.ISecurityStaticBasic} basic
         * @memberof Qot_Common.SecurityStaticInfo
         * @instance
         */
        SecurityStaticInfo.prototype.basic = null;

        /**
         * SecurityStaticInfo warrantExData.
         * @member {Qot_Common.IWarrantStaticExData|null|undefined} warrantExData
         * @memberof Qot_Common.SecurityStaticInfo
         * @instance
         */
        SecurityStaticInfo.prototype.warrantExData = null;

        /**
         * SecurityStaticInfo optionExData.
         * @member {Qot_Common.IOptionStaticExData|null|undefined} optionExData
         * @memberof Qot_Common.SecurityStaticInfo
         * @instance
         */
        SecurityStaticInfo.prototype.optionExData = null;

        /**
         * Creates a new SecurityStaticInfo instance using the specified properties.
         * @function create
         * @memberof Qot_Common.SecurityStaticInfo
         * @static
         * @param {Qot_Common.ISecurityStaticInfo=} [properties] Properties to set
         * @returns {Qot_Common.SecurityStaticInfo} SecurityStaticInfo instance
         */
        SecurityStaticInfo.create = function create(properties) {
            return new SecurityStaticInfo(properties);
        };

        /**
         * Encodes the specified SecurityStaticInfo message. Does not implicitly {@link Qot_Common.SecurityStaticInfo.verify|verify} messages.
         * @function encode
         * @memberof Qot_Common.SecurityStaticInfo
         * @static
         * @param {Qot_Common.ISecurityStaticInfo} message SecurityStaticInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SecurityStaticInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.SecurityStaticBasic.encode(message.basic, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.warrantExData != null && message.hasOwnProperty("warrantExData"))
                $root.Qot_Common.WarrantStaticExData.encode(message.warrantExData, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.optionExData != null && message.hasOwnProperty("optionExData"))
                $root.Qot_Common.OptionStaticExData.encode(message.optionExData, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SecurityStaticInfo message, length delimited. Does not implicitly {@link Qot_Common.SecurityStaticInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_Common.SecurityStaticInfo
         * @static
         * @param {Qot_Common.ISecurityStaticInfo} message SecurityStaticInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SecurityStaticInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SecurityStaticInfo message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_Common.SecurityStaticInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_Common.SecurityStaticInfo} SecurityStaticInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SecurityStaticInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_Common.SecurityStaticInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.basic = $root.Qot_Common.SecurityStaticBasic.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.warrantExData = $root.Qot_Common.WarrantStaticExData.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.optionExData = $root.Qot_Common.OptionStaticExData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("basic"))
                throw $util.ProtocolError("missing required 'basic'", { instance: message });
            return message;
        };

        /**
         * Decodes a SecurityStaticInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_Common.SecurityStaticInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_Common.SecurityStaticInfo} SecurityStaticInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SecurityStaticInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SecurityStaticInfo message.
         * @function verify
         * @memberof Qot_Common.SecurityStaticInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SecurityStaticInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.SecurityStaticBasic.verify(message.basic);
                if (error)
                    return "basic." + error;
            }
            if (message.warrantExData != null && message.hasOwnProperty("warrantExData")) {
                var error = $root.Qot_Common.WarrantStaticExData.verify(message.warrantExData);
                if (error)
                    return "warrantExData." + error;
            }
            if (message.optionExData != null && message.hasOwnProperty("optionExData")) {
                var error = $root.Qot_Common.OptionStaticExData.verify(message.optionExData);
                if (error)
                    return "optionExData." + error;
            }
            return null;
        };

        /**
         * Creates a SecurityStaticInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_Common.SecurityStaticInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_Common.SecurityStaticInfo} SecurityStaticInfo
         */
        SecurityStaticInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_Common.SecurityStaticInfo)
                return object;
            var message = new $root.Qot_Common.SecurityStaticInfo();
            if (object.basic != null) {
                if (typeof object.basic !== "object")
                    throw TypeError(".Qot_Common.SecurityStaticInfo.basic: object expected");
                message.basic = $root.Qot_Common.SecurityStaticBasic.fromObject(object.basic);
            }
            if (object.warrantExData != null) {
                if (typeof object.warrantExData !== "object")
                    throw TypeError(".Qot_Common.SecurityStaticInfo.warrantExData: object expected");
                message.warrantExData = $root.Qot_Common.WarrantStaticExData.fromObject(object.warrantExData);
            }
            if (object.optionExData != null) {
                if (typeof object.optionExData !== "object")
                    throw TypeError(".Qot_Common.SecurityStaticInfo.optionExData: object expected");
                message.optionExData = $root.Qot_Common.OptionStaticExData.fromObject(object.optionExData);
            }
            return message;
        };

        /**
         * Creates a plain object from a SecurityStaticInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_Common.SecurityStaticInfo
         * @static
         * @param {Qot_Common.SecurityStaticInfo} message SecurityStaticInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SecurityStaticInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.basic = null;
                object.warrantExData = null;
                object.optionExData = null;
            }
            if (message.basic != null && message.hasOwnProperty("basic"))
                object.basic = $root.Qot_Common.SecurityStaticBasic.toObject(message.basic, options);
            if (message.warrantExData != null && message.hasOwnProperty("warrantExData"))
                object.warrantExData = $root.Qot_Common.WarrantStaticExData.toObject(message.warrantExData, options);
            if (message.optionExData != null && message.hasOwnProperty("optionExData"))
                object.optionExData = $root.Qot_Common.OptionStaticExData.toObject(message.optionExData, options);
            return object;
        };

        /**
         * Converts this SecurityStaticInfo to JSON.
         * @function toJSON
         * @memberof Qot_Common.SecurityStaticInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SecurityStaticInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SecurityStaticInfo;
    })();

    Qot_Common.Broker = (function() {

        /**
         * Properties of a Broker.
         * @memberof Qot_Common
         * @interface IBroker
         * @property {number|Long} id Broker id
         * @property {string} name Broker name
         * @property {number} pos Broker pos
         */

        /**
         * Constructs a new Broker.
         * @memberof Qot_Common
         * @classdesc Represents a Broker.
         * @implements IBroker
         * @constructor
         * @param {Qot_Common.IBroker=} [properties] Properties to set
         */
        function Broker(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Broker id.
         * @member {number|Long} id
         * @memberof Qot_Common.Broker
         * @instance
         */
        Broker.prototype.id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Broker name.
         * @member {string} name
         * @memberof Qot_Common.Broker
         * @instance
         */
        Broker.prototype.name = "";

        /**
         * Broker pos.
         * @member {number} pos
         * @memberof Qot_Common.Broker
         * @instance
         */
        Broker.prototype.pos = 0;

        /**
         * Creates a new Broker instance using the specified properties.
         * @function create
         * @memberof Qot_Common.Broker
         * @static
         * @param {Qot_Common.IBroker=} [properties] Properties to set
         * @returns {Qot_Common.Broker} Broker instance
         */
        Broker.create = function create(properties) {
            return new Broker(properties);
        };

        /**
         * Encodes the specified Broker message. Does not implicitly {@link Qot_Common.Broker.verify|verify} messages.
         * @function encode
         * @memberof Qot_Common.Broker
         * @static
         * @param {Qot_Common.IBroker} message Broker message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Broker.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.id);
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.pos);
            return writer;
        };

        /**
         * Encodes the specified Broker message, length delimited. Does not implicitly {@link Qot_Common.Broker.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_Common.Broker
         * @static
         * @param {Qot_Common.IBroker} message Broker message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Broker.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Broker message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_Common.Broker
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_Common.Broker} Broker
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Broker.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_Common.Broker();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.int64();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.pos = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            if (!message.hasOwnProperty("name"))
                throw $util.ProtocolError("missing required 'name'", { instance: message });
            if (!message.hasOwnProperty("pos"))
                throw $util.ProtocolError("missing required 'pos'", { instance: message });
            return message;
        };

        /**
         * Decodes a Broker message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_Common.Broker
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_Common.Broker} Broker
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Broker.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Broker message.
         * @function verify
         * @memberof Qot_Common.Broker
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Broker.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                return "id: integer|Long expected";
            if (!$util.isString(message.name))
                return "name: string expected";
            if (!$util.isInteger(message.pos))
                return "pos: integer expected";
            return null;
        };

        /**
         * Creates a Broker message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_Common.Broker
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_Common.Broker} Broker
         */
        Broker.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_Common.Broker)
                return object;
            var message = new $root.Qot_Common.Broker();
            if (object.id != null)
                if ($util.Long)
                    (message.id = $util.Long.fromValue(object.id)).unsigned = false;
                else if (typeof object.id === "string")
                    message.id = parseInt(object.id, 10);
                else if (typeof object.id === "number")
                    message.id = object.id;
                else if (typeof object.id === "object")
                    message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber();
            if (object.name != null)
                message.name = String(object.name);
            if (object.pos != null)
                message.pos = object.pos | 0;
            return message;
        };

        /**
         * Creates a plain object from a Broker message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_Common.Broker
         * @static
         * @param {Qot_Common.Broker} message Broker
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Broker.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.id = options.longs === String ? "0" : 0;
                object.name = "";
                object.pos = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                if (typeof message.id === "number")
                    object.id = options.longs === String ? String(message.id) : message.id;
                else
                    object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber() : message.id;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.pos != null && message.hasOwnProperty("pos"))
                object.pos = message.pos;
            return object;
        };

        /**
         * Converts this Broker to JSON.
         * @function toJSON
         * @memberof Qot_Common.Broker
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Broker.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Broker;
    })();

    Qot_Common.Ticker = (function() {

        /**
         * Properties of a Ticker.
         * @memberof Qot_Common
         * @interface ITicker
         * @property {string} time Ticker time
         * @property {number|Long} sequence Ticker sequence
         * @property {number} dir Ticker dir
         * @property {number} price Ticker price
         * @property {number|Long} volume Ticker volume
         * @property {number} turnover Ticker turnover
         * @property {number|null} [recvTime] Ticker recvTime
         * @property {number|null} [type] Ticker type
         * @property {number|null} [typeSign] Ticker typeSign
         * @property {number|null} [pushDataType] Ticker pushDataType
         * @property {number|null} [timestamp] Ticker timestamp
         */

        /**
         * Constructs a new Ticker.
         * @memberof Qot_Common
         * @classdesc Represents a Ticker.
         * @implements ITicker
         * @constructor
         * @param {Qot_Common.ITicker=} [properties] Properties to set
         */
        function Ticker(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Ticker time.
         * @member {string} time
         * @memberof Qot_Common.Ticker
         * @instance
         */
        Ticker.prototype.time = "";

        /**
         * Ticker sequence.
         * @member {number|Long} sequence
         * @memberof Qot_Common.Ticker
         * @instance
         */
        Ticker.prototype.sequence = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Ticker dir.
         * @member {number} dir
         * @memberof Qot_Common.Ticker
         * @instance
         */
        Ticker.prototype.dir = 0;

        /**
         * Ticker price.
         * @member {number} price
         * @memberof Qot_Common.Ticker
         * @instance
         */
        Ticker.prototype.price = 0;

        /**
         * Ticker volume.
         * @member {number|Long} volume
         * @memberof Qot_Common.Ticker
         * @instance
         */
        Ticker.prototype.volume = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Ticker turnover.
         * @member {number} turnover
         * @memberof Qot_Common.Ticker
         * @instance
         */
        Ticker.prototype.turnover = 0;

        /**
         * Ticker recvTime.
         * @member {number} recvTime
         * @memberof Qot_Common.Ticker
         * @instance
         */
        Ticker.prototype.recvTime = 0;

        /**
         * Ticker type.
         * @member {number} type
         * @memberof Qot_Common.Ticker
         * @instance
         */
        Ticker.prototype.type = 0;

        /**
         * Ticker typeSign.
         * @member {number} typeSign
         * @memberof Qot_Common.Ticker
         * @instance
         */
        Ticker.prototype.typeSign = 0;

        /**
         * Ticker pushDataType.
         * @member {number} pushDataType
         * @memberof Qot_Common.Ticker
         * @instance
         */
        Ticker.prototype.pushDataType = 0;

        /**
         * Ticker timestamp.
         * @member {number} timestamp
         * @memberof Qot_Common.Ticker
         * @instance
         */
        Ticker.prototype.timestamp = 0;

        /**
         * Creates a new Ticker instance using the specified properties.
         * @function create
         * @memberof Qot_Common.Ticker
         * @static
         * @param {Qot_Common.ITicker=} [properties] Properties to set
         * @returns {Qot_Common.Ticker} Ticker instance
         */
        Ticker.create = function create(properties) {
            return new Ticker(properties);
        };

        /**
         * Encodes the specified Ticker message. Does not implicitly {@link Qot_Common.Ticker.verify|verify} messages.
         * @function encode
         * @memberof Qot_Common.Ticker
         * @static
         * @param {Qot_Common.ITicker} message Ticker message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Ticker.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.time);
            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.sequence);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.dir);
            writer.uint32(/* id 4, wireType 1 =*/33).double(message.price);
            writer.uint32(/* id 5, wireType 0 =*/40).int64(message.volume);
            writer.uint32(/* id 6, wireType 1 =*/49).double(message.turnover);
            if (message.recvTime != null && message.hasOwnProperty("recvTime"))
                writer.uint32(/* id 7, wireType 1 =*/57).double(message.recvTime);
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.type);
            if (message.typeSign != null && message.hasOwnProperty("typeSign"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.typeSign);
            if (message.pushDataType != null && message.hasOwnProperty("pushDataType"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.pushDataType);
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                writer.uint32(/* id 11, wireType 1 =*/89).double(message.timestamp);
            return writer;
        };

        /**
         * Encodes the specified Ticker message, length delimited. Does not implicitly {@link Qot_Common.Ticker.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_Common.Ticker
         * @static
         * @param {Qot_Common.ITicker} message Ticker message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Ticker.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Ticker message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_Common.Ticker
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_Common.Ticker} Ticker
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Ticker.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_Common.Ticker();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.time = reader.string();
                    break;
                case 2:
                    message.sequence = reader.int64();
                    break;
                case 3:
                    message.dir = reader.int32();
                    break;
                case 4:
                    message.price = reader.double();
                    break;
                case 5:
                    message.volume = reader.int64();
                    break;
                case 6:
                    message.turnover = reader.double();
                    break;
                case 7:
                    message.recvTime = reader.double();
                    break;
                case 8:
                    message.type = reader.int32();
                    break;
                case 9:
                    message.typeSign = reader.int32();
                    break;
                case 10:
                    message.pushDataType = reader.int32();
                    break;
                case 11:
                    message.timestamp = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("time"))
                throw $util.ProtocolError("missing required 'time'", { instance: message });
            if (!message.hasOwnProperty("sequence"))
                throw $util.ProtocolError("missing required 'sequence'", { instance: message });
            if (!message.hasOwnProperty("dir"))
                throw $util.ProtocolError("missing required 'dir'", { instance: message });
            if (!message.hasOwnProperty("price"))
                throw $util.ProtocolError("missing required 'price'", { instance: message });
            if (!message.hasOwnProperty("volume"))
                throw $util.ProtocolError("missing required 'volume'", { instance: message });
            if (!message.hasOwnProperty("turnover"))
                throw $util.ProtocolError("missing required 'turnover'", { instance: message });
            return message;
        };

        /**
         * Decodes a Ticker message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_Common.Ticker
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_Common.Ticker} Ticker
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Ticker.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Ticker message.
         * @function verify
         * @memberof Qot_Common.Ticker
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Ticker.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.time))
                return "time: string expected";
            if (!$util.isInteger(message.sequence) && !(message.sequence && $util.isInteger(message.sequence.low) && $util.isInteger(message.sequence.high)))
                return "sequence: integer|Long expected";
            if (!$util.isInteger(message.dir))
                return "dir: integer expected";
            if (typeof message.price !== "number")
                return "price: number expected";
            if (!$util.isInteger(message.volume) && !(message.volume && $util.isInteger(message.volume.low) && $util.isInteger(message.volume.high)))
                return "volume: integer|Long expected";
            if (typeof message.turnover !== "number")
                return "turnover: number expected";
            if (message.recvTime != null && message.hasOwnProperty("recvTime"))
                if (typeof message.recvTime !== "number")
                    return "recvTime: number expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.typeSign != null && message.hasOwnProperty("typeSign"))
                if (!$util.isInteger(message.typeSign))
                    return "typeSign: integer expected";
            if (message.pushDataType != null && message.hasOwnProperty("pushDataType"))
                if (!$util.isInteger(message.pushDataType))
                    return "pushDataType: integer expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp !== "number")
                    return "timestamp: number expected";
            return null;
        };

        /**
         * Creates a Ticker message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_Common.Ticker
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_Common.Ticker} Ticker
         */
        Ticker.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_Common.Ticker)
                return object;
            var message = new $root.Qot_Common.Ticker();
            if (object.time != null)
                message.time = String(object.time);
            if (object.sequence != null)
                if ($util.Long)
                    (message.sequence = $util.Long.fromValue(object.sequence)).unsigned = false;
                else if (typeof object.sequence === "string")
                    message.sequence = parseInt(object.sequence, 10);
                else if (typeof object.sequence === "number")
                    message.sequence = object.sequence;
                else if (typeof object.sequence === "object")
                    message.sequence = new $util.LongBits(object.sequence.low >>> 0, object.sequence.high >>> 0).toNumber();
            if (object.dir != null)
                message.dir = object.dir | 0;
            if (object.price != null)
                message.price = Number(object.price);
            if (object.volume != null)
                if ($util.Long)
                    (message.volume = $util.Long.fromValue(object.volume)).unsigned = false;
                else if (typeof object.volume === "string")
                    message.volume = parseInt(object.volume, 10);
                else if (typeof object.volume === "number")
                    message.volume = object.volume;
                else if (typeof object.volume === "object")
                    message.volume = new $util.LongBits(object.volume.low >>> 0, object.volume.high >>> 0).toNumber();
            if (object.turnover != null)
                message.turnover = Number(object.turnover);
            if (object.recvTime != null)
                message.recvTime = Number(object.recvTime);
            if (object.type != null)
                message.type = object.type | 0;
            if (object.typeSign != null)
                message.typeSign = object.typeSign | 0;
            if (object.pushDataType != null)
                message.pushDataType = object.pushDataType | 0;
            if (object.timestamp != null)
                message.timestamp = Number(object.timestamp);
            return message;
        };

        /**
         * Creates a plain object from a Ticker message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_Common.Ticker
         * @static
         * @param {Qot_Common.Ticker} message Ticker
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Ticker.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.time = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.sequence = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.sequence = options.longs === String ? "0" : 0;
                object.dir = 0;
                object.price = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.volume = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.volume = options.longs === String ? "0" : 0;
                object.turnover = 0;
                object.recvTime = 0;
                object.type = 0;
                object.typeSign = 0;
                object.pushDataType = 0;
                object.timestamp = 0;
            }
            if (message.time != null && message.hasOwnProperty("time"))
                object.time = message.time;
            if (message.sequence != null && message.hasOwnProperty("sequence"))
                if (typeof message.sequence === "number")
                    object.sequence = options.longs === String ? String(message.sequence) : message.sequence;
                else
                    object.sequence = options.longs === String ? $util.Long.prototype.toString.call(message.sequence) : options.longs === Number ? new $util.LongBits(message.sequence.low >>> 0, message.sequence.high >>> 0).toNumber() : message.sequence;
            if (message.dir != null && message.hasOwnProperty("dir"))
                object.dir = message.dir;
            if (message.price != null && message.hasOwnProperty("price"))
                object.price = options.json && !isFinite(message.price) ? String(message.price) : message.price;
            if (message.volume != null && message.hasOwnProperty("volume"))
                if (typeof message.volume === "number")
                    object.volume = options.longs === String ? String(message.volume) : message.volume;
                else
                    object.volume = options.longs === String ? $util.Long.prototype.toString.call(message.volume) : options.longs === Number ? new $util.LongBits(message.volume.low >>> 0, message.volume.high >>> 0).toNumber() : message.volume;
            if (message.turnover != null && message.hasOwnProperty("turnover"))
                object.turnover = options.json && !isFinite(message.turnover) ? String(message.turnover) : message.turnover;
            if (message.recvTime != null && message.hasOwnProperty("recvTime"))
                object.recvTime = options.json && !isFinite(message.recvTime) ? String(message.recvTime) : message.recvTime;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.typeSign != null && message.hasOwnProperty("typeSign"))
                object.typeSign = message.typeSign;
            if (message.pushDataType != null && message.hasOwnProperty("pushDataType"))
                object.pushDataType = message.pushDataType;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                object.timestamp = options.json && !isFinite(message.timestamp) ? String(message.timestamp) : message.timestamp;
            return object;
        };

        /**
         * Converts this Ticker to JSON.
         * @function toJSON
         * @memberof Qot_Common.Ticker
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Ticker.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Ticker;
    })();

    Qot_Common.OrderBook = (function() {

        /**
         * Properties of an OrderBook.
         * @memberof Qot_Common
         * @interface IOrderBook
         * @property {number} price OrderBook price
         * @property {number|Long} volume OrderBook volume
         * @property {number} orederCount OrderBook orederCount
         */

        /**
         * Constructs a new OrderBook.
         * @memberof Qot_Common
         * @classdesc Represents an OrderBook.
         * @implements IOrderBook
         * @constructor
         * @param {Qot_Common.IOrderBook=} [properties] Properties to set
         */
        function OrderBook(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OrderBook price.
         * @member {number} price
         * @memberof Qot_Common.OrderBook
         * @instance
         */
        OrderBook.prototype.price = 0;

        /**
         * OrderBook volume.
         * @member {number|Long} volume
         * @memberof Qot_Common.OrderBook
         * @instance
         */
        OrderBook.prototype.volume = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * OrderBook orederCount.
         * @member {number} orederCount
         * @memberof Qot_Common.OrderBook
         * @instance
         */
        OrderBook.prototype.orederCount = 0;

        /**
         * Creates a new OrderBook instance using the specified properties.
         * @function create
         * @memberof Qot_Common.OrderBook
         * @static
         * @param {Qot_Common.IOrderBook=} [properties] Properties to set
         * @returns {Qot_Common.OrderBook} OrderBook instance
         */
        OrderBook.create = function create(properties) {
            return new OrderBook(properties);
        };

        /**
         * Encodes the specified OrderBook message. Does not implicitly {@link Qot_Common.OrderBook.verify|verify} messages.
         * @function encode
         * @memberof Qot_Common.OrderBook
         * @static
         * @param {Qot_Common.IOrderBook} message OrderBook message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OrderBook.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 1 =*/9).double(message.price);
            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.volume);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.orederCount);
            return writer;
        };

        /**
         * Encodes the specified OrderBook message, length delimited. Does not implicitly {@link Qot_Common.OrderBook.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_Common.OrderBook
         * @static
         * @param {Qot_Common.IOrderBook} message OrderBook message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OrderBook.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OrderBook message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_Common.OrderBook
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_Common.OrderBook} OrderBook
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OrderBook.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_Common.OrderBook();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.price = reader.double();
                    break;
                case 2:
                    message.volume = reader.int64();
                    break;
                case 3:
                    message.orederCount = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("price"))
                throw $util.ProtocolError("missing required 'price'", { instance: message });
            if (!message.hasOwnProperty("volume"))
                throw $util.ProtocolError("missing required 'volume'", { instance: message });
            if (!message.hasOwnProperty("orederCount"))
                throw $util.ProtocolError("missing required 'orederCount'", { instance: message });
            return message;
        };

        /**
         * Decodes an OrderBook message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_Common.OrderBook
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_Common.OrderBook} OrderBook
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OrderBook.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OrderBook message.
         * @function verify
         * @memberof Qot_Common.OrderBook
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OrderBook.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (typeof message.price !== "number")
                return "price: number expected";
            if (!$util.isInteger(message.volume) && !(message.volume && $util.isInteger(message.volume.low) && $util.isInteger(message.volume.high)))
                return "volume: integer|Long expected";
            if (!$util.isInteger(message.orederCount))
                return "orederCount: integer expected";
            return null;
        };

        /**
         * Creates an OrderBook message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_Common.OrderBook
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_Common.OrderBook} OrderBook
         */
        OrderBook.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_Common.OrderBook)
                return object;
            var message = new $root.Qot_Common.OrderBook();
            if (object.price != null)
                message.price = Number(object.price);
            if (object.volume != null)
                if ($util.Long)
                    (message.volume = $util.Long.fromValue(object.volume)).unsigned = false;
                else if (typeof object.volume === "string")
                    message.volume = parseInt(object.volume, 10);
                else if (typeof object.volume === "number")
                    message.volume = object.volume;
                else if (typeof object.volume === "object")
                    message.volume = new $util.LongBits(object.volume.low >>> 0, object.volume.high >>> 0).toNumber();
            if (object.orederCount != null)
                message.orederCount = object.orederCount | 0;
            return message;
        };

        /**
         * Creates a plain object from an OrderBook message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_Common.OrderBook
         * @static
         * @param {Qot_Common.OrderBook} message OrderBook
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OrderBook.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.price = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.volume = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.volume = options.longs === String ? "0" : 0;
                object.orederCount = 0;
            }
            if (message.price != null && message.hasOwnProperty("price"))
                object.price = options.json && !isFinite(message.price) ? String(message.price) : message.price;
            if (message.volume != null && message.hasOwnProperty("volume"))
                if (typeof message.volume === "number")
                    object.volume = options.longs === String ? String(message.volume) : message.volume;
                else
                    object.volume = options.longs === String ? $util.Long.prototype.toString.call(message.volume) : options.longs === Number ? new $util.LongBits(message.volume.low >>> 0, message.volume.high >>> 0).toNumber() : message.volume;
            if (message.orederCount != null && message.hasOwnProperty("orederCount"))
                object.orederCount = message.orederCount;
            return object;
        };

        /**
         * Converts this OrderBook to JSON.
         * @function toJSON
         * @memberof Qot_Common.OrderBook
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OrderBook.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return OrderBook;
    })();

    Qot_Common.OrderDetail = (function() {

        /**
         * Properties of an OrderDetail.
         * @memberof Qot_Common
         * @interface IOrderDetail
         * @property {number} orderCount OrderDetail orderCount
         * @property {Array.<number>|null} [orderVol] OrderDetail orderVol
         */

        /**
         * Constructs a new OrderDetail.
         * @memberof Qot_Common
         * @classdesc Represents an OrderDetail.
         * @implements IOrderDetail
         * @constructor
         * @param {Qot_Common.IOrderDetail=} [properties] Properties to set
         */
        function OrderDetail(properties) {
            this.orderVol = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OrderDetail orderCount.
         * @member {number} orderCount
         * @memberof Qot_Common.OrderDetail
         * @instance
         */
        OrderDetail.prototype.orderCount = 0;

        /**
         * OrderDetail orderVol.
         * @member {Array.<number>} orderVol
         * @memberof Qot_Common.OrderDetail
         * @instance
         */
        OrderDetail.prototype.orderVol = $util.emptyArray;

        /**
         * Creates a new OrderDetail instance using the specified properties.
         * @function create
         * @memberof Qot_Common.OrderDetail
         * @static
         * @param {Qot_Common.IOrderDetail=} [properties] Properties to set
         * @returns {Qot_Common.OrderDetail} OrderDetail instance
         */
        OrderDetail.create = function create(properties) {
            return new OrderDetail(properties);
        };

        /**
         * Encodes the specified OrderDetail message. Does not implicitly {@link Qot_Common.OrderDetail.verify|verify} messages.
         * @function encode
         * @memberof Qot_Common.OrderDetail
         * @static
         * @param {Qot_Common.IOrderDetail} message OrderDetail message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OrderDetail.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.orderCount);
            if (message.orderVol != null && message.orderVol.length)
                for (var i = 0; i < message.orderVol.length; ++i)
                    writer.uint32(/* id 2, wireType 1 =*/17).double(message.orderVol[i]);
            return writer;
        };

        /**
         * Encodes the specified OrderDetail message, length delimited. Does not implicitly {@link Qot_Common.OrderDetail.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_Common.OrderDetail
         * @static
         * @param {Qot_Common.IOrderDetail} message OrderDetail message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OrderDetail.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OrderDetail message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_Common.OrderDetail
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_Common.OrderDetail} OrderDetail
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OrderDetail.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_Common.OrderDetail();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.orderCount = reader.int32();
                    break;
                case 2:
                    if (!(message.orderVol && message.orderVol.length))
                        message.orderVol = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.orderVol.push(reader.double());
                    } else
                        message.orderVol.push(reader.double());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("orderCount"))
                throw $util.ProtocolError("missing required 'orderCount'", { instance: message });
            return message;
        };

        /**
         * Decodes an OrderDetail message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_Common.OrderDetail
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_Common.OrderDetail} OrderDetail
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OrderDetail.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OrderDetail message.
         * @function verify
         * @memberof Qot_Common.OrderDetail
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OrderDetail.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.orderCount))
                return "orderCount: integer expected";
            if (message.orderVol != null && message.hasOwnProperty("orderVol")) {
                if (!Array.isArray(message.orderVol))
                    return "orderVol: array expected";
                for (var i = 0; i < message.orderVol.length; ++i)
                    if (typeof message.orderVol[i] !== "number")
                        return "orderVol: number[] expected";
            }
            return null;
        };

        /**
         * Creates an OrderDetail message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_Common.OrderDetail
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_Common.OrderDetail} OrderDetail
         */
        OrderDetail.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_Common.OrderDetail)
                return object;
            var message = new $root.Qot_Common.OrderDetail();
            if (object.orderCount != null)
                message.orderCount = object.orderCount | 0;
            if (object.orderVol) {
                if (!Array.isArray(object.orderVol))
                    throw TypeError(".Qot_Common.OrderDetail.orderVol: array expected");
                message.orderVol = [];
                for (var i = 0; i < object.orderVol.length; ++i)
                    message.orderVol[i] = Number(object.orderVol[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from an OrderDetail message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_Common.OrderDetail
         * @static
         * @param {Qot_Common.OrderDetail} message OrderDetail
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OrderDetail.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.orderVol = [];
            if (options.defaults)
                object.orderCount = 0;
            if (message.orderCount != null && message.hasOwnProperty("orderCount"))
                object.orderCount = message.orderCount;
            if (message.orderVol && message.orderVol.length) {
                object.orderVol = [];
                for (var j = 0; j < message.orderVol.length; ++j)
                    object.orderVol[j] = options.json && !isFinite(message.orderVol[j]) ? String(message.orderVol[j]) : message.orderVol[j];
            }
            return object;
        };

        /**
         * Converts this OrderDetail to JSON.
         * @function toJSON
         * @memberof Qot_Common.OrderDetail
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OrderDetail.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return OrderDetail;
    })();

    Qot_Common.ShareHoldingChange = (function() {

        /**
         * Properties of a ShareHoldingChange.
         * @memberof Qot_Common
         * @interface IShareHoldingChange
         * @property {string} holderName ShareHoldingChange holderName
         * @property {number} holdingQty ShareHoldingChange holdingQty
         * @property {number} holdingRatio ShareHoldingChange holdingRatio
         * @property {number} changeQty ShareHoldingChange changeQty
         * @property {number} changeRatio ShareHoldingChange changeRatio
         * @property {string} time ShareHoldingChange time
         * @property {number|null} [timestamp] ShareHoldingChange timestamp
         */

        /**
         * Constructs a new ShareHoldingChange.
         * @memberof Qot_Common
         * @classdesc Represents a ShareHoldingChange.
         * @implements IShareHoldingChange
         * @constructor
         * @param {Qot_Common.IShareHoldingChange=} [properties] Properties to set
         */
        function ShareHoldingChange(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ShareHoldingChange holderName.
         * @member {string} holderName
         * @memberof Qot_Common.ShareHoldingChange
         * @instance
         */
        ShareHoldingChange.prototype.holderName = "";

        /**
         * ShareHoldingChange holdingQty.
         * @member {number} holdingQty
         * @memberof Qot_Common.ShareHoldingChange
         * @instance
         */
        ShareHoldingChange.prototype.holdingQty = 0;

        /**
         * ShareHoldingChange holdingRatio.
         * @member {number} holdingRatio
         * @memberof Qot_Common.ShareHoldingChange
         * @instance
         */
        ShareHoldingChange.prototype.holdingRatio = 0;

        /**
         * ShareHoldingChange changeQty.
         * @member {number} changeQty
         * @memberof Qot_Common.ShareHoldingChange
         * @instance
         */
        ShareHoldingChange.prototype.changeQty = 0;

        /**
         * ShareHoldingChange changeRatio.
         * @member {number} changeRatio
         * @memberof Qot_Common.ShareHoldingChange
         * @instance
         */
        ShareHoldingChange.prototype.changeRatio = 0;

        /**
         * ShareHoldingChange time.
         * @member {string} time
         * @memberof Qot_Common.ShareHoldingChange
         * @instance
         */
        ShareHoldingChange.prototype.time = "";

        /**
         * ShareHoldingChange timestamp.
         * @member {number} timestamp
         * @memberof Qot_Common.ShareHoldingChange
         * @instance
         */
        ShareHoldingChange.prototype.timestamp = 0;

        /**
         * Creates a new ShareHoldingChange instance using the specified properties.
         * @function create
         * @memberof Qot_Common.ShareHoldingChange
         * @static
         * @param {Qot_Common.IShareHoldingChange=} [properties] Properties to set
         * @returns {Qot_Common.ShareHoldingChange} ShareHoldingChange instance
         */
        ShareHoldingChange.create = function create(properties) {
            return new ShareHoldingChange(properties);
        };

        /**
         * Encodes the specified ShareHoldingChange message. Does not implicitly {@link Qot_Common.ShareHoldingChange.verify|verify} messages.
         * @function encode
         * @memberof Qot_Common.ShareHoldingChange
         * @static
         * @param {Qot_Common.IShareHoldingChange} message ShareHoldingChange message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ShareHoldingChange.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.holderName);
            writer.uint32(/* id 2, wireType 1 =*/17).double(message.holdingQty);
            writer.uint32(/* id 3, wireType 1 =*/25).double(message.holdingRatio);
            writer.uint32(/* id 4, wireType 1 =*/33).double(message.changeQty);
            writer.uint32(/* id 5, wireType 1 =*/41).double(message.changeRatio);
            writer.uint32(/* id 6, wireType 2 =*/50).string(message.time);
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                writer.uint32(/* id 7, wireType 1 =*/57).double(message.timestamp);
            return writer;
        };

        /**
         * Encodes the specified ShareHoldingChange message, length delimited. Does not implicitly {@link Qot_Common.ShareHoldingChange.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_Common.ShareHoldingChange
         * @static
         * @param {Qot_Common.IShareHoldingChange} message ShareHoldingChange message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ShareHoldingChange.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ShareHoldingChange message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_Common.ShareHoldingChange
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_Common.ShareHoldingChange} ShareHoldingChange
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShareHoldingChange.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_Common.ShareHoldingChange();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.holderName = reader.string();
                    break;
                case 2:
                    message.holdingQty = reader.double();
                    break;
                case 3:
                    message.holdingRatio = reader.double();
                    break;
                case 4:
                    message.changeQty = reader.double();
                    break;
                case 5:
                    message.changeRatio = reader.double();
                    break;
                case 6:
                    message.time = reader.string();
                    break;
                case 7:
                    message.timestamp = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("holderName"))
                throw $util.ProtocolError("missing required 'holderName'", { instance: message });
            if (!message.hasOwnProperty("holdingQty"))
                throw $util.ProtocolError("missing required 'holdingQty'", { instance: message });
            if (!message.hasOwnProperty("holdingRatio"))
                throw $util.ProtocolError("missing required 'holdingRatio'", { instance: message });
            if (!message.hasOwnProperty("changeQty"))
                throw $util.ProtocolError("missing required 'changeQty'", { instance: message });
            if (!message.hasOwnProperty("changeRatio"))
                throw $util.ProtocolError("missing required 'changeRatio'", { instance: message });
            if (!message.hasOwnProperty("time"))
                throw $util.ProtocolError("missing required 'time'", { instance: message });
            return message;
        };

        /**
         * Decodes a ShareHoldingChange message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_Common.ShareHoldingChange
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_Common.ShareHoldingChange} ShareHoldingChange
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShareHoldingChange.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ShareHoldingChange message.
         * @function verify
         * @memberof Qot_Common.ShareHoldingChange
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ShareHoldingChange.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.holderName))
                return "holderName: string expected";
            if (typeof message.holdingQty !== "number")
                return "holdingQty: number expected";
            if (typeof message.holdingRatio !== "number")
                return "holdingRatio: number expected";
            if (typeof message.changeQty !== "number")
                return "changeQty: number expected";
            if (typeof message.changeRatio !== "number")
                return "changeRatio: number expected";
            if (!$util.isString(message.time))
                return "time: string expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp !== "number")
                    return "timestamp: number expected";
            return null;
        };

        /**
         * Creates a ShareHoldingChange message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_Common.ShareHoldingChange
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_Common.ShareHoldingChange} ShareHoldingChange
         */
        ShareHoldingChange.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_Common.ShareHoldingChange)
                return object;
            var message = new $root.Qot_Common.ShareHoldingChange();
            if (object.holderName != null)
                message.holderName = String(object.holderName);
            if (object.holdingQty != null)
                message.holdingQty = Number(object.holdingQty);
            if (object.holdingRatio != null)
                message.holdingRatio = Number(object.holdingRatio);
            if (object.changeQty != null)
                message.changeQty = Number(object.changeQty);
            if (object.changeRatio != null)
                message.changeRatio = Number(object.changeRatio);
            if (object.time != null)
                message.time = String(object.time);
            if (object.timestamp != null)
                message.timestamp = Number(object.timestamp);
            return message;
        };

        /**
         * Creates a plain object from a ShareHoldingChange message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_Common.ShareHoldingChange
         * @static
         * @param {Qot_Common.ShareHoldingChange} message ShareHoldingChange
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ShareHoldingChange.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.holderName = "";
                object.holdingQty = 0;
                object.holdingRatio = 0;
                object.changeQty = 0;
                object.changeRatio = 0;
                object.time = "";
                object.timestamp = 0;
            }
            if (message.holderName != null && message.hasOwnProperty("holderName"))
                object.holderName = message.holderName;
            if (message.holdingQty != null && message.hasOwnProperty("holdingQty"))
                object.holdingQty = options.json && !isFinite(message.holdingQty) ? String(message.holdingQty) : message.holdingQty;
            if (message.holdingRatio != null && message.hasOwnProperty("holdingRatio"))
                object.holdingRatio = options.json && !isFinite(message.holdingRatio) ? String(message.holdingRatio) : message.holdingRatio;
            if (message.changeQty != null && message.hasOwnProperty("changeQty"))
                object.changeQty = options.json && !isFinite(message.changeQty) ? String(message.changeQty) : message.changeQty;
            if (message.changeRatio != null && message.hasOwnProperty("changeRatio"))
                object.changeRatio = options.json && !isFinite(message.changeRatio) ? String(message.changeRatio) : message.changeRatio;
            if (message.time != null && message.hasOwnProperty("time"))
                object.time = message.time;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                object.timestamp = options.json && !isFinite(message.timestamp) ? String(message.timestamp) : message.timestamp;
            return object;
        };

        /**
         * Converts this ShareHoldingChange to JSON.
         * @function toJSON
         * @memberof Qot_Common.ShareHoldingChange
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ShareHoldingChange.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ShareHoldingChange;
    })();

    Qot_Common.SubInfo = (function() {

        /**
         * Properties of a SubInfo.
         * @memberof Qot_Common
         * @interface ISubInfo
         * @property {number} subType SubInfo subType
         * @property {Array.<Qot_Common.ISecurity>|null} [securityList] SubInfo securityList
         */

        /**
         * Constructs a new SubInfo.
         * @memberof Qot_Common
         * @classdesc Represents a SubInfo.
         * @implements ISubInfo
         * @constructor
         * @param {Qot_Common.ISubInfo=} [properties] Properties to set
         */
        function SubInfo(properties) {
            this.securityList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SubInfo subType.
         * @member {number} subType
         * @memberof Qot_Common.SubInfo
         * @instance
         */
        SubInfo.prototype.subType = 0;

        /**
         * SubInfo securityList.
         * @member {Array.<Qot_Common.ISecurity>} securityList
         * @memberof Qot_Common.SubInfo
         * @instance
         */
        SubInfo.prototype.securityList = $util.emptyArray;

        /**
         * Creates a new SubInfo instance using the specified properties.
         * @function create
         * @memberof Qot_Common.SubInfo
         * @static
         * @param {Qot_Common.ISubInfo=} [properties] Properties to set
         * @returns {Qot_Common.SubInfo} SubInfo instance
         */
        SubInfo.create = function create(properties) {
            return new SubInfo(properties);
        };

        /**
         * Encodes the specified SubInfo message. Does not implicitly {@link Qot_Common.SubInfo.verify|verify} messages.
         * @function encode
         * @memberof Qot_Common.SubInfo
         * @static
         * @param {Qot_Common.ISubInfo} message SubInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.subType);
            if (message.securityList != null && message.securityList.length)
                for (var i = 0; i < message.securityList.length; ++i)
                    $root.Qot_Common.Security.encode(message.securityList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SubInfo message, length delimited. Does not implicitly {@link Qot_Common.SubInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_Common.SubInfo
         * @static
         * @param {Qot_Common.ISubInfo} message SubInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SubInfo message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_Common.SubInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_Common.SubInfo} SubInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_Common.SubInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.subType = reader.int32();
                    break;
                case 2:
                    if (!(message.securityList && message.securityList.length))
                        message.securityList = [];
                    message.securityList.push($root.Qot_Common.Security.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("subType"))
                throw $util.ProtocolError("missing required 'subType'", { instance: message });
            return message;
        };

        /**
         * Decodes a SubInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_Common.SubInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_Common.SubInfo} SubInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SubInfo message.
         * @function verify
         * @memberof Qot_Common.SubInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SubInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.subType))
                return "subType: integer expected";
            if (message.securityList != null && message.hasOwnProperty("securityList")) {
                if (!Array.isArray(message.securityList))
                    return "securityList: array expected";
                for (var i = 0; i < message.securityList.length; ++i) {
                    var error = $root.Qot_Common.Security.verify(message.securityList[i]);
                    if (error)
                        return "securityList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a SubInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_Common.SubInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_Common.SubInfo} SubInfo
         */
        SubInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_Common.SubInfo)
                return object;
            var message = new $root.Qot_Common.SubInfo();
            if (object.subType != null)
                message.subType = object.subType | 0;
            if (object.securityList) {
                if (!Array.isArray(object.securityList))
                    throw TypeError(".Qot_Common.SubInfo.securityList: array expected");
                message.securityList = [];
                for (var i = 0; i < object.securityList.length; ++i) {
                    if (typeof object.securityList[i] !== "object")
                        throw TypeError(".Qot_Common.SubInfo.securityList: object expected");
                    message.securityList[i] = $root.Qot_Common.Security.fromObject(object.securityList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a SubInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_Common.SubInfo
         * @static
         * @param {Qot_Common.SubInfo} message SubInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SubInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.securityList = [];
            if (options.defaults)
                object.subType = 0;
            if (message.subType != null && message.hasOwnProperty("subType"))
                object.subType = message.subType;
            if (message.securityList && message.securityList.length) {
                object.securityList = [];
                for (var j = 0; j < message.securityList.length; ++j)
                    object.securityList[j] = $root.Qot_Common.Security.toObject(message.securityList[j], options);
            }
            return object;
        };

        /**
         * Converts this SubInfo to JSON.
         * @function toJSON
         * @memberof Qot_Common.SubInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SubInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SubInfo;
    })();

    Qot_Common.ConnSubInfo = (function() {

        /**
         * Properties of a ConnSubInfo.
         * @memberof Qot_Common
         * @interface IConnSubInfo
         * @property {Array.<Qot_Common.ISubInfo>|null} [subInfoList] ConnSubInfo subInfoList
         * @property {number} usedQuota ConnSubInfo usedQuota
         * @property {boolean} isOwnConnData ConnSubInfo isOwnConnData
         */

        /**
         * Constructs a new ConnSubInfo.
         * @memberof Qot_Common
         * @classdesc Represents a ConnSubInfo.
         * @implements IConnSubInfo
         * @constructor
         * @param {Qot_Common.IConnSubInfo=} [properties] Properties to set
         */
        function ConnSubInfo(properties) {
            this.subInfoList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ConnSubInfo subInfoList.
         * @member {Array.<Qot_Common.ISubInfo>} subInfoList
         * @memberof Qot_Common.ConnSubInfo
         * @instance
         */
        ConnSubInfo.prototype.subInfoList = $util.emptyArray;

        /**
         * ConnSubInfo usedQuota.
         * @member {number} usedQuota
         * @memberof Qot_Common.ConnSubInfo
         * @instance
         */
        ConnSubInfo.prototype.usedQuota = 0;

        /**
         * ConnSubInfo isOwnConnData.
         * @member {boolean} isOwnConnData
         * @memberof Qot_Common.ConnSubInfo
         * @instance
         */
        ConnSubInfo.prototype.isOwnConnData = false;

        /**
         * Creates a new ConnSubInfo instance using the specified properties.
         * @function create
         * @memberof Qot_Common.ConnSubInfo
         * @static
         * @param {Qot_Common.IConnSubInfo=} [properties] Properties to set
         * @returns {Qot_Common.ConnSubInfo} ConnSubInfo instance
         */
        ConnSubInfo.create = function create(properties) {
            return new ConnSubInfo(properties);
        };

        /**
         * Encodes the specified ConnSubInfo message. Does not implicitly {@link Qot_Common.ConnSubInfo.verify|verify} messages.
         * @function encode
         * @memberof Qot_Common.ConnSubInfo
         * @static
         * @param {Qot_Common.IConnSubInfo} message ConnSubInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConnSubInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.subInfoList != null && message.subInfoList.length)
                for (var i = 0; i < message.subInfoList.length; ++i)
                    $root.Qot_Common.SubInfo.encode(message.subInfoList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.usedQuota);
            writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isOwnConnData);
            return writer;
        };

        /**
         * Encodes the specified ConnSubInfo message, length delimited. Does not implicitly {@link Qot_Common.ConnSubInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_Common.ConnSubInfo
         * @static
         * @param {Qot_Common.IConnSubInfo} message ConnSubInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConnSubInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ConnSubInfo message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_Common.ConnSubInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_Common.ConnSubInfo} ConnSubInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConnSubInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_Common.ConnSubInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.subInfoList && message.subInfoList.length))
                        message.subInfoList = [];
                    message.subInfoList.push($root.Qot_Common.SubInfo.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.usedQuota = reader.int32();
                    break;
                case 3:
                    message.isOwnConnData = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("usedQuota"))
                throw $util.ProtocolError("missing required 'usedQuota'", { instance: message });
            if (!message.hasOwnProperty("isOwnConnData"))
                throw $util.ProtocolError("missing required 'isOwnConnData'", { instance: message });
            return message;
        };

        /**
         * Decodes a ConnSubInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_Common.ConnSubInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_Common.ConnSubInfo} ConnSubInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConnSubInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ConnSubInfo message.
         * @function verify
         * @memberof Qot_Common.ConnSubInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ConnSubInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.subInfoList != null && message.hasOwnProperty("subInfoList")) {
                if (!Array.isArray(message.subInfoList))
                    return "subInfoList: array expected";
                for (var i = 0; i < message.subInfoList.length; ++i) {
                    var error = $root.Qot_Common.SubInfo.verify(message.subInfoList[i]);
                    if (error)
                        return "subInfoList." + error;
                }
            }
            if (!$util.isInteger(message.usedQuota))
                return "usedQuota: integer expected";
            if (typeof message.isOwnConnData !== "boolean")
                return "isOwnConnData: boolean expected";
            return null;
        };

        /**
         * Creates a ConnSubInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_Common.ConnSubInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_Common.ConnSubInfo} ConnSubInfo
         */
        ConnSubInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_Common.ConnSubInfo)
                return object;
            var message = new $root.Qot_Common.ConnSubInfo();
            if (object.subInfoList) {
                if (!Array.isArray(object.subInfoList))
                    throw TypeError(".Qot_Common.ConnSubInfo.subInfoList: array expected");
                message.subInfoList = [];
                for (var i = 0; i < object.subInfoList.length; ++i) {
                    if (typeof object.subInfoList[i] !== "object")
                        throw TypeError(".Qot_Common.ConnSubInfo.subInfoList: object expected");
                    message.subInfoList[i] = $root.Qot_Common.SubInfo.fromObject(object.subInfoList[i]);
                }
            }
            if (object.usedQuota != null)
                message.usedQuota = object.usedQuota | 0;
            if (object.isOwnConnData != null)
                message.isOwnConnData = Boolean(object.isOwnConnData);
            return message;
        };

        /**
         * Creates a plain object from a ConnSubInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_Common.ConnSubInfo
         * @static
         * @param {Qot_Common.ConnSubInfo} message ConnSubInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ConnSubInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.subInfoList = [];
            if (options.defaults) {
                object.usedQuota = 0;
                object.isOwnConnData = false;
            }
            if (message.subInfoList && message.subInfoList.length) {
                object.subInfoList = [];
                for (var j = 0; j < message.subInfoList.length; ++j)
                    object.subInfoList[j] = $root.Qot_Common.SubInfo.toObject(message.subInfoList[j], options);
            }
            if (message.usedQuota != null && message.hasOwnProperty("usedQuota"))
                object.usedQuota = message.usedQuota;
            if (message.isOwnConnData != null && message.hasOwnProperty("isOwnConnData"))
                object.isOwnConnData = message.isOwnConnData;
            return object;
        };

        /**
         * Converts this ConnSubInfo to JSON.
         * @function toJSON
         * @memberof Qot_Common.ConnSubInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ConnSubInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ConnSubInfo;
    })();

    Qot_Common.PlateInfo = (function() {

        /**
         * Properties of a PlateInfo.
         * @memberof Qot_Common
         * @interface IPlateInfo
         * @property {Qot_Common.ISecurity} plate PlateInfo plate
         * @property {string} name PlateInfo name
         * @property {number|null} [plateType] PlateInfo plateType
         */

        /**
         * Constructs a new PlateInfo.
         * @memberof Qot_Common
         * @classdesc Represents a PlateInfo.
         * @implements IPlateInfo
         * @constructor
         * @param {Qot_Common.IPlateInfo=} [properties] Properties to set
         */
        function PlateInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PlateInfo plate.
         * @member {Qot_Common.ISecurity} plate
         * @memberof Qot_Common.PlateInfo
         * @instance
         */
        PlateInfo.prototype.plate = null;

        /**
         * PlateInfo name.
         * @member {string} name
         * @memberof Qot_Common.PlateInfo
         * @instance
         */
        PlateInfo.prototype.name = "";

        /**
         * PlateInfo plateType.
         * @member {number} plateType
         * @memberof Qot_Common.PlateInfo
         * @instance
         */
        PlateInfo.prototype.plateType = 0;

        /**
         * Creates a new PlateInfo instance using the specified properties.
         * @function create
         * @memberof Qot_Common.PlateInfo
         * @static
         * @param {Qot_Common.IPlateInfo=} [properties] Properties to set
         * @returns {Qot_Common.PlateInfo} PlateInfo instance
         */
        PlateInfo.create = function create(properties) {
            return new PlateInfo(properties);
        };

        /**
         * Encodes the specified PlateInfo message. Does not implicitly {@link Qot_Common.PlateInfo.verify|verify} messages.
         * @function encode
         * @memberof Qot_Common.PlateInfo
         * @static
         * @param {Qot_Common.IPlateInfo} message PlateInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlateInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.plate, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.plateType != null && message.hasOwnProperty("plateType"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.plateType);
            return writer;
        };

        /**
         * Encodes the specified PlateInfo message, length delimited. Does not implicitly {@link Qot_Common.PlateInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_Common.PlateInfo
         * @static
         * @param {Qot_Common.IPlateInfo} message PlateInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlateInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PlateInfo message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_Common.PlateInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_Common.PlateInfo} PlateInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlateInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_Common.PlateInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.plate = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.plateType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("plate"))
                throw $util.ProtocolError("missing required 'plate'", { instance: message });
            if (!message.hasOwnProperty("name"))
                throw $util.ProtocolError("missing required 'name'", { instance: message });
            return message;
        };

        /**
         * Decodes a PlateInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_Common.PlateInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_Common.PlateInfo} PlateInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlateInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PlateInfo message.
         * @function verify
         * @memberof Qot_Common.PlateInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PlateInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.plate);
                if (error)
                    return "plate." + error;
            }
            if (!$util.isString(message.name))
                return "name: string expected";
            if (message.plateType != null && message.hasOwnProperty("plateType"))
                if (!$util.isInteger(message.plateType))
                    return "plateType: integer expected";
            return null;
        };

        /**
         * Creates a PlateInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_Common.PlateInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_Common.PlateInfo} PlateInfo
         */
        PlateInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_Common.PlateInfo)
                return object;
            var message = new $root.Qot_Common.PlateInfo();
            if (object.plate != null) {
                if (typeof object.plate !== "object")
                    throw TypeError(".Qot_Common.PlateInfo.plate: object expected");
                message.plate = $root.Qot_Common.Security.fromObject(object.plate);
            }
            if (object.name != null)
                message.name = String(object.name);
            if (object.plateType != null)
                message.plateType = object.plateType | 0;
            return message;
        };

        /**
         * Creates a plain object from a PlateInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_Common.PlateInfo
         * @static
         * @param {Qot_Common.PlateInfo} message PlateInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PlateInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.plate = null;
                object.name = "";
                object.plateType = 0;
            }
            if (message.plate != null && message.hasOwnProperty("plate"))
                object.plate = $root.Qot_Common.Security.toObject(message.plate, options);
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.plateType != null && message.hasOwnProperty("plateType"))
                object.plateType = message.plateType;
            return object;
        };

        /**
         * Converts this PlateInfo to JSON.
         * @function toJSON
         * @memberof Qot_Common.PlateInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PlateInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PlateInfo;
    })();

    Qot_Common.Rehab = (function() {

        /**
         * Properties of a Rehab.
         * @memberof Qot_Common
         * @interface IRehab
         * @property {string} time Rehab time
         * @property {number|Long} companyActFlag Rehab companyActFlag
         * @property {number} fwdFactorA Rehab fwdFactorA
         * @property {number} fwdFactorB Rehab fwdFactorB
         * @property {number} bwdFactorA Rehab bwdFactorA
         * @property {number} bwdFactorB Rehab bwdFactorB
         * @property {number|null} [splitBase] Rehab splitBase
         * @property {number|null} [splitErt] Rehab splitErt
         * @property {number|null} [joinBase] Rehab joinBase
         * @property {number|null} [joinErt] Rehab joinErt
         * @property {number|null} [bonusBase] Rehab bonusBase
         * @property {number|null} [bonusErt] Rehab bonusErt
         * @property {number|null} [transferBase] Rehab transferBase
         * @property {number|null} [transferErt] Rehab transferErt
         * @property {number|null} [allotBase] Rehab allotBase
         * @property {number|null} [allotErt] Rehab allotErt
         * @property {number|null} [allotPrice] Rehab allotPrice
         * @property {number|null} [addBase] Rehab addBase
         * @property {number|null} [addErt] Rehab addErt
         * @property {number|null} [addPrice] Rehab addPrice
         * @property {number|null} [dividend] Rehab dividend
         * @property {number|null} [spDividend] Rehab spDividend
         * @property {number|null} [timestamp] Rehab timestamp
         */

        /**
         * Constructs a new Rehab.
         * @memberof Qot_Common
         * @classdesc Represents a Rehab.
         * @implements IRehab
         * @constructor
         * @param {Qot_Common.IRehab=} [properties] Properties to set
         */
        function Rehab(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Rehab time.
         * @member {string} time
         * @memberof Qot_Common.Rehab
         * @instance
         */
        Rehab.prototype.time = "";

        /**
         * Rehab companyActFlag.
         * @member {number|Long} companyActFlag
         * @memberof Qot_Common.Rehab
         * @instance
         */
        Rehab.prototype.companyActFlag = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Rehab fwdFactorA.
         * @member {number} fwdFactorA
         * @memberof Qot_Common.Rehab
         * @instance
         */
        Rehab.prototype.fwdFactorA = 0;

        /**
         * Rehab fwdFactorB.
         * @member {number} fwdFactorB
         * @memberof Qot_Common.Rehab
         * @instance
         */
        Rehab.prototype.fwdFactorB = 0;

        /**
         * Rehab bwdFactorA.
         * @member {number} bwdFactorA
         * @memberof Qot_Common.Rehab
         * @instance
         */
        Rehab.prototype.bwdFactorA = 0;

        /**
         * Rehab bwdFactorB.
         * @member {number} bwdFactorB
         * @memberof Qot_Common.Rehab
         * @instance
         */
        Rehab.prototype.bwdFactorB = 0;

        /**
         * Rehab splitBase.
         * @member {number} splitBase
         * @memberof Qot_Common.Rehab
         * @instance
         */
        Rehab.prototype.splitBase = 0;

        /**
         * Rehab splitErt.
         * @member {number} splitErt
         * @memberof Qot_Common.Rehab
         * @instance
         */
        Rehab.prototype.splitErt = 0;

        /**
         * Rehab joinBase.
         * @member {number} joinBase
         * @memberof Qot_Common.Rehab
         * @instance
         */
        Rehab.prototype.joinBase = 0;

        /**
         * Rehab joinErt.
         * @member {number} joinErt
         * @memberof Qot_Common.Rehab
         * @instance
         */
        Rehab.prototype.joinErt = 0;

        /**
         * Rehab bonusBase.
         * @member {number} bonusBase
         * @memberof Qot_Common.Rehab
         * @instance
         */
        Rehab.prototype.bonusBase = 0;

        /**
         * Rehab bonusErt.
         * @member {number} bonusErt
         * @memberof Qot_Common.Rehab
         * @instance
         */
        Rehab.prototype.bonusErt = 0;

        /**
         * Rehab transferBase.
         * @member {number} transferBase
         * @memberof Qot_Common.Rehab
         * @instance
         */
        Rehab.prototype.transferBase = 0;

        /**
         * Rehab transferErt.
         * @member {number} transferErt
         * @memberof Qot_Common.Rehab
         * @instance
         */
        Rehab.prototype.transferErt = 0;

        /**
         * Rehab allotBase.
         * @member {number} allotBase
         * @memberof Qot_Common.Rehab
         * @instance
         */
        Rehab.prototype.allotBase = 0;

        /**
         * Rehab allotErt.
         * @member {number} allotErt
         * @memberof Qot_Common.Rehab
         * @instance
         */
        Rehab.prototype.allotErt = 0;

        /**
         * Rehab allotPrice.
         * @member {number} allotPrice
         * @memberof Qot_Common.Rehab
         * @instance
         */
        Rehab.prototype.allotPrice = 0;

        /**
         * Rehab addBase.
         * @member {number} addBase
         * @memberof Qot_Common.Rehab
         * @instance
         */
        Rehab.prototype.addBase = 0;

        /**
         * Rehab addErt.
         * @member {number} addErt
         * @memberof Qot_Common.Rehab
         * @instance
         */
        Rehab.prototype.addErt = 0;

        /**
         * Rehab addPrice.
         * @member {number} addPrice
         * @memberof Qot_Common.Rehab
         * @instance
         */
        Rehab.prototype.addPrice = 0;

        /**
         * Rehab dividend.
         * @member {number} dividend
         * @memberof Qot_Common.Rehab
         * @instance
         */
        Rehab.prototype.dividend = 0;

        /**
         * Rehab spDividend.
         * @member {number} spDividend
         * @memberof Qot_Common.Rehab
         * @instance
         */
        Rehab.prototype.spDividend = 0;

        /**
         * Rehab timestamp.
         * @member {number} timestamp
         * @memberof Qot_Common.Rehab
         * @instance
         */
        Rehab.prototype.timestamp = 0;

        /**
         * Creates a new Rehab instance using the specified properties.
         * @function create
         * @memberof Qot_Common.Rehab
         * @static
         * @param {Qot_Common.IRehab=} [properties] Properties to set
         * @returns {Qot_Common.Rehab} Rehab instance
         */
        Rehab.create = function create(properties) {
            return new Rehab(properties);
        };

        /**
         * Encodes the specified Rehab message. Does not implicitly {@link Qot_Common.Rehab.verify|verify} messages.
         * @function encode
         * @memberof Qot_Common.Rehab
         * @static
         * @param {Qot_Common.IRehab} message Rehab message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Rehab.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.time);
            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.companyActFlag);
            writer.uint32(/* id 3, wireType 1 =*/25).double(message.fwdFactorA);
            writer.uint32(/* id 4, wireType 1 =*/33).double(message.fwdFactorB);
            writer.uint32(/* id 5, wireType 1 =*/41).double(message.bwdFactorA);
            writer.uint32(/* id 6, wireType 1 =*/49).double(message.bwdFactorB);
            if (message.splitBase != null && message.hasOwnProperty("splitBase"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.splitBase);
            if (message.splitErt != null && message.hasOwnProperty("splitErt"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.splitErt);
            if (message.joinBase != null && message.hasOwnProperty("joinBase"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.joinBase);
            if (message.joinErt != null && message.hasOwnProperty("joinErt"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.joinErt);
            if (message.bonusBase != null && message.hasOwnProperty("bonusBase"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.bonusBase);
            if (message.bonusErt != null && message.hasOwnProperty("bonusErt"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.bonusErt);
            if (message.transferBase != null && message.hasOwnProperty("transferBase"))
                writer.uint32(/* id 13, wireType 0 =*/104).int32(message.transferBase);
            if (message.transferErt != null && message.hasOwnProperty("transferErt"))
                writer.uint32(/* id 14, wireType 0 =*/112).int32(message.transferErt);
            if (message.allotBase != null && message.hasOwnProperty("allotBase"))
                writer.uint32(/* id 15, wireType 0 =*/120).int32(message.allotBase);
            if (message.allotErt != null && message.hasOwnProperty("allotErt"))
                writer.uint32(/* id 16, wireType 0 =*/128).int32(message.allotErt);
            if (message.allotPrice != null && message.hasOwnProperty("allotPrice"))
                writer.uint32(/* id 17, wireType 1 =*/137).double(message.allotPrice);
            if (message.addBase != null && message.hasOwnProperty("addBase"))
                writer.uint32(/* id 18, wireType 0 =*/144).int32(message.addBase);
            if (message.addErt != null && message.hasOwnProperty("addErt"))
                writer.uint32(/* id 19, wireType 0 =*/152).int32(message.addErt);
            if (message.addPrice != null && message.hasOwnProperty("addPrice"))
                writer.uint32(/* id 20, wireType 1 =*/161).double(message.addPrice);
            if (message.dividend != null && message.hasOwnProperty("dividend"))
                writer.uint32(/* id 21, wireType 1 =*/169).double(message.dividend);
            if (message.spDividend != null && message.hasOwnProperty("spDividend"))
                writer.uint32(/* id 22, wireType 1 =*/177).double(message.spDividend);
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                writer.uint32(/* id 23, wireType 1 =*/185).double(message.timestamp);
            return writer;
        };

        /**
         * Encodes the specified Rehab message, length delimited. Does not implicitly {@link Qot_Common.Rehab.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_Common.Rehab
         * @static
         * @param {Qot_Common.IRehab} message Rehab message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Rehab.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Rehab message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_Common.Rehab
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_Common.Rehab} Rehab
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Rehab.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_Common.Rehab();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.time = reader.string();
                    break;
                case 2:
                    message.companyActFlag = reader.int64();
                    break;
                case 3:
                    message.fwdFactorA = reader.double();
                    break;
                case 4:
                    message.fwdFactorB = reader.double();
                    break;
                case 5:
                    message.bwdFactorA = reader.double();
                    break;
                case 6:
                    message.bwdFactorB = reader.double();
                    break;
                case 7:
                    message.splitBase = reader.int32();
                    break;
                case 8:
                    message.splitErt = reader.int32();
                    break;
                case 9:
                    message.joinBase = reader.int32();
                    break;
                case 10:
                    message.joinErt = reader.int32();
                    break;
                case 11:
                    message.bonusBase = reader.int32();
                    break;
                case 12:
                    message.bonusErt = reader.int32();
                    break;
                case 13:
                    message.transferBase = reader.int32();
                    break;
                case 14:
                    message.transferErt = reader.int32();
                    break;
                case 15:
                    message.allotBase = reader.int32();
                    break;
                case 16:
                    message.allotErt = reader.int32();
                    break;
                case 17:
                    message.allotPrice = reader.double();
                    break;
                case 18:
                    message.addBase = reader.int32();
                    break;
                case 19:
                    message.addErt = reader.int32();
                    break;
                case 20:
                    message.addPrice = reader.double();
                    break;
                case 21:
                    message.dividend = reader.double();
                    break;
                case 22:
                    message.spDividend = reader.double();
                    break;
                case 23:
                    message.timestamp = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("time"))
                throw $util.ProtocolError("missing required 'time'", { instance: message });
            if (!message.hasOwnProperty("companyActFlag"))
                throw $util.ProtocolError("missing required 'companyActFlag'", { instance: message });
            if (!message.hasOwnProperty("fwdFactorA"))
                throw $util.ProtocolError("missing required 'fwdFactorA'", { instance: message });
            if (!message.hasOwnProperty("fwdFactorB"))
                throw $util.ProtocolError("missing required 'fwdFactorB'", { instance: message });
            if (!message.hasOwnProperty("bwdFactorA"))
                throw $util.ProtocolError("missing required 'bwdFactorA'", { instance: message });
            if (!message.hasOwnProperty("bwdFactorB"))
                throw $util.ProtocolError("missing required 'bwdFactorB'", { instance: message });
            return message;
        };

        /**
         * Decodes a Rehab message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_Common.Rehab
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_Common.Rehab} Rehab
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Rehab.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Rehab message.
         * @function verify
         * @memberof Qot_Common.Rehab
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Rehab.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.time))
                return "time: string expected";
            if (!$util.isInteger(message.companyActFlag) && !(message.companyActFlag && $util.isInteger(message.companyActFlag.low) && $util.isInteger(message.companyActFlag.high)))
                return "companyActFlag: integer|Long expected";
            if (typeof message.fwdFactorA !== "number")
                return "fwdFactorA: number expected";
            if (typeof message.fwdFactorB !== "number")
                return "fwdFactorB: number expected";
            if (typeof message.bwdFactorA !== "number")
                return "bwdFactorA: number expected";
            if (typeof message.bwdFactorB !== "number")
                return "bwdFactorB: number expected";
            if (message.splitBase != null && message.hasOwnProperty("splitBase"))
                if (!$util.isInteger(message.splitBase))
                    return "splitBase: integer expected";
            if (message.splitErt != null && message.hasOwnProperty("splitErt"))
                if (!$util.isInteger(message.splitErt))
                    return "splitErt: integer expected";
            if (message.joinBase != null && message.hasOwnProperty("joinBase"))
                if (!$util.isInteger(message.joinBase))
                    return "joinBase: integer expected";
            if (message.joinErt != null && message.hasOwnProperty("joinErt"))
                if (!$util.isInteger(message.joinErt))
                    return "joinErt: integer expected";
            if (message.bonusBase != null && message.hasOwnProperty("bonusBase"))
                if (!$util.isInteger(message.bonusBase))
                    return "bonusBase: integer expected";
            if (message.bonusErt != null && message.hasOwnProperty("bonusErt"))
                if (!$util.isInteger(message.bonusErt))
                    return "bonusErt: integer expected";
            if (message.transferBase != null && message.hasOwnProperty("transferBase"))
                if (!$util.isInteger(message.transferBase))
                    return "transferBase: integer expected";
            if (message.transferErt != null && message.hasOwnProperty("transferErt"))
                if (!$util.isInteger(message.transferErt))
                    return "transferErt: integer expected";
            if (message.allotBase != null && message.hasOwnProperty("allotBase"))
                if (!$util.isInteger(message.allotBase))
                    return "allotBase: integer expected";
            if (message.allotErt != null && message.hasOwnProperty("allotErt"))
                if (!$util.isInteger(message.allotErt))
                    return "allotErt: integer expected";
            if (message.allotPrice != null && message.hasOwnProperty("allotPrice"))
                if (typeof message.allotPrice !== "number")
                    return "allotPrice: number expected";
            if (message.addBase != null && message.hasOwnProperty("addBase"))
                if (!$util.isInteger(message.addBase))
                    return "addBase: integer expected";
            if (message.addErt != null && message.hasOwnProperty("addErt"))
                if (!$util.isInteger(message.addErt))
                    return "addErt: integer expected";
            if (message.addPrice != null && message.hasOwnProperty("addPrice"))
                if (typeof message.addPrice !== "number")
                    return "addPrice: number expected";
            if (message.dividend != null && message.hasOwnProperty("dividend"))
                if (typeof message.dividend !== "number")
                    return "dividend: number expected";
            if (message.spDividend != null && message.hasOwnProperty("spDividend"))
                if (typeof message.spDividend !== "number")
                    return "spDividend: number expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp !== "number")
                    return "timestamp: number expected";
            return null;
        };

        /**
         * Creates a Rehab message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_Common.Rehab
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_Common.Rehab} Rehab
         */
        Rehab.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_Common.Rehab)
                return object;
            var message = new $root.Qot_Common.Rehab();
            if (object.time != null)
                message.time = String(object.time);
            if (object.companyActFlag != null)
                if ($util.Long)
                    (message.companyActFlag = $util.Long.fromValue(object.companyActFlag)).unsigned = false;
                else if (typeof object.companyActFlag === "string")
                    message.companyActFlag = parseInt(object.companyActFlag, 10);
                else if (typeof object.companyActFlag === "number")
                    message.companyActFlag = object.companyActFlag;
                else if (typeof object.companyActFlag === "object")
                    message.companyActFlag = new $util.LongBits(object.companyActFlag.low >>> 0, object.companyActFlag.high >>> 0).toNumber();
            if (object.fwdFactorA != null)
                message.fwdFactorA = Number(object.fwdFactorA);
            if (object.fwdFactorB != null)
                message.fwdFactorB = Number(object.fwdFactorB);
            if (object.bwdFactorA != null)
                message.bwdFactorA = Number(object.bwdFactorA);
            if (object.bwdFactorB != null)
                message.bwdFactorB = Number(object.bwdFactorB);
            if (object.splitBase != null)
                message.splitBase = object.splitBase | 0;
            if (object.splitErt != null)
                message.splitErt = object.splitErt | 0;
            if (object.joinBase != null)
                message.joinBase = object.joinBase | 0;
            if (object.joinErt != null)
                message.joinErt = object.joinErt | 0;
            if (object.bonusBase != null)
                message.bonusBase = object.bonusBase | 0;
            if (object.bonusErt != null)
                message.bonusErt = object.bonusErt | 0;
            if (object.transferBase != null)
                message.transferBase = object.transferBase | 0;
            if (object.transferErt != null)
                message.transferErt = object.transferErt | 0;
            if (object.allotBase != null)
                message.allotBase = object.allotBase | 0;
            if (object.allotErt != null)
                message.allotErt = object.allotErt | 0;
            if (object.allotPrice != null)
                message.allotPrice = Number(object.allotPrice);
            if (object.addBase != null)
                message.addBase = object.addBase | 0;
            if (object.addErt != null)
                message.addErt = object.addErt | 0;
            if (object.addPrice != null)
                message.addPrice = Number(object.addPrice);
            if (object.dividend != null)
                message.dividend = Number(object.dividend);
            if (object.spDividend != null)
                message.spDividend = Number(object.spDividend);
            if (object.timestamp != null)
                message.timestamp = Number(object.timestamp);
            return message;
        };

        /**
         * Creates a plain object from a Rehab message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_Common.Rehab
         * @static
         * @param {Qot_Common.Rehab} message Rehab
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Rehab.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.time = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.companyActFlag = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.companyActFlag = options.longs === String ? "0" : 0;
                object.fwdFactorA = 0;
                object.fwdFactorB = 0;
                object.bwdFactorA = 0;
                object.bwdFactorB = 0;
                object.splitBase = 0;
                object.splitErt = 0;
                object.joinBase = 0;
                object.joinErt = 0;
                object.bonusBase = 0;
                object.bonusErt = 0;
                object.transferBase = 0;
                object.transferErt = 0;
                object.allotBase = 0;
                object.allotErt = 0;
                object.allotPrice = 0;
                object.addBase = 0;
                object.addErt = 0;
                object.addPrice = 0;
                object.dividend = 0;
                object.spDividend = 0;
                object.timestamp = 0;
            }
            if (message.time != null && message.hasOwnProperty("time"))
                object.time = message.time;
            if (message.companyActFlag != null && message.hasOwnProperty("companyActFlag"))
                if (typeof message.companyActFlag === "number")
                    object.companyActFlag = options.longs === String ? String(message.companyActFlag) : message.companyActFlag;
                else
                    object.companyActFlag = options.longs === String ? $util.Long.prototype.toString.call(message.companyActFlag) : options.longs === Number ? new $util.LongBits(message.companyActFlag.low >>> 0, message.companyActFlag.high >>> 0).toNumber() : message.companyActFlag;
            if (message.fwdFactorA != null && message.hasOwnProperty("fwdFactorA"))
                object.fwdFactorA = options.json && !isFinite(message.fwdFactorA) ? String(message.fwdFactorA) : message.fwdFactorA;
            if (message.fwdFactorB != null && message.hasOwnProperty("fwdFactorB"))
                object.fwdFactorB = options.json && !isFinite(message.fwdFactorB) ? String(message.fwdFactorB) : message.fwdFactorB;
            if (message.bwdFactorA != null && message.hasOwnProperty("bwdFactorA"))
                object.bwdFactorA = options.json && !isFinite(message.bwdFactorA) ? String(message.bwdFactorA) : message.bwdFactorA;
            if (message.bwdFactorB != null && message.hasOwnProperty("bwdFactorB"))
                object.bwdFactorB = options.json && !isFinite(message.bwdFactorB) ? String(message.bwdFactorB) : message.bwdFactorB;
            if (message.splitBase != null && message.hasOwnProperty("splitBase"))
                object.splitBase = message.splitBase;
            if (message.splitErt != null && message.hasOwnProperty("splitErt"))
                object.splitErt = message.splitErt;
            if (message.joinBase != null && message.hasOwnProperty("joinBase"))
                object.joinBase = message.joinBase;
            if (message.joinErt != null && message.hasOwnProperty("joinErt"))
                object.joinErt = message.joinErt;
            if (message.bonusBase != null && message.hasOwnProperty("bonusBase"))
                object.bonusBase = message.bonusBase;
            if (message.bonusErt != null && message.hasOwnProperty("bonusErt"))
                object.bonusErt = message.bonusErt;
            if (message.transferBase != null && message.hasOwnProperty("transferBase"))
                object.transferBase = message.transferBase;
            if (message.transferErt != null && message.hasOwnProperty("transferErt"))
                object.transferErt = message.transferErt;
            if (message.allotBase != null && message.hasOwnProperty("allotBase"))
                object.allotBase = message.allotBase;
            if (message.allotErt != null && message.hasOwnProperty("allotErt"))
                object.allotErt = message.allotErt;
            if (message.allotPrice != null && message.hasOwnProperty("allotPrice"))
                object.allotPrice = options.json && !isFinite(message.allotPrice) ? String(message.allotPrice) : message.allotPrice;
            if (message.addBase != null && message.hasOwnProperty("addBase"))
                object.addBase = message.addBase;
            if (message.addErt != null && message.hasOwnProperty("addErt"))
                object.addErt = message.addErt;
            if (message.addPrice != null && message.hasOwnProperty("addPrice"))
                object.addPrice = options.json && !isFinite(message.addPrice) ? String(message.addPrice) : message.addPrice;
            if (message.dividend != null && message.hasOwnProperty("dividend"))
                object.dividend = options.json && !isFinite(message.dividend) ? String(message.dividend) : message.dividend;
            if (message.spDividend != null && message.hasOwnProperty("spDividend"))
                object.spDividend = options.json && !isFinite(message.spDividend) ? String(message.spDividend) : message.spDividend;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                object.timestamp = options.json && !isFinite(message.timestamp) ? String(message.timestamp) : message.timestamp;
            return object;
        };

        /**
         * Converts this Rehab to JSON.
         * @function toJSON
         * @memberof Qot_Common.Rehab
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Rehab.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Rehab;
    })();

    return Qot_Common;
})();

$root.GetUserInfo = (function() {

    /**
     * Namespace GetUserInfo.
     * @exports GetUserInfo
     * @namespace
     */
    var GetUserInfo = {};

    /**
     * QotRight enum.
     * @name GetUserInfo.QotRight
     * @enum {string}
     * @property {number} QotRight_Unknow=0 QotRight_Unknow value
     * @property {number} QotRight_Bmp=1 QotRight_Bmp value
     * @property {number} QotRight_Level1=2 QotRight_Level1 value
     * @property {number} QotRight_Level2=3 QotRight_Level2 value
     */
    GetUserInfo.QotRight = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "QotRight_Unknow"] = 0;
        values[valuesById[1] = "QotRight_Bmp"] = 1;
        values[valuesById[2] = "QotRight_Level1"] = 2;
        values[valuesById[3] = "QotRight_Level2"] = 3;
        return values;
    })();

    GetUserInfo.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof GetUserInfo
         * @interface IC2S
         * @property {number|Long} userID C2S userID
         */

        /**
         * Constructs a new C2S.
         * @memberof GetUserInfo
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {GetUserInfo.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S userID.
         * @member {number|Long} userID
         * @memberof GetUserInfo.C2S
         * @instance
         */
        C2S.prototype.userID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof GetUserInfo.C2S
         * @static
         * @param {GetUserInfo.IC2S=} [properties] Properties to set
         * @returns {GetUserInfo.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link GetUserInfo.C2S.verify|verify} messages.
         * @function encode
         * @memberof GetUserInfo.C2S
         * @static
         * @param {GetUserInfo.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.userID);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link GetUserInfo.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof GetUserInfo.C2S
         * @static
         * @param {GetUserInfo.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof GetUserInfo.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {GetUserInfo.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetUserInfo.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.userID = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("userID"))
                throw $util.ProtocolError("missing required 'userID'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof GetUserInfo.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {GetUserInfo.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof GetUserInfo.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.userID) && !(message.userID && $util.isInteger(message.userID.low) && $util.isInteger(message.userID.high)))
                return "userID: integer|Long expected";
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof GetUserInfo.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {GetUserInfo.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.GetUserInfo.C2S)
                return object;
            var message = new $root.GetUserInfo.C2S();
            if (object.userID != null)
                if ($util.Long)
                    (message.userID = $util.Long.fromValue(object.userID)).unsigned = true;
                else if (typeof object.userID === "string")
                    message.userID = parseInt(object.userID, 10);
                else if (typeof object.userID === "number")
                    message.userID = object.userID;
                else if (typeof object.userID === "object")
                    message.userID = new $util.LongBits(object.userID.low >>> 0, object.userID.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof GetUserInfo.C2S
         * @static
         * @param {GetUserInfo.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.userID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.userID = options.longs === String ? "0" : 0;
            if (message.userID != null && message.hasOwnProperty("userID"))
                if (typeof message.userID === "number")
                    object.userID = options.longs === String ? String(message.userID) : message.userID;
                else
                    object.userID = options.longs === String ? $util.Long.prototype.toString.call(message.userID) : options.longs === Number ? new $util.LongBits(message.userID.low >>> 0, message.userID.high >>> 0).toNumber(true) : message.userID;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof GetUserInfo.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    GetUserInfo.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof GetUserInfo
         * @interface IS2C
         * @property {string} nickName S2C nickName
         * @property {string} avatarUrl S2C avatarUrl
         * @property {string} apiLevel S2C apiLevel
         * @property {number} hkQotRight S2C hkQotRight
         * @property {number} usQotRight S2C usQotRight
         * @property {number} cnQotRight S2C cnQotRight
         * @property {boolean} isNeedAgreeDisclaimer S2C isNeedAgreeDisclaimer
         * @property {number|Long} userID S2C userID
         */

        /**
         * Constructs a new S2C.
         * @memberof GetUserInfo
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {GetUserInfo.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C nickName.
         * @member {string} nickName
         * @memberof GetUserInfo.S2C
         * @instance
         */
        S2C.prototype.nickName = "";

        /**
         * S2C avatarUrl.
         * @member {string} avatarUrl
         * @memberof GetUserInfo.S2C
         * @instance
         */
        S2C.prototype.avatarUrl = "";

        /**
         * S2C apiLevel.
         * @member {string} apiLevel
         * @memberof GetUserInfo.S2C
         * @instance
         */
        S2C.prototype.apiLevel = "";

        /**
         * S2C hkQotRight.
         * @member {number} hkQotRight
         * @memberof GetUserInfo.S2C
         * @instance
         */
        S2C.prototype.hkQotRight = 0;

        /**
         * S2C usQotRight.
         * @member {number} usQotRight
         * @memberof GetUserInfo.S2C
         * @instance
         */
        S2C.prototype.usQotRight = 0;

        /**
         * S2C cnQotRight.
         * @member {number} cnQotRight
         * @memberof GetUserInfo.S2C
         * @instance
         */
        S2C.prototype.cnQotRight = 0;

        /**
         * S2C isNeedAgreeDisclaimer.
         * @member {boolean} isNeedAgreeDisclaimer
         * @memberof GetUserInfo.S2C
         * @instance
         */
        S2C.prototype.isNeedAgreeDisclaimer = false;

        /**
         * S2C userID.
         * @member {number|Long} userID
         * @memberof GetUserInfo.S2C
         * @instance
         */
        S2C.prototype.userID = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof GetUserInfo.S2C
         * @static
         * @param {GetUserInfo.IS2C=} [properties] Properties to set
         * @returns {GetUserInfo.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link GetUserInfo.S2C.verify|verify} messages.
         * @function encode
         * @memberof GetUserInfo.S2C
         * @static
         * @param {GetUserInfo.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.nickName);
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.avatarUrl);
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.apiLevel);
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.hkQotRight);
            writer.uint32(/* id 5, wireType 0 =*/40).int32(message.usQotRight);
            writer.uint32(/* id 6, wireType 0 =*/48).int32(message.cnQotRight);
            writer.uint32(/* id 7, wireType 0 =*/56).bool(message.isNeedAgreeDisclaimer);
            writer.uint32(/* id 8, wireType 0 =*/64).int64(message.userID);
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link GetUserInfo.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof GetUserInfo.S2C
         * @static
         * @param {GetUserInfo.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof GetUserInfo.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {GetUserInfo.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetUserInfo.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.nickName = reader.string();
                    break;
                case 2:
                    message.avatarUrl = reader.string();
                    break;
                case 3:
                    message.apiLevel = reader.string();
                    break;
                case 4:
                    message.hkQotRight = reader.int32();
                    break;
                case 5:
                    message.usQotRight = reader.int32();
                    break;
                case 6:
                    message.cnQotRight = reader.int32();
                    break;
                case 7:
                    message.isNeedAgreeDisclaimer = reader.bool();
                    break;
                case 8:
                    message.userID = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("nickName"))
                throw $util.ProtocolError("missing required 'nickName'", { instance: message });
            if (!message.hasOwnProperty("avatarUrl"))
                throw $util.ProtocolError("missing required 'avatarUrl'", { instance: message });
            if (!message.hasOwnProperty("apiLevel"))
                throw $util.ProtocolError("missing required 'apiLevel'", { instance: message });
            if (!message.hasOwnProperty("hkQotRight"))
                throw $util.ProtocolError("missing required 'hkQotRight'", { instance: message });
            if (!message.hasOwnProperty("usQotRight"))
                throw $util.ProtocolError("missing required 'usQotRight'", { instance: message });
            if (!message.hasOwnProperty("cnQotRight"))
                throw $util.ProtocolError("missing required 'cnQotRight'", { instance: message });
            if (!message.hasOwnProperty("isNeedAgreeDisclaimer"))
                throw $util.ProtocolError("missing required 'isNeedAgreeDisclaimer'", { instance: message });
            if (!message.hasOwnProperty("userID"))
                throw $util.ProtocolError("missing required 'userID'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof GetUserInfo.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {GetUserInfo.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof GetUserInfo.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.nickName))
                return "nickName: string expected";
            if (!$util.isString(message.avatarUrl))
                return "avatarUrl: string expected";
            if (!$util.isString(message.apiLevel))
                return "apiLevel: string expected";
            if (!$util.isInteger(message.hkQotRight))
                return "hkQotRight: integer expected";
            if (!$util.isInteger(message.usQotRight))
                return "usQotRight: integer expected";
            if (!$util.isInteger(message.cnQotRight))
                return "cnQotRight: integer expected";
            if (typeof message.isNeedAgreeDisclaimer !== "boolean")
                return "isNeedAgreeDisclaimer: boolean expected";
            if (!$util.isInteger(message.userID) && !(message.userID && $util.isInteger(message.userID.low) && $util.isInteger(message.userID.high)))
                return "userID: integer|Long expected";
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof GetUserInfo.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {GetUserInfo.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.GetUserInfo.S2C)
                return object;
            var message = new $root.GetUserInfo.S2C();
            if (object.nickName != null)
                message.nickName = String(object.nickName);
            if (object.avatarUrl != null)
                message.avatarUrl = String(object.avatarUrl);
            if (object.apiLevel != null)
                message.apiLevel = String(object.apiLevel);
            if (object.hkQotRight != null)
                message.hkQotRight = object.hkQotRight | 0;
            if (object.usQotRight != null)
                message.usQotRight = object.usQotRight | 0;
            if (object.cnQotRight != null)
                message.cnQotRight = object.cnQotRight | 0;
            if (object.isNeedAgreeDisclaimer != null)
                message.isNeedAgreeDisclaimer = Boolean(object.isNeedAgreeDisclaimer);
            if (object.userID != null)
                if ($util.Long)
                    (message.userID = $util.Long.fromValue(object.userID)).unsigned = false;
                else if (typeof object.userID === "string")
                    message.userID = parseInt(object.userID, 10);
                else if (typeof object.userID === "number")
                    message.userID = object.userID;
                else if (typeof object.userID === "object")
                    message.userID = new $util.LongBits(object.userID.low >>> 0, object.userID.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof GetUserInfo.S2C
         * @static
         * @param {GetUserInfo.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.nickName = "";
                object.avatarUrl = "";
                object.apiLevel = "";
                object.hkQotRight = 0;
                object.usQotRight = 0;
                object.cnQotRight = 0;
                object.isNeedAgreeDisclaimer = false;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.userID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.userID = options.longs === String ? "0" : 0;
            }
            if (message.nickName != null && message.hasOwnProperty("nickName"))
                object.nickName = message.nickName;
            if (message.avatarUrl != null && message.hasOwnProperty("avatarUrl"))
                object.avatarUrl = message.avatarUrl;
            if (message.apiLevel != null && message.hasOwnProperty("apiLevel"))
                object.apiLevel = message.apiLevel;
            if (message.hkQotRight != null && message.hasOwnProperty("hkQotRight"))
                object.hkQotRight = message.hkQotRight;
            if (message.usQotRight != null && message.hasOwnProperty("usQotRight"))
                object.usQotRight = message.usQotRight;
            if (message.cnQotRight != null && message.hasOwnProperty("cnQotRight"))
                object.cnQotRight = message.cnQotRight;
            if (message.isNeedAgreeDisclaimer != null && message.hasOwnProperty("isNeedAgreeDisclaimer"))
                object.isNeedAgreeDisclaimer = message.isNeedAgreeDisclaimer;
            if (message.userID != null && message.hasOwnProperty("userID"))
                if (typeof message.userID === "number")
                    object.userID = options.longs === String ? String(message.userID) : message.userID;
                else
                    object.userID = options.longs === String ? $util.Long.prototype.toString.call(message.userID) : options.longs === Number ? new $util.LongBits(message.userID.low >>> 0, message.userID.high >>> 0).toNumber() : message.userID;
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof GetUserInfo.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    GetUserInfo.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof GetUserInfo
         * @interface IRequest
         * @property {GetUserInfo.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof GetUserInfo
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {GetUserInfo.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {GetUserInfo.IC2S} c2s
         * @memberof GetUserInfo.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof GetUserInfo.Request
         * @static
         * @param {GetUserInfo.IRequest=} [properties] Properties to set
         * @returns {GetUserInfo.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link GetUserInfo.Request.verify|verify} messages.
         * @function encode
         * @memberof GetUserInfo.Request
         * @static
         * @param {GetUserInfo.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.GetUserInfo.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link GetUserInfo.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof GetUserInfo.Request
         * @static
         * @param {GetUserInfo.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof GetUserInfo.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {GetUserInfo.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetUserInfo.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.GetUserInfo.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof GetUserInfo.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {GetUserInfo.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof GetUserInfo.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.GetUserInfo.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof GetUserInfo.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {GetUserInfo.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.GetUserInfo.Request)
                return object;
            var message = new $root.GetUserInfo.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".GetUserInfo.Request.c2s: object expected");
                message.c2s = $root.GetUserInfo.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof GetUserInfo.Request
         * @static
         * @param {GetUserInfo.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.GetUserInfo.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof GetUserInfo.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    GetUserInfo.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof GetUserInfo
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {GetUserInfo.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof GetUserInfo
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {GetUserInfo.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof GetUserInfo.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof GetUserInfo.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof GetUserInfo.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {GetUserInfo.IS2C|null|undefined} s2c
         * @memberof GetUserInfo.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof GetUserInfo.Response
         * @static
         * @param {GetUserInfo.IResponse=} [properties] Properties to set
         * @returns {GetUserInfo.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link GetUserInfo.Response.verify|verify} messages.
         * @function encode
         * @memberof GetUserInfo.Response
         * @static
         * @param {GetUserInfo.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.GetUserInfo.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link GetUserInfo.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof GetUserInfo.Response
         * @static
         * @param {GetUserInfo.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof GetUserInfo.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {GetUserInfo.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetUserInfo.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.GetUserInfo.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof GetUserInfo.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {GetUserInfo.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof GetUserInfo.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.GetUserInfo.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof GetUserInfo.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {GetUserInfo.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.GetUserInfo.Response)
                return object;
            var message = new $root.GetUserInfo.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".GetUserInfo.Response.s2c: object expected");
                message.s2c = $root.GetUserInfo.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof GetUserInfo.Response
         * @static
         * @param {GetUserInfo.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.GetUserInfo.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof GetUserInfo.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return GetUserInfo;
})();

$root.InitConnect = (function() {

    /**
     * Namespace InitConnect.
     * @exports InitConnect
     * @namespace
     */
    var InitConnect = {};

    InitConnect.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof InitConnect
         * @interface IC2S
         * @property {number} clientVer C2S clientVer
         * @property {string} clientID C2S clientID
         * @property {boolean|null} [recvNotify] C2S recvNotify
         * @property {number|null} [packetEncAlgo] C2S packetEncAlgo
         */

        /**
         * Constructs a new C2S.
         * @memberof InitConnect
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {InitConnect.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S clientVer.
         * @member {number} clientVer
         * @memberof InitConnect.C2S
         * @instance
         */
        C2S.prototype.clientVer = 0;

        /**
         * C2S clientID.
         * @member {string} clientID
         * @memberof InitConnect.C2S
         * @instance
         */
        C2S.prototype.clientID = "";

        /**
         * C2S recvNotify.
         * @member {boolean} recvNotify
         * @memberof InitConnect.C2S
         * @instance
         */
        C2S.prototype.recvNotify = false;

        /**
         * C2S packetEncAlgo.
         * @member {number} packetEncAlgo
         * @memberof InitConnect.C2S
         * @instance
         */
        C2S.prototype.packetEncAlgo = 0;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof InitConnect.C2S
         * @static
         * @param {InitConnect.IC2S=} [properties] Properties to set
         * @returns {InitConnect.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link InitConnect.C2S.verify|verify} messages.
         * @function encode
         * @memberof InitConnect.C2S
         * @static
         * @param {InitConnect.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.clientVer);
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.clientID);
            if (message.recvNotify != null && message.hasOwnProperty("recvNotify"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.recvNotify);
            if (message.packetEncAlgo != null && message.hasOwnProperty("packetEncAlgo"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.packetEncAlgo);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link InitConnect.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof InitConnect.C2S
         * @static
         * @param {InitConnect.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof InitConnect.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {InitConnect.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.InitConnect.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.clientVer = reader.int32();
                    break;
                case 2:
                    message.clientID = reader.string();
                    break;
                case 3:
                    message.recvNotify = reader.bool();
                    break;
                case 4:
                    message.packetEncAlgo = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("clientVer"))
                throw $util.ProtocolError("missing required 'clientVer'", { instance: message });
            if (!message.hasOwnProperty("clientID"))
                throw $util.ProtocolError("missing required 'clientID'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof InitConnect.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {InitConnect.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof InitConnect.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.clientVer))
                return "clientVer: integer expected";
            if (!$util.isString(message.clientID))
                return "clientID: string expected";
            if (message.recvNotify != null && message.hasOwnProperty("recvNotify"))
                if (typeof message.recvNotify !== "boolean")
                    return "recvNotify: boolean expected";
            if (message.packetEncAlgo != null && message.hasOwnProperty("packetEncAlgo"))
                if (!$util.isInteger(message.packetEncAlgo))
                    return "packetEncAlgo: integer expected";
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof InitConnect.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {InitConnect.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.InitConnect.C2S)
                return object;
            var message = new $root.InitConnect.C2S();
            if (object.clientVer != null)
                message.clientVer = object.clientVer | 0;
            if (object.clientID != null)
                message.clientID = String(object.clientID);
            if (object.recvNotify != null)
                message.recvNotify = Boolean(object.recvNotify);
            if (object.packetEncAlgo != null)
                message.packetEncAlgo = object.packetEncAlgo | 0;
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof InitConnect.C2S
         * @static
         * @param {InitConnect.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.clientVer = 0;
                object.clientID = "";
                object.recvNotify = false;
                object.packetEncAlgo = 0;
            }
            if (message.clientVer != null && message.hasOwnProperty("clientVer"))
                object.clientVer = message.clientVer;
            if (message.clientID != null && message.hasOwnProperty("clientID"))
                object.clientID = message.clientID;
            if (message.recvNotify != null && message.hasOwnProperty("recvNotify"))
                object.recvNotify = message.recvNotify;
            if (message.packetEncAlgo != null && message.hasOwnProperty("packetEncAlgo"))
                object.packetEncAlgo = message.packetEncAlgo;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof InitConnect.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    InitConnect.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof InitConnect
         * @interface IS2C
         * @property {number} serverVer S2C serverVer
         * @property {number|Long} loginUserID S2C loginUserID
         * @property {number|Long} connID S2C connID
         * @property {string} connAESKey S2C connAESKey
         * @property {number} keepAliveInterval S2C keepAliveInterval
         */

        /**
         * Constructs a new S2C.
         * @memberof InitConnect
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {InitConnect.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C serverVer.
         * @member {number} serverVer
         * @memberof InitConnect.S2C
         * @instance
         */
        S2C.prototype.serverVer = 0;

        /**
         * S2C loginUserID.
         * @member {number|Long} loginUserID
         * @memberof InitConnect.S2C
         * @instance
         */
        S2C.prototype.loginUserID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * S2C connID.
         * @member {number|Long} connID
         * @memberof InitConnect.S2C
         * @instance
         */
        S2C.prototype.connID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * S2C connAESKey.
         * @member {string} connAESKey
         * @memberof InitConnect.S2C
         * @instance
         */
        S2C.prototype.connAESKey = "";

        /**
         * S2C keepAliveInterval.
         * @member {number} keepAliveInterval
         * @memberof InitConnect.S2C
         * @instance
         */
        S2C.prototype.keepAliveInterval = 0;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof InitConnect.S2C
         * @static
         * @param {InitConnect.IS2C=} [properties] Properties to set
         * @returns {InitConnect.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link InitConnect.S2C.verify|verify} messages.
         * @function encode
         * @memberof InitConnect.S2C
         * @static
         * @param {InitConnect.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.serverVer);
            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.loginUserID);
            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.connID);
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.connAESKey);
            writer.uint32(/* id 5, wireType 0 =*/40).int32(message.keepAliveInterval);
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link InitConnect.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof InitConnect.S2C
         * @static
         * @param {InitConnect.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof InitConnect.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {InitConnect.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.InitConnect.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.serverVer = reader.int32();
                    break;
                case 2:
                    message.loginUserID = reader.uint64();
                    break;
                case 3:
                    message.connID = reader.uint64();
                    break;
                case 4:
                    message.connAESKey = reader.string();
                    break;
                case 5:
                    message.keepAliveInterval = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("serverVer"))
                throw $util.ProtocolError("missing required 'serverVer'", { instance: message });
            if (!message.hasOwnProperty("loginUserID"))
                throw $util.ProtocolError("missing required 'loginUserID'", { instance: message });
            if (!message.hasOwnProperty("connID"))
                throw $util.ProtocolError("missing required 'connID'", { instance: message });
            if (!message.hasOwnProperty("connAESKey"))
                throw $util.ProtocolError("missing required 'connAESKey'", { instance: message });
            if (!message.hasOwnProperty("keepAliveInterval"))
                throw $util.ProtocolError("missing required 'keepAliveInterval'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof InitConnect.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {InitConnect.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof InitConnect.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.serverVer))
                return "serverVer: integer expected";
            if (!$util.isInteger(message.loginUserID) && !(message.loginUserID && $util.isInteger(message.loginUserID.low) && $util.isInteger(message.loginUserID.high)))
                return "loginUserID: integer|Long expected";
            if (!$util.isInteger(message.connID) && !(message.connID && $util.isInteger(message.connID.low) && $util.isInteger(message.connID.high)))
                return "connID: integer|Long expected";
            if (!$util.isString(message.connAESKey))
                return "connAESKey: string expected";
            if (!$util.isInteger(message.keepAliveInterval))
                return "keepAliveInterval: integer expected";
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof InitConnect.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {InitConnect.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.InitConnect.S2C)
                return object;
            var message = new $root.InitConnect.S2C();
            if (object.serverVer != null)
                message.serverVer = object.serverVer | 0;
            if (object.loginUserID != null)
                if ($util.Long)
                    (message.loginUserID = $util.Long.fromValue(object.loginUserID)).unsigned = true;
                else if (typeof object.loginUserID === "string")
                    message.loginUserID = parseInt(object.loginUserID, 10);
                else if (typeof object.loginUserID === "number")
                    message.loginUserID = object.loginUserID;
                else if (typeof object.loginUserID === "object")
                    message.loginUserID = new $util.LongBits(object.loginUserID.low >>> 0, object.loginUserID.high >>> 0).toNumber(true);
            if (object.connID != null)
                if ($util.Long)
                    (message.connID = $util.Long.fromValue(object.connID)).unsigned = true;
                else if (typeof object.connID === "string")
                    message.connID = parseInt(object.connID, 10);
                else if (typeof object.connID === "number")
                    message.connID = object.connID;
                else if (typeof object.connID === "object")
                    message.connID = new $util.LongBits(object.connID.low >>> 0, object.connID.high >>> 0).toNumber(true);
            if (object.connAESKey != null)
                message.connAESKey = String(object.connAESKey);
            if (object.keepAliveInterval != null)
                message.keepAliveInterval = object.keepAliveInterval | 0;
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof InitConnect.S2C
         * @static
         * @param {InitConnect.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.serverVer = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.loginUserID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.loginUserID = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.connID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.connID = options.longs === String ? "0" : 0;
                object.connAESKey = "";
                object.keepAliveInterval = 0;
            }
            if (message.serverVer != null && message.hasOwnProperty("serverVer"))
                object.serverVer = message.serverVer;
            if (message.loginUserID != null && message.hasOwnProperty("loginUserID"))
                if (typeof message.loginUserID === "number")
                    object.loginUserID = options.longs === String ? String(message.loginUserID) : message.loginUserID;
                else
                    object.loginUserID = options.longs === String ? $util.Long.prototype.toString.call(message.loginUserID) : options.longs === Number ? new $util.LongBits(message.loginUserID.low >>> 0, message.loginUserID.high >>> 0).toNumber(true) : message.loginUserID;
            if (message.connID != null && message.hasOwnProperty("connID"))
                if (typeof message.connID === "number")
                    object.connID = options.longs === String ? String(message.connID) : message.connID;
                else
                    object.connID = options.longs === String ? $util.Long.prototype.toString.call(message.connID) : options.longs === Number ? new $util.LongBits(message.connID.low >>> 0, message.connID.high >>> 0).toNumber(true) : message.connID;
            if (message.connAESKey != null && message.hasOwnProperty("connAESKey"))
                object.connAESKey = message.connAESKey;
            if (message.keepAliveInterval != null && message.hasOwnProperty("keepAliveInterval"))
                object.keepAliveInterval = message.keepAliveInterval;
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof InitConnect.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    InitConnect.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof InitConnect
         * @interface IRequest
         * @property {InitConnect.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof InitConnect
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {InitConnect.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {InitConnect.IC2S} c2s
         * @memberof InitConnect.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof InitConnect.Request
         * @static
         * @param {InitConnect.IRequest=} [properties] Properties to set
         * @returns {InitConnect.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link InitConnect.Request.verify|verify} messages.
         * @function encode
         * @memberof InitConnect.Request
         * @static
         * @param {InitConnect.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.InitConnect.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link InitConnect.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof InitConnect.Request
         * @static
         * @param {InitConnect.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof InitConnect.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {InitConnect.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.InitConnect.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.InitConnect.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof InitConnect.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {InitConnect.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof InitConnect.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.InitConnect.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof InitConnect.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {InitConnect.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.InitConnect.Request)
                return object;
            var message = new $root.InitConnect.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".InitConnect.Request.c2s: object expected");
                message.c2s = $root.InitConnect.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof InitConnect.Request
         * @static
         * @param {InitConnect.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.InitConnect.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof InitConnect.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    InitConnect.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof InitConnect
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {InitConnect.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof InitConnect
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {InitConnect.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof InitConnect.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof InitConnect.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof InitConnect.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {InitConnect.IS2C|null|undefined} s2c
         * @memberof InitConnect.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof InitConnect.Response
         * @static
         * @param {InitConnect.IResponse=} [properties] Properties to set
         * @returns {InitConnect.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link InitConnect.Response.verify|verify} messages.
         * @function encode
         * @memberof InitConnect.Response
         * @static
         * @param {InitConnect.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.InitConnect.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link InitConnect.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof InitConnect.Response
         * @static
         * @param {InitConnect.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof InitConnect.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {InitConnect.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.InitConnect.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.InitConnect.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof InitConnect.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {InitConnect.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof InitConnect.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.InitConnect.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof InitConnect.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {InitConnect.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.InitConnect.Response)
                return object;
            var message = new $root.InitConnect.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".InitConnect.Response.s2c: object expected");
                message.s2c = $root.InitConnect.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof InitConnect.Response
         * @static
         * @param {InitConnect.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.InitConnect.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof InitConnect.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return InitConnect;
})();

$root.KeepAlive = (function() {

    /**
     * Namespace KeepAlive.
     * @exports KeepAlive
     * @namespace
     */
    var KeepAlive = {};

    KeepAlive.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof KeepAlive
         * @interface IC2S
         * @property {number|Long} time C2S time
         */

        /**
         * Constructs a new C2S.
         * @memberof KeepAlive
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {KeepAlive.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S time.
         * @member {number|Long} time
         * @memberof KeepAlive.C2S
         * @instance
         */
        C2S.prototype.time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof KeepAlive.C2S
         * @static
         * @param {KeepAlive.IC2S=} [properties] Properties to set
         * @returns {KeepAlive.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link KeepAlive.C2S.verify|verify} messages.
         * @function encode
         * @memberof KeepAlive.C2S
         * @static
         * @param {KeepAlive.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.time);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link KeepAlive.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof KeepAlive.C2S
         * @static
         * @param {KeepAlive.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof KeepAlive.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {KeepAlive.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.KeepAlive.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.time = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("time"))
                throw $util.ProtocolError("missing required 'time'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof KeepAlive.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {KeepAlive.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof KeepAlive.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.time) && !(message.time && $util.isInteger(message.time.low) && $util.isInteger(message.time.high)))
                return "time: integer|Long expected";
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof KeepAlive.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {KeepAlive.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.KeepAlive.C2S)
                return object;
            var message = new $root.KeepAlive.C2S();
            if (object.time != null)
                if ($util.Long)
                    (message.time = $util.Long.fromValue(object.time)).unsigned = false;
                else if (typeof object.time === "string")
                    message.time = parseInt(object.time, 10);
                else if (typeof object.time === "number")
                    message.time = object.time;
                else if (typeof object.time === "object")
                    message.time = new $util.LongBits(object.time.low >>> 0, object.time.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof KeepAlive.C2S
         * @static
         * @param {KeepAlive.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.time = options.longs === String ? "0" : 0;
            if (message.time != null && message.hasOwnProperty("time"))
                if (typeof message.time === "number")
                    object.time = options.longs === String ? String(message.time) : message.time;
                else
                    object.time = options.longs === String ? $util.Long.prototype.toString.call(message.time) : options.longs === Number ? new $util.LongBits(message.time.low >>> 0, message.time.high >>> 0).toNumber() : message.time;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof KeepAlive.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    KeepAlive.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof KeepAlive
         * @interface IS2C
         * @property {number|Long} time S2C time
         */

        /**
         * Constructs a new S2C.
         * @memberof KeepAlive
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {KeepAlive.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C time.
         * @member {number|Long} time
         * @memberof KeepAlive.S2C
         * @instance
         */
        S2C.prototype.time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof KeepAlive.S2C
         * @static
         * @param {KeepAlive.IS2C=} [properties] Properties to set
         * @returns {KeepAlive.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link KeepAlive.S2C.verify|verify} messages.
         * @function encode
         * @memberof KeepAlive.S2C
         * @static
         * @param {KeepAlive.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.time);
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link KeepAlive.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof KeepAlive.S2C
         * @static
         * @param {KeepAlive.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof KeepAlive.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {KeepAlive.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.KeepAlive.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.time = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("time"))
                throw $util.ProtocolError("missing required 'time'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof KeepAlive.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {KeepAlive.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof KeepAlive.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.time) && !(message.time && $util.isInteger(message.time.low) && $util.isInteger(message.time.high)))
                return "time: integer|Long expected";
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof KeepAlive.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {KeepAlive.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.KeepAlive.S2C)
                return object;
            var message = new $root.KeepAlive.S2C();
            if (object.time != null)
                if ($util.Long)
                    (message.time = $util.Long.fromValue(object.time)).unsigned = false;
                else if (typeof object.time === "string")
                    message.time = parseInt(object.time, 10);
                else if (typeof object.time === "number")
                    message.time = object.time;
                else if (typeof object.time === "object")
                    message.time = new $util.LongBits(object.time.low >>> 0, object.time.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof KeepAlive.S2C
         * @static
         * @param {KeepAlive.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.time = options.longs === String ? "0" : 0;
            if (message.time != null && message.hasOwnProperty("time"))
                if (typeof message.time === "number")
                    object.time = options.longs === String ? String(message.time) : message.time;
                else
                    object.time = options.longs === String ? $util.Long.prototype.toString.call(message.time) : options.longs === Number ? new $util.LongBits(message.time.low >>> 0, message.time.high >>> 0).toNumber() : message.time;
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof KeepAlive.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    KeepAlive.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof KeepAlive
         * @interface IRequest
         * @property {KeepAlive.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof KeepAlive
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {KeepAlive.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {KeepAlive.IC2S} c2s
         * @memberof KeepAlive.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof KeepAlive.Request
         * @static
         * @param {KeepAlive.IRequest=} [properties] Properties to set
         * @returns {KeepAlive.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link KeepAlive.Request.verify|verify} messages.
         * @function encode
         * @memberof KeepAlive.Request
         * @static
         * @param {KeepAlive.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.KeepAlive.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link KeepAlive.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof KeepAlive.Request
         * @static
         * @param {KeepAlive.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof KeepAlive.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {KeepAlive.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.KeepAlive.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.KeepAlive.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof KeepAlive.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {KeepAlive.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof KeepAlive.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.KeepAlive.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof KeepAlive.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {KeepAlive.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.KeepAlive.Request)
                return object;
            var message = new $root.KeepAlive.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".KeepAlive.Request.c2s: object expected");
                message.c2s = $root.KeepAlive.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof KeepAlive.Request
         * @static
         * @param {KeepAlive.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.KeepAlive.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof KeepAlive.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    KeepAlive.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof KeepAlive
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {KeepAlive.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof KeepAlive
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {KeepAlive.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof KeepAlive.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof KeepAlive.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof KeepAlive.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {KeepAlive.IS2C|null|undefined} s2c
         * @memberof KeepAlive.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof KeepAlive.Response
         * @static
         * @param {KeepAlive.IResponse=} [properties] Properties to set
         * @returns {KeepAlive.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link KeepAlive.Response.verify|verify} messages.
         * @function encode
         * @memberof KeepAlive.Response
         * @static
         * @param {KeepAlive.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.KeepAlive.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link KeepAlive.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof KeepAlive.Response
         * @static
         * @param {KeepAlive.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof KeepAlive.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {KeepAlive.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.KeepAlive.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.KeepAlive.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof KeepAlive.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {KeepAlive.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof KeepAlive.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.KeepAlive.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof KeepAlive.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {KeepAlive.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.KeepAlive.Response)
                return object;
            var message = new $root.KeepAlive.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".KeepAlive.Response.s2c: object expected");
                message.s2c = $root.KeepAlive.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof KeepAlive.Response
         * @static
         * @param {KeepAlive.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.KeepAlive.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof KeepAlive.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return KeepAlive;
})();

$root.Notify = (function() {

    /**
     * Namespace Notify.
     * @exports Notify
     * @namespace
     */
    var Notify = {};

    /**
     * NotifyType enum.
     * @name Notify.NotifyType
     * @enum {string}
     * @property {number} NotifyType_None=0 NotifyType_None value
     * @property {number} NotifyType_GtwEvent=1 NotifyType_GtwEvent value
     */
    Notify.NotifyType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NotifyType_None"] = 0;
        values[valuesById[1] = "NotifyType_GtwEvent"] = 1;
        return values;
    })();

    /**
     * GtwEventType enum.
     * @name Notify.GtwEventType
     * @enum {string}
     * @property {number} GtwEventType_None=0 GtwEventType_None value
     * @property {number} GtwEventType_LocalCfgLoadFailed=1 GtwEventType_LocalCfgLoadFailed value
     * @property {number} GtwEventType_APISvrRunFailed=2 GtwEventType_APISvrRunFailed value
     * @property {number} GtwEventType_ForceUpdate=3 GtwEventType_ForceUpdate value
     * @property {number} GtwEventType_LoginFailed=4 GtwEventType_LoginFailed value
     * @property {number} GtwEventType_UnAgreeDisclaimer=5 GtwEventType_UnAgreeDisclaimer value
     * @property {number} GtwEventType_NetCfgMissing=6 GtwEventType_NetCfgMissing value
     * @property {number} GtwEventType_KickedOut=7 GtwEventType_KickedOut value
     * @property {number} GtwEventType_LoginPwdChanged=8 GtwEventType_LoginPwdChanged value
     * @property {number} GtwEventType_BanLogin=9 GtwEventType_BanLogin value
     * @property {number} GtwEventType_NeedPicVerifyCode=10 GtwEventType_NeedPicVerifyCode value
     * @property {number} GtwEventType_NeedPhoneVerifyCode=11 GtwEventType_NeedPhoneVerifyCode value
     * @property {number} GtwEventType_AppDataNotExist=12 GtwEventType_AppDataNotExist value
     * @property {number} GtwEventType_NessaryDataMissing=13 GtwEventType_NessaryDataMissing value
     * @property {number} GtwEventType_TradePwdChanged=14 GtwEventType_TradePwdChanged value
     * @property {number} GtwEventType_EnableDeviceLock=15 GtwEventType_EnableDeviceLock value
     */
    Notify.GtwEventType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "GtwEventType_None"] = 0;
        values[valuesById[1] = "GtwEventType_LocalCfgLoadFailed"] = 1;
        values[valuesById[2] = "GtwEventType_APISvrRunFailed"] = 2;
        values[valuesById[3] = "GtwEventType_ForceUpdate"] = 3;
        values[valuesById[4] = "GtwEventType_LoginFailed"] = 4;
        values[valuesById[5] = "GtwEventType_UnAgreeDisclaimer"] = 5;
        values[valuesById[6] = "GtwEventType_NetCfgMissing"] = 6;
        values[valuesById[7] = "GtwEventType_KickedOut"] = 7;
        values[valuesById[8] = "GtwEventType_LoginPwdChanged"] = 8;
        values[valuesById[9] = "GtwEventType_BanLogin"] = 9;
        values[valuesById[10] = "GtwEventType_NeedPicVerifyCode"] = 10;
        values[valuesById[11] = "GtwEventType_NeedPhoneVerifyCode"] = 11;
        values[valuesById[12] = "GtwEventType_AppDataNotExist"] = 12;
        values[valuesById[13] = "GtwEventType_NessaryDataMissing"] = 13;
        values[valuesById[14] = "GtwEventType_TradePwdChanged"] = 14;
        values[valuesById[15] = "GtwEventType_EnableDeviceLock"] = 15;
        return values;
    })();

    Notify.GtwEvent = (function() {

        /**
         * Properties of a GtwEvent.
         * @memberof Notify
         * @interface IGtwEvent
         * @property {number} eventType GtwEvent eventType
         * @property {string} desc GtwEvent desc
         */

        /**
         * Constructs a new GtwEvent.
         * @memberof Notify
         * @classdesc Represents a GtwEvent.
         * @implements IGtwEvent
         * @constructor
         * @param {Notify.IGtwEvent=} [properties] Properties to set
         */
        function GtwEvent(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GtwEvent eventType.
         * @member {number} eventType
         * @memberof Notify.GtwEvent
         * @instance
         */
        GtwEvent.prototype.eventType = 0;

        /**
         * GtwEvent desc.
         * @member {string} desc
         * @memberof Notify.GtwEvent
         * @instance
         */
        GtwEvent.prototype.desc = "";

        /**
         * Creates a new GtwEvent instance using the specified properties.
         * @function create
         * @memberof Notify.GtwEvent
         * @static
         * @param {Notify.IGtwEvent=} [properties] Properties to set
         * @returns {Notify.GtwEvent} GtwEvent instance
         */
        GtwEvent.create = function create(properties) {
            return new GtwEvent(properties);
        };

        /**
         * Encodes the specified GtwEvent message. Does not implicitly {@link Notify.GtwEvent.verify|verify} messages.
         * @function encode
         * @memberof Notify.GtwEvent
         * @static
         * @param {Notify.IGtwEvent} message GtwEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GtwEvent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.eventType);
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.desc);
            return writer;
        };

        /**
         * Encodes the specified GtwEvent message, length delimited. Does not implicitly {@link Notify.GtwEvent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Notify.GtwEvent
         * @static
         * @param {Notify.IGtwEvent} message GtwEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GtwEvent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GtwEvent message from the specified reader or buffer.
         * @function decode
         * @memberof Notify.GtwEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Notify.GtwEvent} GtwEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GtwEvent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Notify.GtwEvent();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.eventType = reader.int32();
                    break;
                case 2:
                    message.desc = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("eventType"))
                throw $util.ProtocolError("missing required 'eventType'", { instance: message });
            if (!message.hasOwnProperty("desc"))
                throw $util.ProtocolError("missing required 'desc'", { instance: message });
            return message;
        };

        /**
         * Decodes a GtwEvent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Notify.GtwEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Notify.GtwEvent} GtwEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GtwEvent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GtwEvent message.
         * @function verify
         * @memberof Notify.GtwEvent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GtwEvent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.eventType))
                return "eventType: integer expected";
            if (!$util.isString(message.desc))
                return "desc: string expected";
            return null;
        };

        /**
         * Creates a GtwEvent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Notify.GtwEvent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Notify.GtwEvent} GtwEvent
         */
        GtwEvent.fromObject = function fromObject(object) {
            if (object instanceof $root.Notify.GtwEvent)
                return object;
            var message = new $root.Notify.GtwEvent();
            if (object.eventType != null)
                message.eventType = object.eventType | 0;
            if (object.desc != null)
                message.desc = String(object.desc);
            return message;
        };

        /**
         * Creates a plain object from a GtwEvent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Notify.GtwEvent
         * @static
         * @param {Notify.GtwEvent} message GtwEvent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GtwEvent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.eventType = 0;
                object.desc = "";
            }
            if (message.eventType != null && message.hasOwnProperty("eventType"))
                object.eventType = message.eventType;
            if (message.desc != null && message.hasOwnProperty("desc"))
                object.desc = message.desc;
            return object;
        };

        /**
         * Converts this GtwEvent to JSON.
         * @function toJSON
         * @memberof Notify.GtwEvent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GtwEvent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GtwEvent;
    })();

    Notify.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Notify
         * @interface IS2C
         * @property {number} type S2C type
         * @property {Notify.IGtwEvent|null} [event] S2C event
         */

        /**
         * Constructs a new S2C.
         * @memberof Notify
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Notify.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C type.
         * @member {number} type
         * @memberof Notify.S2C
         * @instance
         */
        S2C.prototype.type = 0;

        /**
         * S2C event.
         * @member {Notify.IGtwEvent|null|undefined} event
         * @memberof Notify.S2C
         * @instance
         */
        S2C.prototype.event = null;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Notify.S2C
         * @static
         * @param {Notify.IS2C=} [properties] Properties to set
         * @returns {Notify.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Notify.S2C.verify|verify} messages.
         * @function encode
         * @memberof Notify.S2C
         * @static
         * @param {Notify.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.event != null && message.hasOwnProperty("event"))
                $root.Notify.GtwEvent.encode(message.event, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Notify.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Notify.S2C
         * @static
         * @param {Notify.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Notify.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Notify.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Notify.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.event = $root.Notify.GtwEvent.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("type"))
                throw $util.ProtocolError("missing required 'type'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Notify.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Notify.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Notify.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.type))
                return "type: integer expected";
            if (message.event != null && message.hasOwnProperty("event")) {
                var error = $root.Notify.GtwEvent.verify(message.event);
                if (error)
                    return "event." + error;
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Notify.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Notify.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Notify.S2C)
                return object;
            var message = new $root.Notify.S2C();
            if (object.type != null)
                message.type = object.type | 0;
            if (object.event != null) {
                if (typeof object.event !== "object")
                    throw TypeError(".Notify.S2C.event: object expected");
                message.event = $root.Notify.GtwEvent.fromObject(object.event);
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Notify.S2C
         * @static
         * @param {Notify.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = 0;
                object.event = null;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.event != null && message.hasOwnProperty("event"))
                object.event = $root.Notify.GtwEvent.toObject(message.event, options);
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Notify.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Notify.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Notify
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Notify.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Notify
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Notify.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Notify.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Notify.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Notify.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Notify.IS2C|null|undefined} s2c
         * @memberof Notify.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Notify.Response
         * @static
         * @param {Notify.IResponse=} [properties] Properties to set
         * @returns {Notify.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Notify.Response.verify|verify} messages.
         * @function encode
         * @memberof Notify.Response
         * @static
         * @param {Notify.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Notify.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Notify.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Notify.Response
         * @static
         * @param {Notify.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Notify.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Notify.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Notify.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Notify.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Notify.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Notify.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Notify.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Notify.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Notify.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Notify.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Notify.Response)
                return object;
            var message = new $root.Notify.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Notify.Response.s2c: object expected");
                message.s2c = $root.Notify.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Notify.Response
         * @static
         * @param {Notify.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Notify.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Notify.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Notify;
})();

$root.Qot_GetBasicQot = (function() {

    /**
     * Namespace Qot_GetBasicQot.
     * @exports Qot_GetBasicQot
     * @namespace
     */
    var Qot_GetBasicQot = {};

    Qot_GetBasicQot.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Qot_GetBasicQot
         * @interface IC2S
         * @property {Array.<Qot_Common.ISecurity>|null} [securityList] C2S securityList
         */

        /**
         * Constructs a new C2S.
         * @memberof Qot_GetBasicQot
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Qot_GetBasicQot.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            this.securityList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S securityList.
         * @member {Array.<Qot_Common.ISecurity>} securityList
         * @memberof Qot_GetBasicQot.C2S
         * @instance
         */
        C2S.prototype.securityList = $util.emptyArray;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Qot_GetBasicQot.C2S
         * @static
         * @param {Qot_GetBasicQot.IC2S=} [properties] Properties to set
         * @returns {Qot_GetBasicQot.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Qot_GetBasicQot.C2S.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetBasicQot.C2S
         * @static
         * @param {Qot_GetBasicQot.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.securityList != null && message.securityList.length)
                for (var i = 0; i < message.securityList.length; ++i)
                    $root.Qot_Common.Security.encode(message.securityList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Qot_GetBasicQot.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetBasicQot.C2S
         * @static
         * @param {Qot_GetBasicQot.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetBasicQot.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetBasicQot.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetBasicQot.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.securityList && message.securityList.length))
                        message.securityList = [];
                    message.securityList.push($root.Qot_Common.Security.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetBasicQot.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetBasicQot.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Qot_GetBasicQot.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.securityList != null && message.hasOwnProperty("securityList")) {
                if (!Array.isArray(message.securityList))
                    return "securityList: array expected";
                for (var i = 0; i < message.securityList.length; ++i) {
                    var error = $root.Qot_Common.Security.verify(message.securityList[i]);
                    if (error)
                        return "securityList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetBasicQot.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetBasicQot.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetBasicQot.C2S)
                return object;
            var message = new $root.Qot_GetBasicQot.C2S();
            if (object.securityList) {
                if (!Array.isArray(object.securityList))
                    throw TypeError(".Qot_GetBasicQot.C2S.securityList: array expected");
                message.securityList = [];
                for (var i = 0; i < object.securityList.length; ++i) {
                    if (typeof object.securityList[i] !== "object")
                        throw TypeError(".Qot_GetBasicQot.C2S.securityList: object expected");
                    message.securityList[i] = $root.Qot_Common.Security.fromObject(object.securityList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetBasicQot.C2S
         * @static
         * @param {Qot_GetBasicQot.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.securityList = [];
            if (message.securityList && message.securityList.length) {
                object.securityList = [];
                for (var j = 0; j < message.securityList.length; ++j)
                    object.securityList[j] = $root.Qot_Common.Security.toObject(message.securityList[j], options);
            }
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Qot_GetBasicQot.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Qot_GetBasicQot.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_GetBasicQot
         * @interface IS2C
         * @property {Array.<Qot_Common.IBasicQot>|null} [basicQotList] S2C basicQotList
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_GetBasicQot
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_GetBasicQot.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.basicQotList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C basicQotList.
         * @member {Array.<Qot_Common.IBasicQot>} basicQotList
         * @memberof Qot_GetBasicQot.S2C
         * @instance
         */
        S2C.prototype.basicQotList = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_GetBasicQot.S2C
         * @static
         * @param {Qot_GetBasicQot.IS2C=} [properties] Properties to set
         * @returns {Qot_GetBasicQot.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_GetBasicQot.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetBasicQot.S2C
         * @static
         * @param {Qot_GetBasicQot.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.basicQotList != null && message.basicQotList.length)
                for (var i = 0; i < message.basicQotList.length; ++i)
                    $root.Qot_Common.BasicQot.encode(message.basicQotList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_GetBasicQot.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetBasicQot.S2C
         * @static
         * @param {Qot_GetBasicQot.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetBasicQot.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetBasicQot.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetBasicQot.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.basicQotList && message.basicQotList.length))
                        message.basicQotList = [];
                    message.basicQotList.push($root.Qot_Common.BasicQot.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetBasicQot.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetBasicQot.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_GetBasicQot.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.basicQotList != null && message.hasOwnProperty("basicQotList")) {
                if (!Array.isArray(message.basicQotList))
                    return "basicQotList: array expected";
                for (var i = 0; i < message.basicQotList.length; ++i) {
                    var error = $root.Qot_Common.BasicQot.verify(message.basicQotList[i]);
                    if (error)
                        return "basicQotList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetBasicQot.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetBasicQot.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetBasicQot.S2C)
                return object;
            var message = new $root.Qot_GetBasicQot.S2C();
            if (object.basicQotList) {
                if (!Array.isArray(object.basicQotList))
                    throw TypeError(".Qot_GetBasicQot.S2C.basicQotList: array expected");
                message.basicQotList = [];
                for (var i = 0; i < object.basicQotList.length; ++i) {
                    if (typeof object.basicQotList[i] !== "object")
                        throw TypeError(".Qot_GetBasicQot.S2C.basicQotList: object expected");
                    message.basicQotList[i] = $root.Qot_Common.BasicQot.fromObject(object.basicQotList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetBasicQot.S2C
         * @static
         * @param {Qot_GetBasicQot.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.basicQotList = [];
            if (message.basicQotList && message.basicQotList.length) {
                object.basicQotList = [];
                for (var j = 0; j < message.basicQotList.length; ++j)
                    object.basicQotList[j] = $root.Qot_Common.BasicQot.toObject(message.basicQotList[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_GetBasicQot.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_GetBasicQot.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Qot_GetBasicQot
         * @interface IRequest
         * @property {Qot_GetBasicQot.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Qot_GetBasicQot
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Qot_GetBasicQot.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Qot_GetBasicQot.IC2S} c2s
         * @memberof Qot_GetBasicQot.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Qot_GetBasicQot.Request
         * @static
         * @param {Qot_GetBasicQot.IRequest=} [properties] Properties to set
         * @returns {Qot_GetBasicQot.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Qot_GetBasicQot.Request.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetBasicQot.Request
         * @static
         * @param {Qot_GetBasicQot.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_GetBasicQot.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Qot_GetBasicQot.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetBasicQot.Request
         * @static
         * @param {Qot_GetBasicQot.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetBasicQot.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetBasicQot.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetBasicQot.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Qot_GetBasicQot.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetBasicQot.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetBasicQot.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Qot_GetBasicQot.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_GetBasicQot.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetBasicQot.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetBasicQot.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetBasicQot.Request)
                return object;
            var message = new $root.Qot_GetBasicQot.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Qot_GetBasicQot.Request.c2s: object expected");
                message.c2s = $root.Qot_GetBasicQot.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetBasicQot.Request
         * @static
         * @param {Qot_GetBasicQot.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Qot_GetBasicQot.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Qot_GetBasicQot.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Qot_GetBasicQot.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_GetBasicQot
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_GetBasicQot.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_GetBasicQot
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_GetBasicQot.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_GetBasicQot.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_GetBasicQot.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_GetBasicQot.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_GetBasicQot.IS2C|null|undefined} s2c
         * @memberof Qot_GetBasicQot.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_GetBasicQot.Response
         * @static
         * @param {Qot_GetBasicQot.IResponse=} [properties] Properties to set
         * @returns {Qot_GetBasicQot.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_GetBasicQot.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetBasicQot.Response
         * @static
         * @param {Qot_GetBasicQot.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_GetBasicQot.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_GetBasicQot.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetBasicQot.Response
         * @static
         * @param {Qot_GetBasicQot.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetBasicQot.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetBasicQot.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetBasicQot.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_GetBasicQot.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetBasicQot.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetBasicQot.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_GetBasicQot.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_GetBasicQot.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetBasicQot.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetBasicQot.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetBasicQot.Response)
                return object;
            var message = new $root.Qot_GetBasicQot.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_GetBasicQot.Response.s2c: object expected");
                message.s2c = $root.Qot_GetBasicQot.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetBasicQot.Response
         * @static
         * @param {Qot_GetBasicQot.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_GetBasicQot.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_GetBasicQot.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_GetBasicQot;
})();

$root.Qot_GetBroker = (function() {

    /**
     * Namespace Qot_GetBroker.
     * @exports Qot_GetBroker
     * @namespace
     */
    var Qot_GetBroker = {};

    Qot_GetBroker.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Qot_GetBroker
         * @interface IC2S
         * @property {Qot_Common.ISecurity} security C2S security
         */

        /**
         * Constructs a new C2S.
         * @memberof Qot_GetBroker
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Qot_GetBroker.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_GetBroker.C2S
         * @instance
         */
        C2S.prototype.security = null;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Qot_GetBroker.C2S
         * @static
         * @param {Qot_GetBroker.IC2S=} [properties] Properties to set
         * @returns {Qot_GetBroker.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Qot_GetBroker.C2S.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetBroker.C2S
         * @static
         * @param {Qot_GetBroker.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Qot_GetBroker.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetBroker.C2S
         * @static
         * @param {Qot_GetBroker.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetBroker.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetBroker.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetBroker.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetBroker.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetBroker.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Qot_GetBroker.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetBroker.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetBroker.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetBroker.C2S)
                return object;
            var message = new $root.Qot_GetBroker.C2S();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_GetBroker.C2S.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetBroker.C2S
         * @static
         * @param {Qot_GetBroker.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.security = null;
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Qot_GetBroker.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Qot_GetBroker.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_GetBroker
         * @interface IS2C
         * @property {Qot_Common.ISecurity} security S2C security
         * @property {Array.<Qot_Common.IBroker>|null} [brokerAskList] S2C brokerAskList
         * @property {Array.<Qot_Common.IBroker>|null} [brokerBidList] S2C brokerBidList
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_GetBroker
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_GetBroker.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.brokerAskList = [];
            this.brokerBidList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_GetBroker.S2C
         * @instance
         */
        S2C.prototype.security = null;

        /**
         * S2C brokerAskList.
         * @member {Array.<Qot_Common.IBroker>} brokerAskList
         * @memberof Qot_GetBroker.S2C
         * @instance
         */
        S2C.prototype.brokerAskList = $util.emptyArray;

        /**
         * S2C brokerBidList.
         * @member {Array.<Qot_Common.IBroker>} brokerBidList
         * @memberof Qot_GetBroker.S2C
         * @instance
         */
        S2C.prototype.brokerBidList = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_GetBroker.S2C
         * @static
         * @param {Qot_GetBroker.IS2C=} [properties] Properties to set
         * @returns {Qot_GetBroker.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_GetBroker.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetBroker.S2C
         * @static
         * @param {Qot_GetBroker.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.brokerAskList != null && message.brokerAskList.length)
                for (var i = 0; i < message.brokerAskList.length; ++i)
                    $root.Qot_Common.Broker.encode(message.brokerAskList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.brokerBidList != null && message.brokerBidList.length)
                for (var i = 0; i < message.brokerBidList.length; ++i)
                    $root.Qot_Common.Broker.encode(message.brokerBidList[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_GetBroker.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetBroker.S2C
         * @static
         * @param {Qot_GetBroker.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetBroker.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetBroker.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetBroker.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.brokerAskList && message.brokerAskList.length))
                        message.brokerAskList = [];
                    message.brokerAskList.push($root.Qot_Common.Broker.decode(reader, reader.uint32()));
                    break;
                case 3:
                    if (!(message.brokerBidList && message.brokerBidList.length))
                        message.brokerBidList = [];
                    message.brokerBidList.push($root.Qot_Common.Broker.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetBroker.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetBroker.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_GetBroker.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            if (message.brokerAskList != null && message.hasOwnProperty("brokerAskList")) {
                if (!Array.isArray(message.brokerAskList))
                    return "brokerAskList: array expected";
                for (var i = 0; i < message.brokerAskList.length; ++i) {
                    var error = $root.Qot_Common.Broker.verify(message.brokerAskList[i]);
                    if (error)
                        return "brokerAskList." + error;
                }
            }
            if (message.brokerBidList != null && message.hasOwnProperty("brokerBidList")) {
                if (!Array.isArray(message.brokerBidList))
                    return "brokerBidList: array expected";
                for (var i = 0; i < message.brokerBidList.length; ++i) {
                    var error = $root.Qot_Common.Broker.verify(message.brokerBidList[i]);
                    if (error)
                        return "brokerBidList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetBroker.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetBroker.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetBroker.S2C)
                return object;
            var message = new $root.Qot_GetBroker.S2C();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_GetBroker.S2C.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            if (object.brokerAskList) {
                if (!Array.isArray(object.brokerAskList))
                    throw TypeError(".Qot_GetBroker.S2C.brokerAskList: array expected");
                message.brokerAskList = [];
                for (var i = 0; i < object.brokerAskList.length; ++i) {
                    if (typeof object.brokerAskList[i] !== "object")
                        throw TypeError(".Qot_GetBroker.S2C.brokerAskList: object expected");
                    message.brokerAskList[i] = $root.Qot_Common.Broker.fromObject(object.brokerAskList[i]);
                }
            }
            if (object.brokerBidList) {
                if (!Array.isArray(object.brokerBidList))
                    throw TypeError(".Qot_GetBroker.S2C.brokerBidList: array expected");
                message.brokerBidList = [];
                for (var i = 0; i < object.brokerBidList.length; ++i) {
                    if (typeof object.brokerBidList[i] !== "object")
                        throw TypeError(".Qot_GetBroker.S2C.brokerBidList: object expected");
                    message.brokerBidList[i] = $root.Qot_Common.Broker.fromObject(object.brokerBidList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetBroker.S2C
         * @static
         * @param {Qot_GetBroker.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.brokerAskList = [];
                object.brokerBidList = [];
            }
            if (options.defaults)
                object.security = null;
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            if (message.brokerAskList && message.brokerAskList.length) {
                object.brokerAskList = [];
                for (var j = 0; j < message.brokerAskList.length; ++j)
                    object.brokerAskList[j] = $root.Qot_Common.Broker.toObject(message.brokerAskList[j], options);
            }
            if (message.brokerBidList && message.brokerBidList.length) {
                object.brokerBidList = [];
                for (var j = 0; j < message.brokerBidList.length; ++j)
                    object.brokerBidList[j] = $root.Qot_Common.Broker.toObject(message.brokerBidList[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_GetBroker.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_GetBroker.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Qot_GetBroker
         * @interface IRequest
         * @property {Qot_GetBroker.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Qot_GetBroker
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Qot_GetBroker.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Qot_GetBroker.IC2S} c2s
         * @memberof Qot_GetBroker.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Qot_GetBroker.Request
         * @static
         * @param {Qot_GetBroker.IRequest=} [properties] Properties to set
         * @returns {Qot_GetBroker.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Qot_GetBroker.Request.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetBroker.Request
         * @static
         * @param {Qot_GetBroker.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_GetBroker.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Qot_GetBroker.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetBroker.Request
         * @static
         * @param {Qot_GetBroker.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetBroker.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetBroker.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetBroker.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Qot_GetBroker.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetBroker.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetBroker.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Qot_GetBroker.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_GetBroker.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetBroker.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetBroker.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetBroker.Request)
                return object;
            var message = new $root.Qot_GetBroker.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Qot_GetBroker.Request.c2s: object expected");
                message.c2s = $root.Qot_GetBroker.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetBroker.Request
         * @static
         * @param {Qot_GetBroker.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Qot_GetBroker.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Qot_GetBroker.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Qot_GetBroker.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_GetBroker
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_GetBroker.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_GetBroker
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_GetBroker.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_GetBroker.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_GetBroker.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_GetBroker.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_GetBroker.IS2C|null|undefined} s2c
         * @memberof Qot_GetBroker.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_GetBroker.Response
         * @static
         * @param {Qot_GetBroker.IResponse=} [properties] Properties to set
         * @returns {Qot_GetBroker.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_GetBroker.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetBroker.Response
         * @static
         * @param {Qot_GetBroker.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_GetBroker.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_GetBroker.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetBroker.Response
         * @static
         * @param {Qot_GetBroker.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetBroker.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetBroker.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetBroker.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_GetBroker.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetBroker.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetBroker.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_GetBroker.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_GetBroker.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetBroker.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetBroker.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetBroker.Response)
                return object;
            var message = new $root.Qot_GetBroker.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_GetBroker.Response.s2c: object expected");
                message.s2c = $root.Qot_GetBroker.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetBroker.Response
         * @static
         * @param {Qot_GetBroker.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_GetBroker.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_GetBroker.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_GetBroker;
})();

$root.Qot_GetHistoryKL = (function() {

    /**
     * Namespace Qot_GetHistoryKL.
     * @exports Qot_GetHistoryKL
     * @namespace
     */
    var Qot_GetHistoryKL = {};

    Qot_GetHistoryKL.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Qot_GetHistoryKL
         * @interface IC2S
         * @property {number} rehabType C2S rehabType
         * @property {number} klType C2S klType
         * @property {Qot_Common.ISecurity} security C2S security
         * @property {string} beginTime C2S beginTime
         * @property {string} endTime C2S endTime
         * @property {number|null} [maxAckKLNum] C2S maxAckKLNum
         * @property {number|Long|null} [needKLFieldsFlag] C2S needKLFieldsFlag
         */

        /**
         * Constructs a new C2S.
         * @memberof Qot_GetHistoryKL
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Qot_GetHistoryKL.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S rehabType.
         * @member {number} rehabType
         * @memberof Qot_GetHistoryKL.C2S
         * @instance
         */
        C2S.prototype.rehabType = 0;

        /**
         * C2S klType.
         * @member {number} klType
         * @memberof Qot_GetHistoryKL.C2S
         * @instance
         */
        C2S.prototype.klType = 0;

        /**
         * C2S security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_GetHistoryKL.C2S
         * @instance
         */
        C2S.prototype.security = null;

        /**
         * C2S beginTime.
         * @member {string} beginTime
         * @memberof Qot_GetHistoryKL.C2S
         * @instance
         */
        C2S.prototype.beginTime = "";

        /**
         * C2S endTime.
         * @member {string} endTime
         * @memberof Qot_GetHistoryKL.C2S
         * @instance
         */
        C2S.prototype.endTime = "";

        /**
         * C2S maxAckKLNum.
         * @member {number} maxAckKLNum
         * @memberof Qot_GetHistoryKL.C2S
         * @instance
         */
        C2S.prototype.maxAckKLNum = 0;

        /**
         * C2S needKLFieldsFlag.
         * @member {number|Long} needKLFieldsFlag
         * @memberof Qot_GetHistoryKL.C2S
         * @instance
         */
        C2S.prototype.needKLFieldsFlag = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Qot_GetHistoryKL.C2S
         * @static
         * @param {Qot_GetHistoryKL.IC2S=} [properties] Properties to set
         * @returns {Qot_GetHistoryKL.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Qot_GetHistoryKL.C2S.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetHistoryKL.C2S
         * @static
         * @param {Qot_GetHistoryKL.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.rehabType);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.klType);
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.beginTime);
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.endTime);
            if (message.maxAckKLNum != null && message.hasOwnProperty("maxAckKLNum"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.maxAckKLNum);
            if (message.needKLFieldsFlag != null && message.hasOwnProperty("needKLFieldsFlag"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.needKLFieldsFlag);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Qot_GetHistoryKL.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetHistoryKL.C2S
         * @static
         * @param {Qot_GetHistoryKL.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetHistoryKL.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetHistoryKL.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetHistoryKL.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rehabType = reader.int32();
                    break;
                case 2:
                    message.klType = reader.int32();
                    break;
                case 3:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.beginTime = reader.string();
                    break;
                case 5:
                    message.endTime = reader.string();
                    break;
                case 6:
                    message.maxAckKLNum = reader.int32();
                    break;
                case 7:
                    message.needKLFieldsFlag = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("rehabType"))
                throw $util.ProtocolError("missing required 'rehabType'", { instance: message });
            if (!message.hasOwnProperty("klType"))
                throw $util.ProtocolError("missing required 'klType'", { instance: message });
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            if (!message.hasOwnProperty("beginTime"))
                throw $util.ProtocolError("missing required 'beginTime'", { instance: message });
            if (!message.hasOwnProperty("endTime"))
                throw $util.ProtocolError("missing required 'endTime'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetHistoryKL.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetHistoryKL.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Qot_GetHistoryKL.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.rehabType))
                return "rehabType: integer expected";
            if (!$util.isInteger(message.klType))
                return "klType: integer expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            if (!$util.isString(message.beginTime))
                return "beginTime: string expected";
            if (!$util.isString(message.endTime))
                return "endTime: string expected";
            if (message.maxAckKLNum != null && message.hasOwnProperty("maxAckKLNum"))
                if (!$util.isInteger(message.maxAckKLNum))
                    return "maxAckKLNum: integer expected";
            if (message.needKLFieldsFlag != null && message.hasOwnProperty("needKLFieldsFlag"))
                if (!$util.isInteger(message.needKLFieldsFlag) && !(message.needKLFieldsFlag && $util.isInteger(message.needKLFieldsFlag.low) && $util.isInteger(message.needKLFieldsFlag.high)))
                    return "needKLFieldsFlag: integer|Long expected";
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetHistoryKL.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetHistoryKL.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetHistoryKL.C2S)
                return object;
            var message = new $root.Qot_GetHistoryKL.C2S();
            if (object.rehabType != null)
                message.rehabType = object.rehabType | 0;
            if (object.klType != null)
                message.klType = object.klType | 0;
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_GetHistoryKL.C2S.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            if (object.beginTime != null)
                message.beginTime = String(object.beginTime);
            if (object.endTime != null)
                message.endTime = String(object.endTime);
            if (object.maxAckKLNum != null)
                message.maxAckKLNum = object.maxAckKLNum | 0;
            if (object.needKLFieldsFlag != null)
                if ($util.Long)
                    (message.needKLFieldsFlag = $util.Long.fromValue(object.needKLFieldsFlag)).unsigned = false;
                else if (typeof object.needKLFieldsFlag === "string")
                    message.needKLFieldsFlag = parseInt(object.needKLFieldsFlag, 10);
                else if (typeof object.needKLFieldsFlag === "number")
                    message.needKLFieldsFlag = object.needKLFieldsFlag;
                else if (typeof object.needKLFieldsFlag === "object")
                    message.needKLFieldsFlag = new $util.LongBits(object.needKLFieldsFlag.low >>> 0, object.needKLFieldsFlag.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetHistoryKL.C2S
         * @static
         * @param {Qot_GetHistoryKL.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.rehabType = 0;
                object.klType = 0;
                object.security = null;
                object.beginTime = "";
                object.endTime = "";
                object.maxAckKLNum = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.needKLFieldsFlag = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.needKLFieldsFlag = options.longs === String ? "0" : 0;
            }
            if (message.rehabType != null && message.hasOwnProperty("rehabType"))
                object.rehabType = message.rehabType;
            if (message.klType != null && message.hasOwnProperty("klType"))
                object.klType = message.klType;
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            if (message.beginTime != null && message.hasOwnProperty("beginTime"))
                object.beginTime = message.beginTime;
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                object.endTime = message.endTime;
            if (message.maxAckKLNum != null && message.hasOwnProperty("maxAckKLNum"))
                object.maxAckKLNum = message.maxAckKLNum;
            if (message.needKLFieldsFlag != null && message.hasOwnProperty("needKLFieldsFlag"))
                if (typeof message.needKLFieldsFlag === "number")
                    object.needKLFieldsFlag = options.longs === String ? String(message.needKLFieldsFlag) : message.needKLFieldsFlag;
                else
                    object.needKLFieldsFlag = options.longs === String ? $util.Long.prototype.toString.call(message.needKLFieldsFlag) : options.longs === Number ? new $util.LongBits(message.needKLFieldsFlag.low >>> 0, message.needKLFieldsFlag.high >>> 0).toNumber() : message.needKLFieldsFlag;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Qot_GetHistoryKL.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Qot_GetHistoryKL.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_GetHistoryKL
         * @interface IS2C
         * @property {Qot_Common.ISecurity} security S2C security
         * @property {Array.<Qot_Common.IKLine>|null} [klList] S2C klList
         * @property {string|null} [nextKLTime] S2C nextKLTime
         * @property {number|null} [nextKLTimestamp] S2C nextKLTimestamp
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_GetHistoryKL
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_GetHistoryKL.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.klList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_GetHistoryKL.S2C
         * @instance
         */
        S2C.prototype.security = null;

        /**
         * S2C klList.
         * @member {Array.<Qot_Common.IKLine>} klList
         * @memberof Qot_GetHistoryKL.S2C
         * @instance
         */
        S2C.prototype.klList = $util.emptyArray;

        /**
         * S2C nextKLTime.
         * @member {string} nextKLTime
         * @memberof Qot_GetHistoryKL.S2C
         * @instance
         */
        S2C.prototype.nextKLTime = "";

        /**
         * S2C nextKLTimestamp.
         * @member {number} nextKLTimestamp
         * @memberof Qot_GetHistoryKL.S2C
         * @instance
         */
        S2C.prototype.nextKLTimestamp = 0;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_GetHistoryKL.S2C
         * @static
         * @param {Qot_GetHistoryKL.IS2C=} [properties] Properties to set
         * @returns {Qot_GetHistoryKL.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_GetHistoryKL.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetHistoryKL.S2C
         * @static
         * @param {Qot_GetHistoryKL.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.klList != null && message.klList.length)
                for (var i = 0; i < message.klList.length; ++i)
                    $root.Qot_Common.KLine.encode(message.klList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.nextKLTime != null && message.hasOwnProperty("nextKLTime"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.nextKLTime);
            if (message.nextKLTimestamp != null && message.hasOwnProperty("nextKLTimestamp"))
                writer.uint32(/* id 4, wireType 1 =*/33).double(message.nextKLTimestamp);
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_GetHistoryKL.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetHistoryKL.S2C
         * @static
         * @param {Qot_GetHistoryKL.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetHistoryKL.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetHistoryKL.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetHistoryKL.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.klList && message.klList.length))
                        message.klList = [];
                    message.klList.push($root.Qot_Common.KLine.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.nextKLTime = reader.string();
                    break;
                case 4:
                    message.nextKLTimestamp = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetHistoryKL.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetHistoryKL.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_GetHistoryKL.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            if (message.klList != null && message.hasOwnProperty("klList")) {
                if (!Array.isArray(message.klList))
                    return "klList: array expected";
                for (var i = 0; i < message.klList.length; ++i) {
                    var error = $root.Qot_Common.KLine.verify(message.klList[i]);
                    if (error)
                        return "klList." + error;
                }
            }
            if (message.nextKLTime != null && message.hasOwnProperty("nextKLTime"))
                if (!$util.isString(message.nextKLTime))
                    return "nextKLTime: string expected";
            if (message.nextKLTimestamp != null && message.hasOwnProperty("nextKLTimestamp"))
                if (typeof message.nextKLTimestamp !== "number")
                    return "nextKLTimestamp: number expected";
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetHistoryKL.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetHistoryKL.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetHistoryKL.S2C)
                return object;
            var message = new $root.Qot_GetHistoryKL.S2C();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_GetHistoryKL.S2C.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            if (object.klList) {
                if (!Array.isArray(object.klList))
                    throw TypeError(".Qot_GetHistoryKL.S2C.klList: array expected");
                message.klList = [];
                for (var i = 0; i < object.klList.length; ++i) {
                    if (typeof object.klList[i] !== "object")
                        throw TypeError(".Qot_GetHistoryKL.S2C.klList: object expected");
                    message.klList[i] = $root.Qot_Common.KLine.fromObject(object.klList[i]);
                }
            }
            if (object.nextKLTime != null)
                message.nextKLTime = String(object.nextKLTime);
            if (object.nextKLTimestamp != null)
                message.nextKLTimestamp = Number(object.nextKLTimestamp);
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetHistoryKL.S2C
         * @static
         * @param {Qot_GetHistoryKL.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.klList = [];
            if (options.defaults) {
                object.security = null;
                object.nextKLTime = "";
                object.nextKLTimestamp = 0;
            }
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            if (message.klList && message.klList.length) {
                object.klList = [];
                for (var j = 0; j < message.klList.length; ++j)
                    object.klList[j] = $root.Qot_Common.KLine.toObject(message.klList[j], options);
            }
            if (message.nextKLTime != null && message.hasOwnProperty("nextKLTime"))
                object.nextKLTime = message.nextKLTime;
            if (message.nextKLTimestamp != null && message.hasOwnProperty("nextKLTimestamp"))
                object.nextKLTimestamp = options.json && !isFinite(message.nextKLTimestamp) ? String(message.nextKLTimestamp) : message.nextKLTimestamp;
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_GetHistoryKL.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_GetHistoryKL.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Qot_GetHistoryKL
         * @interface IRequest
         * @property {Qot_GetHistoryKL.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Qot_GetHistoryKL
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Qot_GetHistoryKL.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Qot_GetHistoryKL.IC2S} c2s
         * @memberof Qot_GetHistoryKL.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Qot_GetHistoryKL.Request
         * @static
         * @param {Qot_GetHistoryKL.IRequest=} [properties] Properties to set
         * @returns {Qot_GetHistoryKL.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Qot_GetHistoryKL.Request.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetHistoryKL.Request
         * @static
         * @param {Qot_GetHistoryKL.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_GetHistoryKL.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Qot_GetHistoryKL.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetHistoryKL.Request
         * @static
         * @param {Qot_GetHistoryKL.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetHistoryKL.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetHistoryKL.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetHistoryKL.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Qot_GetHistoryKL.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetHistoryKL.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetHistoryKL.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Qot_GetHistoryKL.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_GetHistoryKL.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetHistoryKL.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetHistoryKL.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetHistoryKL.Request)
                return object;
            var message = new $root.Qot_GetHistoryKL.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Qot_GetHistoryKL.Request.c2s: object expected");
                message.c2s = $root.Qot_GetHistoryKL.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetHistoryKL.Request
         * @static
         * @param {Qot_GetHistoryKL.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Qot_GetHistoryKL.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Qot_GetHistoryKL.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Qot_GetHistoryKL.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_GetHistoryKL
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_GetHistoryKL.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_GetHistoryKL
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_GetHistoryKL.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_GetHistoryKL.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_GetHistoryKL.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_GetHistoryKL.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_GetHistoryKL.IS2C|null|undefined} s2c
         * @memberof Qot_GetHistoryKL.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_GetHistoryKL.Response
         * @static
         * @param {Qot_GetHistoryKL.IResponse=} [properties] Properties to set
         * @returns {Qot_GetHistoryKL.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_GetHistoryKL.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetHistoryKL.Response
         * @static
         * @param {Qot_GetHistoryKL.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_GetHistoryKL.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_GetHistoryKL.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetHistoryKL.Response
         * @static
         * @param {Qot_GetHistoryKL.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetHistoryKL.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetHistoryKL.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetHistoryKL.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_GetHistoryKL.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetHistoryKL.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetHistoryKL.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_GetHistoryKL.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_GetHistoryKL.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetHistoryKL.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetHistoryKL.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetHistoryKL.Response)
                return object;
            var message = new $root.Qot_GetHistoryKL.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_GetHistoryKL.Response.s2c: object expected");
                message.s2c = $root.Qot_GetHistoryKL.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetHistoryKL.Response
         * @static
         * @param {Qot_GetHistoryKL.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_GetHistoryKL.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_GetHistoryKL.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_GetHistoryKL;
})();

$root.Qot_GetHistoryKLPoints = (function() {

    /**
     * Namespace Qot_GetHistoryKLPoints.
     * @exports Qot_GetHistoryKLPoints
     * @namespace
     */
    var Qot_GetHistoryKLPoints = {};

    /**
     * NoDataMode enum.
     * @name Qot_GetHistoryKLPoints.NoDataMode
     * @enum {string}
     * @property {number} NoDataMode_Null=0 NoDataMode_Null value
     * @property {number} NoDataMode_Forward=1 NoDataMode_Forward value
     * @property {number} NoDataMode_Backward=2 NoDataMode_Backward value
     */
    Qot_GetHistoryKLPoints.NoDataMode = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NoDataMode_Null"] = 0;
        values[valuesById[1] = "NoDataMode_Forward"] = 1;
        values[valuesById[2] = "NoDataMode_Backward"] = 2;
        return values;
    })();

    /**
     * DataStatus enum.
     * @name Qot_GetHistoryKLPoints.DataStatus
     * @enum {string}
     * @property {number} DataStatus_Null=0 DataStatus_Null value
     * @property {number} DataStatus_Current=1 DataStatus_Current value
     * @property {number} DataStatus_Previous=2 DataStatus_Previous value
     * @property {number} DataStatus_Back=3 DataStatus_Back value
     */
    Qot_GetHistoryKLPoints.DataStatus = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DataStatus_Null"] = 0;
        values[valuesById[1] = "DataStatus_Current"] = 1;
        values[valuesById[2] = "DataStatus_Previous"] = 2;
        values[valuesById[3] = "DataStatus_Back"] = 3;
        return values;
    })();

    Qot_GetHistoryKLPoints.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Qot_GetHistoryKLPoints
         * @interface IC2S
         * @property {number} rehabType C2S rehabType
         * @property {number} klType C2S klType
         * @property {number} noDataMode C2S noDataMode
         * @property {Array.<Qot_Common.ISecurity>|null} [securityList] C2S securityList
         * @property {Array.<string>|null} [timeList] C2S timeList
         * @property {number|null} [maxReqSecurityNum] C2S maxReqSecurityNum
         * @property {number|Long|null} [needKLFieldsFlag] C2S needKLFieldsFlag
         */

        /**
         * Constructs a new C2S.
         * @memberof Qot_GetHistoryKLPoints
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Qot_GetHistoryKLPoints.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            this.securityList = [];
            this.timeList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S rehabType.
         * @member {number} rehabType
         * @memberof Qot_GetHistoryKLPoints.C2S
         * @instance
         */
        C2S.prototype.rehabType = 0;

        /**
         * C2S klType.
         * @member {number} klType
         * @memberof Qot_GetHistoryKLPoints.C2S
         * @instance
         */
        C2S.prototype.klType = 0;

        /**
         * C2S noDataMode.
         * @member {number} noDataMode
         * @memberof Qot_GetHistoryKLPoints.C2S
         * @instance
         */
        C2S.prototype.noDataMode = 0;

        /**
         * C2S securityList.
         * @member {Array.<Qot_Common.ISecurity>} securityList
         * @memberof Qot_GetHistoryKLPoints.C2S
         * @instance
         */
        C2S.prototype.securityList = $util.emptyArray;

        /**
         * C2S timeList.
         * @member {Array.<string>} timeList
         * @memberof Qot_GetHistoryKLPoints.C2S
         * @instance
         */
        C2S.prototype.timeList = $util.emptyArray;

        /**
         * C2S maxReqSecurityNum.
         * @member {number} maxReqSecurityNum
         * @memberof Qot_GetHistoryKLPoints.C2S
         * @instance
         */
        C2S.prototype.maxReqSecurityNum = 0;

        /**
         * C2S needKLFieldsFlag.
         * @member {number|Long} needKLFieldsFlag
         * @memberof Qot_GetHistoryKLPoints.C2S
         * @instance
         */
        C2S.prototype.needKLFieldsFlag = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Qot_GetHistoryKLPoints.C2S
         * @static
         * @param {Qot_GetHistoryKLPoints.IC2S=} [properties] Properties to set
         * @returns {Qot_GetHistoryKLPoints.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Qot_GetHistoryKLPoints.C2S.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetHistoryKLPoints.C2S
         * @static
         * @param {Qot_GetHistoryKLPoints.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.rehabType);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.klType);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.noDataMode);
            if (message.securityList != null && message.securityList.length)
                for (var i = 0; i < message.securityList.length; ++i)
                    $root.Qot_Common.Security.encode(message.securityList[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.timeList != null && message.timeList.length)
                for (var i = 0; i < message.timeList.length; ++i)
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.timeList[i]);
            if (message.maxReqSecurityNum != null && message.hasOwnProperty("maxReqSecurityNum"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.maxReqSecurityNum);
            if (message.needKLFieldsFlag != null && message.hasOwnProperty("needKLFieldsFlag"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.needKLFieldsFlag);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Qot_GetHistoryKLPoints.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetHistoryKLPoints.C2S
         * @static
         * @param {Qot_GetHistoryKLPoints.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetHistoryKLPoints.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetHistoryKLPoints.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetHistoryKLPoints.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rehabType = reader.int32();
                    break;
                case 2:
                    message.klType = reader.int32();
                    break;
                case 3:
                    message.noDataMode = reader.int32();
                    break;
                case 4:
                    if (!(message.securityList && message.securityList.length))
                        message.securityList = [];
                    message.securityList.push($root.Qot_Common.Security.decode(reader, reader.uint32()));
                    break;
                case 5:
                    if (!(message.timeList && message.timeList.length))
                        message.timeList = [];
                    message.timeList.push(reader.string());
                    break;
                case 6:
                    message.maxReqSecurityNum = reader.int32();
                    break;
                case 7:
                    message.needKLFieldsFlag = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("rehabType"))
                throw $util.ProtocolError("missing required 'rehabType'", { instance: message });
            if (!message.hasOwnProperty("klType"))
                throw $util.ProtocolError("missing required 'klType'", { instance: message });
            if (!message.hasOwnProperty("noDataMode"))
                throw $util.ProtocolError("missing required 'noDataMode'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetHistoryKLPoints.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetHistoryKLPoints.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Qot_GetHistoryKLPoints.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.rehabType))
                return "rehabType: integer expected";
            if (!$util.isInteger(message.klType))
                return "klType: integer expected";
            if (!$util.isInteger(message.noDataMode))
                return "noDataMode: integer expected";
            if (message.securityList != null && message.hasOwnProperty("securityList")) {
                if (!Array.isArray(message.securityList))
                    return "securityList: array expected";
                for (var i = 0; i < message.securityList.length; ++i) {
                    var error = $root.Qot_Common.Security.verify(message.securityList[i]);
                    if (error)
                        return "securityList." + error;
                }
            }
            if (message.timeList != null && message.hasOwnProperty("timeList")) {
                if (!Array.isArray(message.timeList))
                    return "timeList: array expected";
                for (var i = 0; i < message.timeList.length; ++i)
                    if (!$util.isString(message.timeList[i]))
                        return "timeList: string[] expected";
            }
            if (message.maxReqSecurityNum != null && message.hasOwnProperty("maxReqSecurityNum"))
                if (!$util.isInteger(message.maxReqSecurityNum))
                    return "maxReqSecurityNum: integer expected";
            if (message.needKLFieldsFlag != null && message.hasOwnProperty("needKLFieldsFlag"))
                if (!$util.isInteger(message.needKLFieldsFlag) && !(message.needKLFieldsFlag && $util.isInteger(message.needKLFieldsFlag.low) && $util.isInteger(message.needKLFieldsFlag.high)))
                    return "needKLFieldsFlag: integer|Long expected";
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetHistoryKLPoints.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetHistoryKLPoints.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetHistoryKLPoints.C2S)
                return object;
            var message = new $root.Qot_GetHistoryKLPoints.C2S();
            if (object.rehabType != null)
                message.rehabType = object.rehabType | 0;
            if (object.klType != null)
                message.klType = object.klType | 0;
            if (object.noDataMode != null)
                message.noDataMode = object.noDataMode | 0;
            if (object.securityList) {
                if (!Array.isArray(object.securityList))
                    throw TypeError(".Qot_GetHistoryKLPoints.C2S.securityList: array expected");
                message.securityList = [];
                for (var i = 0; i < object.securityList.length; ++i) {
                    if (typeof object.securityList[i] !== "object")
                        throw TypeError(".Qot_GetHistoryKLPoints.C2S.securityList: object expected");
                    message.securityList[i] = $root.Qot_Common.Security.fromObject(object.securityList[i]);
                }
            }
            if (object.timeList) {
                if (!Array.isArray(object.timeList))
                    throw TypeError(".Qot_GetHistoryKLPoints.C2S.timeList: array expected");
                message.timeList = [];
                for (var i = 0; i < object.timeList.length; ++i)
                    message.timeList[i] = String(object.timeList[i]);
            }
            if (object.maxReqSecurityNum != null)
                message.maxReqSecurityNum = object.maxReqSecurityNum | 0;
            if (object.needKLFieldsFlag != null)
                if ($util.Long)
                    (message.needKLFieldsFlag = $util.Long.fromValue(object.needKLFieldsFlag)).unsigned = false;
                else if (typeof object.needKLFieldsFlag === "string")
                    message.needKLFieldsFlag = parseInt(object.needKLFieldsFlag, 10);
                else if (typeof object.needKLFieldsFlag === "number")
                    message.needKLFieldsFlag = object.needKLFieldsFlag;
                else if (typeof object.needKLFieldsFlag === "object")
                    message.needKLFieldsFlag = new $util.LongBits(object.needKLFieldsFlag.low >>> 0, object.needKLFieldsFlag.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetHistoryKLPoints.C2S
         * @static
         * @param {Qot_GetHistoryKLPoints.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.securityList = [];
                object.timeList = [];
            }
            if (options.defaults) {
                object.rehabType = 0;
                object.klType = 0;
                object.noDataMode = 0;
                object.maxReqSecurityNum = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.needKLFieldsFlag = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.needKLFieldsFlag = options.longs === String ? "0" : 0;
            }
            if (message.rehabType != null && message.hasOwnProperty("rehabType"))
                object.rehabType = message.rehabType;
            if (message.klType != null && message.hasOwnProperty("klType"))
                object.klType = message.klType;
            if (message.noDataMode != null && message.hasOwnProperty("noDataMode"))
                object.noDataMode = message.noDataMode;
            if (message.securityList && message.securityList.length) {
                object.securityList = [];
                for (var j = 0; j < message.securityList.length; ++j)
                    object.securityList[j] = $root.Qot_Common.Security.toObject(message.securityList[j], options);
            }
            if (message.timeList && message.timeList.length) {
                object.timeList = [];
                for (var j = 0; j < message.timeList.length; ++j)
                    object.timeList[j] = message.timeList[j];
            }
            if (message.maxReqSecurityNum != null && message.hasOwnProperty("maxReqSecurityNum"))
                object.maxReqSecurityNum = message.maxReqSecurityNum;
            if (message.needKLFieldsFlag != null && message.hasOwnProperty("needKLFieldsFlag"))
                if (typeof message.needKLFieldsFlag === "number")
                    object.needKLFieldsFlag = options.longs === String ? String(message.needKLFieldsFlag) : message.needKLFieldsFlag;
                else
                    object.needKLFieldsFlag = options.longs === String ? $util.Long.prototype.toString.call(message.needKLFieldsFlag) : options.longs === Number ? new $util.LongBits(message.needKLFieldsFlag.low >>> 0, message.needKLFieldsFlag.high >>> 0).toNumber() : message.needKLFieldsFlag;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Qot_GetHistoryKLPoints.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Qot_GetHistoryKLPoints.HistoryPointsKL = (function() {

        /**
         * Properties of a HistoryPointsKL.
         * @memberof Qot_GetHistoryKLPoints
         * @interface IHistoryPointsKL
         * @property {number} status HistoryPointsKL status
         * @property {string} reqTime HistoryPointsKL reqTime
         * @property {Qot_Common.IKLine} kl HistoryPointsKL kl
         */

        /**
         * Constructs a new HistoryPointsKL.
         * @memberof Qot_GetHistoryKLPoints
         * @classdesc Represents a HistoryPointsKL.
         * @implements IHistoryPointsKL
         * @constructor
         * @param {Qot_GetHistoryKLPoints.IHistoryPointsKL=} [properties] Properties to set
         */
        function HistoryPointsKL(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HistoryPointsKL status.
         * @member {number} status
         * @memberof Qot_GetHistoryKLPoints.HistoryPointsKL
         * @instance
         */
        HistoryPointsKL.prototype.status = 0;

        /**
         * HistoryPointsKL reqTime.
         * @member {string} reqTime
         * @memberof Qot_GetHistoryKLPoints.HistoryPointsKL
         * @instance
         */
        HistoryPointsKL.prototype.reqTime = "";

        /**
         * HistoryPointsKL kl.
         * @member {Qot_Common.IKLine} kl
         * @memberof Qot_GetHistoryKLPoints.HistoryPointsKL
         * @instance
         */
        HistoryPointsKL.prototype.kl = null;

        /**
         * Creates a new HistoryPointsKL instance using the specified properties.
         * @function create
         * @memberof Qot_GetHistoryKLPoints.HistoryPointsKL
         * @static
         * @param {Qot_GetHistoryKLPoints.IHistoryPointsKL=} [properties] Properties to set
         * @returns {Qot_GetHistoryKLPoints.HistoryPointsKL} HistoryPointsKL instance
         */
        HistoryPointsKL.create = function create(properties) {
            return new HistoryPointsKL(properties);
        };

        /**
         * Encodes the specified HistoryPointsKL message. Does not implicitly {@link Qot_GetHistoryKLPoints.HistoryPointsKL.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetHistoryKLPoints.HistoryPointsKL
         * @static
         * @param {Qot_GetHistoryKLPoints.IHistoryPointsKL} message HistoryPointsKL message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HistoryPointsKL.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.reqTime);
            $root.Qot_Common.KLine.encode(message.kl, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified HistoryPointsKL message, length delimited. Does not implicitly {@link Qot_GetHistoryKLPoints.HistoryPointsKL.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetHistoryKLPoints.HistoryPointsKL
         * @static
         * @param {Qot_GetHistoryKLPoints.IHistoryPointsKL} message HistoryPointsKL message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HistoryPointsKL.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HistoryPointsKL message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetHistoryKLPoints.HistoryPointsKL
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetHistoryKLPoints.HistoryPointsKL} HistoryPointsKL
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HistoryPointsKL.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetHistoryKLPoints.HistoryPointsKL();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.status = reader.int32();
                    break;
                case 2:
                    message.reqTime = reader.string();
                    break;
                case 3:
                    message.kl = $root.Qot_Common.KLine.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("status"))
                throw $util.ProtocolError("missing required 'status'", { instance: message });
            if (!message.hasOwnProperty("reqTime"))
                throw $util.ProtocolError("missing required 'reqTime'", { instance: message });
            if (!message.hasOwnProperty("kl"))
                throw $util.ProtocolError("missing required 'kl'", { instance: message });
            return message;
        };

        /**
         * Decodes a HistoryPointsKL message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetHistoryKLPoints.HistoryPointsKL
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetHistoryKLPoints.HistoryPointsKL} HistoryPointsKL
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HistoryPointsKL.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HistoryPointsKL message.
         * @function verify
         * @memberof Qot_GetHistoryKLPoints.HistoryPointsKL
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HistoryPointsKL.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.status))
                return "status: integer expected";
            if (!$util.isString(message.reqTime))
                return "reqTime: string expected";
            {
                var error = $root.Qot_Common.KLine.verify(message.kl);
                if (error)
                    return "kl." + error;
            }
            return null;
        };

        /**
         * Creates a HistoryPointsKL message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetHistoryKLPoints.HistoryPointsKL
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetHistoryKLPoints.HistoryPointsKL} HistoryPointsKL
         */
        HistoryPointsKL.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetHistoryKLPoints.HistoryPointsKL)
                return object;
            var message = new $root.Qot_GetHistoryKLPoints.HistoryPointsKL();
            if (object.status != null)
                message.status = object.status | 0;
            if (object.reqTime != null)
                message.reqTime = String(object.reqTime);
            if (object.kl != null) {
                if (typeof object.kl !== "object")
                    throw TypeError(".Qot_GetHistoryKLPoints.HistoryPointsKL.kl: object expected");
                message.kl = $root.Qot_Common.KLine.fromObject(object.kl);
            }
            return message;
        };

        /**
         * Creates a plain object from a HistoryPointsKL message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetHistoryKLPoints.HistoryPointsKL
         * @static
         * @param {Qot_GetHistoryKLPoints.HistoryPointsKL} message HistoryPointsKL
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HistoryPointsKL.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.status = 0;
                object.reqTime = "";
                object.kl = null;
            }
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = message.status;
            if (message.reqTime != null && message.hasOwnProperty("reqTime"))
                object.reqTime = message.reqTime;
            if (message.kl != null && message.hasOwnProperty("kl"))
                object.kl = $root.Qot_Common.KLine.toObject(message.kl, options);
            return object;
        };

        /**
         * Converts this HistoryPointsKL to JSON.
         * @function toJSON
         * @memberof Qot_GetHistoryKLPoints.HistoryPointsKL
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HistoryPointsKL.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HistoryPointsKL;
    })();

    Qot_GetHistoryKLPoints.SecurityHistoryKLPoints = (function() {

        /**
         * Properties of a SecurityHistoryKLPoints.
         * @memberof Qot_GetHistoryKLPoints
         * @interface ISecurityHistoryKLPoints
         * @property {Qot_Common.ISecurity} security SecurityHistoryKLPoints security
         * @property {Array.<Qot_GetHistoryKLPoints.IHistoryPointsKL>|null} [klList] SecurityHistoryKLPoints klList
         */

        /**
         * Constructs a new SecurityHistoryKLPoints.
         * @memberof Qot_GetHistoryKLPoints
         * @classdesc Represents a SecurityHistoryKLPoints.
         * @implements ISecurityHistoryKLPoints
         * @constructor
         * @param {Qot_GetHistoryKLPoints.ISecurityHistoryKLPoints=} [properties] Properties to set
         */
        function SecurityHistoryKLPoints(properties) {
            this.klList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SecurityHistoryKLPoints security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_GetHistoryKLPoints.SecurityHistoryKLPoints
         * @instance
         */
        SecurityHistoryKLPoints.prototype.security = null;

        /**
         * SecurityHistoryKLPoints klList.
         * @member {Array.<Qot_GetHistoryKLPoints.IHistoryPointsKL>} klList
         * @memberof Qot_GetHistoryKLPoints.SecurityHistoryKLPoints
         * @instance
         */
        SecurityHistoryKLPoints.prototype.klList = $util.emptyArray;

        /**
         * Creates a new SecurityHistoryKLPoints instance using the specified properties.
         * @function create
         * @memberof Qot_GetHistoryKLPoints.SecurityHistoryKLPoints
         * @static
         * @param {Qot_GetHistoryKLPoints.ISecurityHistoryKLPoints=} [properties] Properties to set
         * @returns {Qot_GetHistoryKLPoints.SecurityHistoryKLPoints} SecurityHistoryKLPoints instance
         */
        SecurityHistoryKLPoints.create = function create(properties) {
            return new SecurityHistoryKLPoints(properties);
        };

        /**
         * Encodes the specified SecurityHistoryKLPoints message. Does not implicitly {@link Qot_GetHistoryKLPoints.SecurityHistoryKLPoints.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetHistoryKLPoints.SecurityHistoryKLPoints
         * @static
         * @param {Qot_GetHistoryKLPoints.ISecurityHistoryKLPoints} message SecurityHistoryKLPoints message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SecurityHistoryKLPoints.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.klList != null && message.klList.length)
                for (var i = 0; i < message.klList.length; ++i)
                    $root.Qot_GetHistoryKLPoints.HistoryPointsKL.encode(message.klList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SecurityHistoryKLPoints message, length delimited. Does not implicitly {@link Qot_GetHistoryKLPoints.SecurityHistoryKLPoints.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetHistoryKLPoints.SecurityHistoryKLPoints
         * @static
         * @param {Qot_GetHistoryKLPoints.ISecurityHistoryKLPoints} message SecurityHistoryKLPoints message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SecurityHistoryKLPoints.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SecurityHistoryKLPoints message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetHistoryKLPoints.SecurityHistoryKLPoints
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetHistoryKLPoints.SecurityHistoryKLPoints} SecurityHistoryKLPoints
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SecurityHistoryKLPoints.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetHistoryKLPoints.SecurityHistoryKLPoints();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.klList && message.klList.length))
                        message.klList = [];
                    message.klList.push($root.Qot_GetHistoryKLPoints.HistoryPointsKL.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            return message;
        };

        /**
         * Decodes a SecurityHistoryKLPoints message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetHistoryKLPoints.SecurityHistoryKLPoints
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetHistoryKLPoints.SecurityHistoryKLPoints} SecurityHistoryKLPoints
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SecurityHistoryKLPoints.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SecurityHistoryKLPoints message.
         * @function verify
         * @memberof Qot_GetHistoryKLPoints.SecurityHistoryKLPoints
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SecurityHistoryKLPoints.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            if (message.klList != null && message.hasOwnProperty("klList")) {
                if (!Array.isArray(message.klList))
                    return "klList: array expected";
                for (var i = 0; i < message.klList.length; ++i) {
                    var error = $root.Qot_GetHistoryKLPoints.HistoryPointsKL.verify(message.klList[i]);
                    if (error)
                        return "klList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a SecurityHistoryKLPoints message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetHistoryKLPoints.SecurityHistoryKLPoints
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetHistoryKLPoints.SecurityHistoryKLPoints} SecurityHistoryKLPoints
         */
        SecurityHistoryKLPoints.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetHistoryKLPoints.SecurityHistoryKLPoints)
                return object;
            var message = new $root.Qot_GetHistoryKLPoints.SecurityHistoryKLPoints();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_GetHistoryKLPoints.SecurityHistoryKLPoints.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            if (object.klList) {
                if (!Array.isArray(object.klList))
                    throw TypeError(".Qot_GetHistoryKLPoints.SecurityHistoryKLPoints.klList: array expected");
                message.klList = [];
                for (var i = 0; i < object.klList.length; ++i) {
                    if (typeof object.klList[i] !== "object")
                        throw TypeError(".Qot_GetHistoryKLPoints.SecurityHistoryKLPoints.klList: object expected");
                    message.klList[i] = $root.Qot_GetHistoryKLPoints.HistoryPointsKL.fromObject(object.klList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a SecurityHistoryKLPoints message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetHistoryKLPoints.SecurityHistoryKLPoints
         * @static
         * @param {Qot_GetHistoryKLPoints.SecurityHistoryKLPoints} message SecurityHistoryKLPoints
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SecurityHistoryKLPoints.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.klList = [];
            if (options.defaults)
                object.security = null;
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            if (message.klList && message.klList.length) {
                object.klList = [];
                for (var j = 0; j < message.klList.length; ++j)
                    object.klList[j] = $root.Qot_GetHistoryKLPoints.HistoryPointsKL.toObject(message.klList[j], options);
            }
            return object;
        };

        /**
         * Converts this SecurityHistoryKLPoints to JSON.
         * @function toJSON
         * @memberof Qot_GetHistoryKLPoints.SecurityHistoryKLPoints
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SecurityHistoryKLPoints.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SecurityHistoryKLPoints;
    })();

    Qot_GetHistoryKLPoints.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_GetHistoryKLPoints
         * @interface IS2C
         * @property {Array.<Qot_GetHistoryKLPoints.ISecurityHistoryKLPoints>|null} [klPointList] S2C klPointList
         * @property {boolean|null} [hasNext] S2C hasNext
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_GetHistoryKLPoints
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_GetHistoryKLPoints.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.klPointList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C klPointList.
         * @member {Array.<Qot_GetHistoryKLPoints.ISecurityHistoryKLPoints>} klPointList
         * @memberof Qot_GetHistoryKLPoints.S2C
         * @instance
         */
        S2C.prototype.klPointList = $util.emptyArray;

        /**
         * S2C hasNext.
         * @member {boolean} hasNext
         * @memberof Qot_GetHistoryKLPoints.S2C
         * @instance
         */
        S2C.prototype.hasNext = false;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_GetHistoryKLPoints.S2C
         * @static
         * @param {Qot_GetHistoryKLPoints.IS2C=} [properties] Properties to set
         * @returns {Qot_GetHistoryKLPoints.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_GetHistoryKLPoints.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetHistoryKLPoints.S2C
         * @static
         * @param {Qot_GetHistoryKLPoints.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.klPointList != null && message.klPointList.length)
                for (var i = 0; i < message.klPointList.length; ++i)
                    $root.Qot_GetHistoryKLPoints.SecurityHistoryKLPoints.encode(message.klPointList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.hasNext != null && message.hasOwnProperty("hasNext"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.hasNext);
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_GetHistoryKLPoints.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetHistoryKLPoints.S2C
         * @static
         * @param {Qot_GetHistoryKLPoints.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetHistoryKLPoints.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetHistoryKLPoints.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetHistoryKLPoints.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.klPointList && message.klPointList.length))
                        message.klPointList = [];
                    message.klPointList.push($root.Qot_GetHistoryKLPoints.SecurityHistoryKLPoints.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.hasNext = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetHistoryKLPoints.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetHistoryKLPoints.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_GetHistoryKLPoints.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.klPointList != null && message.hasOwnProperty("klPointList")) {
                if (!Array.isArray(message.klPointList))
                    return "klPointList: array expected";
                for (var i = 0; i < message.klPointList.length; ++i) {
                    var error = $root.Qot_GetHistoryKLPoints.SecurityHistoryKLPoints.verify(message.klPointList[i]);
                    if (error)
                        return "klPointList." + error;
                }
            }
            if (message.hasNext != null && message.hasOwnProperty("hasNext"))
                if (typeof message.hasNext !== "boolean")
                    return "hasNext: boolean expected";
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetHistoryKLPoints.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetHistoryKLPoints.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetHistoryKLPoints.S2C)
                return object;
            var message = new $root.Qot_GetHistoryKLPoints.S2C();
            if (object.klPointList) {
                if (!Array.isArray(object.klPointList))
                    throw TypeError(".Qot_GetHistoryKLPoints.S2C.klPointList: array expected");
                message.klPointList = [];
                for (var i = 0; i < object.klPointList.length; ++i) {
                    if (typeof object.klPointList[i] !== "object")
                        throw TypeError(".Qot_GetHistoryKLPoints.S2C.klPointList: object expected");
                    message.klPointList[i] = $root.Qot_GetHistoryKLPoints.SecurityHistoryKLPoints.fromObject(object.klPointList[i]);
                }
            }
            if (object.hasNext != null)
                message.hasNext = Boolean(object.hasNext);
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetHistoryKLPoints.S2C
         * @static
         * @param {Qot_GetHistoryKLPoints.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.klPointList = [];
            if (options.defaults)
                object.hasNext = false;
            if (message.klPointList && message.klPointList.length) {
                object.klPointList = [];
                for (var j = 0; j < message.klPointList.length; ++j)
                    object.klPointList[j] = $root.Qot_GetHistoryKLPoints.SecurityHistoryKLPoints.toObject(message.klPointList[j], options);
            }
            if (message.hasNext != null && message.hasOwnProperty("hasNext"))
                object.hasNext = message.hasNext;
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_GetHistoryKLPoints.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_GetHistoryKLPoints.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Qot_GetHistoryKLPoints
         * @interface IRequest
         * @property {Qot_GetHistoryKLPoints.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Qot_GetHistoryKLPoints
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Qot_GetHistoryKLPoints.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Qot_GetHistoryKLPoints.IC2S} c2s
         * @memberof Qot_GetHistoryKLPoints.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Qot_GetHistoryKLPoints.Request
         * @static
         * @param {Qot_GetHistoryKLPoints.IRequest=} [properties] Properties to set
         * @returns {Qot_GetHistoryKLPoints.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Qot_GetHistoryKLPoints.Request.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetHistoryKLPoints.Request
         * @static
         * @param {Qot_GetHistoryKLPoints.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_GetHistoryKLPoints.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Qot_GetHistoryKLPoints.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetHistoryKLPoints.Request
         * @static
         * @param {Qot_GetHistoryKLPoints.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetHistoryKLPoints.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetHistoryKLPoints.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetHistoryKLPoints.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Qot_GetHistoryKLPoints.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetHistoryKLPoints.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetHistoryKLPoints.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Qot_GetHistoryKLPoints.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_GetHistoryKLPoints.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetHistoryKLPoints.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetHistoryKLPoints.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetHistoryKLPoints.Request)
                return object;
            var message = new $root.Qot_GetHistoryKLPoints.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Qot_GetHistoryKLPoints.Request.c2s: object expected");
                message.c2s = $root.Qot_GetHistoryKLPoints.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetHistoryKLPoints.Request
         * @static
         * @param {Qot_GetHistoryKLPoints.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Qot_GetHistoryKLPoints.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Qot_GetHistoryKLPoints.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Qot_GetHistoryKLPoints.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_GetHistoryKLPoints
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_GetHistoryKLPoints.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_GetHistoryKLPoints
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_GetHistoryKLPoints.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_GetHistoryKLPoints.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_GetHistoryKLPoints.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_GetHistoryKLPoints.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_GetHistoryKLPoints.IS2C|null|undefined} s2c
         * @memberof Qot_GetHistoryKLPoints.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_GetHistoryKLPoints.Response
         * @static
         * @param {Qot_GetHistoryKLPoints.IResponse=} [properties] Properties to set
         * @returns {Qot_GetHistoryKLPoints.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_GetHistoryKLPoints.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetHistoryKLPoints.Response
         * @static
         * @param {Qot_GetHistoryKLPoints.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_GetHistoryKLPoints.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_GetHistoryKLPoints.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetHistoryKLPoints.Response
         * @static
         * @param {Qot_GetHistoryKLPoints.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetHistoryKLPoints.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetHistoryKLPoints.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetHistoryKLPoints.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_GetHistoryKLPoints.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetHistoryKLPoints.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetHistoryKLPoints.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_GetHistoryKLPoints.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_GetHistoryKLPoints.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetHistoryKLPoints.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetHistoryKLPoints.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetHistoryKLPoints.Response)
                return object;
            var message = new $root.Qot_GetHistoryKLPoints.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_GetHistoryKLPoints.Response.s2c: object expected");
                message.s2c = $root.Qot_GetHistoryKLPoints.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetHistoryKLPoints.Response
         * @static
         * @param {Qot_GetHistoryKLPoints.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_GetHistoryKLPoints.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_GetHistoryKLPoints.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_GetHistoryKLPoints;
})();

$root.Qot_GetHoldingChangeList = (function() {

    /**
     * Namespace Qot_GetHoldingChangeList.
     * @exports Qot_GetHoldingChangeList
     * @namespace
     */
    var Qot_GetHoldingChangeList = {};

    Qot_GetHoldingChangeList.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Qot_GetHoldingChangeList
         * @interface IC2S
         * @property {Qot_Common.ISecurity} security C2S security
         * @property {number} holderCategory C2S holderCategory
         * @property {string|null} [beginTime] C2S beginTime
         * @property {string|null} [endTime] C2S endTime
         */

        /**
         * Constructs a new C2S.
         * @memberof Qot_GetHoldingChangeList
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Qot_GetHoldingChangeList.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_GetHoldingChangeList.C2S
         * @instance
         */
        C2S.prototype.security = null;

        /**
         * C2S holderCategory.
         * @member {number} holderCategory
         * @memberof Qot_GetHoldingChangeList.C2S
         * @instance
         */
        C2S.prototype.holderCategory = 0;

        /**
         * C2S beginTime.
         * @member {string} beginTime
         * @memberof Qot_GetHoldingChangeList.C2S
         * @instance
         */
        C2S.prototype.beginTime = "";

        /**
         * C2S endTime.
         * @member {string} endTime
         * @memberof Qot_GetHoldingChangeList.C2S
         * @instance
         */
        C2S.prototype.endTime = "";

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Qot_GetHoldingChangeList.C2S
         * @static
         * @param {Qot_GetHoldingChangeList.IC2S=} [properties] Properties to set
         * @returns {Qot_GetHoldingChangeList.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Qot_GetHoldingChangeList.C2S.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetHoldingChangeList.C2S
         * @static
         * @param {Qot_GetHoldingChangeList.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.holderCategory);
            if (message.beginTime != null && message.hasOwnProperty("beginTime"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.beginTime);
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.endTime);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Qot_GetHoldingChangeList.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetHoldingChangeList.C2S
         * @static
         * @param {Qot_GetHoldingChangeList.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetHoldingChangeList.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetHoldingChangeList.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetHoldingChangeList.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.holderCategory = reader.int32();
                    break;
                case 3:
                    message.beginTime = reader.string();
                    break;
                case 4:
                    message.endTime = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            if (!message.hasOwnProperty("holderCategory"))
                throw $util.ProtocolError("missing required 'holderCategory'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetHoldingChangeList.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetHoldingChangeList.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Qot_GetHoldingChangeList.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            if (!$util.isInteger(message.holderCategory))
                return "holderCategory: integer expected";
            if (message.beginTime != null && message.hasOwnProperty("beginTime"))
                if (!$util.isString(message.beginTime))
                    return "beginTime: string expected";
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                if (!$util.isString(message.endTime))
                    return "endTime: string expected";
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetHoldingChangeList.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetHoldingChangeList.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetHoldingChangeList.C2S)
                return object;
            var message = new $root.Qot_GetHoldingChangeList.C2S();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_GetHoldingChangeList.C2S.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            if (object.holderCategory != null)
                message.holderCategory = object.holderCategory | 0;
            if (object.beginTime != null)
                message.beginTime = String(object.beginTime);
            if (object.endTime != null)
                message.endTime = String(object.endTime);
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetHoldingChangeList.C2S
         * @static
         * @param {Qot_GetHoldingChangeList.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.security = null;
                object.holderCategory = 0;
                object.beginTime = "";
                object.endTime = "";
            }
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            if (message.holderCategory != null && message.hasOwnProperty("holderCategory"))
                object.holderCategory = message.holderCategory;
            if (message.beginTime != null && message.hasOwnProperty("beginTime"))
                object.beginTime = message.beginTime;
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                object.endTime = message.endTime;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Qot_GetHoldingChangeList.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Qot_GetHoldingChangeList.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_GetHoldingChangeList
         * @interface IS2C
         * @property {Qot_Common.ISecurity} security S2C security
         * @property {Array.<Qot_Common.IShareHoldingChange>|null} [holdingChangeList] S2C holdingChangeList
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_GetHoldingChangeList
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_GetHoldingChangeList.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.holdingChangeList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_GetHoldingChangeList.S2C
         * @instance
         */
        S2C.prototype.security = null;

        /**
         * S2C holdingChangeList.
         * @member {Array.<Qot_Common.IShareHoldingChange>} holdingChangeList
         * @memberof Qot_GetHoldingChangeList.S2C
         * @instance
         */
        S2C.prototype.holdingChangeList = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_GetHoldingChangeList.S2C
         * @static
         * @param {Qot_GetHoldingChangeList.IS2C=} [properties] Properties to set
         * @returns {Qot_GetHoldingChangeList.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_GetHoldingChangeList.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetHoldingChangeList.S2C
         * @static
         * @param {Qot_GetHoldingChangeList.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.holdingChangeList != null && message.holdingChangeList.length)
                for (var i = 0; i < message.holdingChangeList.length; ++i)
                    $root.Qot_Common.ShareHoldingChange.encode(message.holdingChangeList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_GetHoldingChangeList.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetHoldingChangeList.S2C
         * @static
         * @param {Qot_GetHoldingChangeList.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetHoldingChangeList.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetHoldingChangeList.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetHoldingChangeList.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.holdingChangeList && message.holdingChangeList.length))
                        message.holdingChangeList = [];
                    message.holdingChangeList.push($root.Qot_Common.ShareHoldingChange.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetHoldingChangeList.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetHoldingChangeList.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_GetHoldingChangeList.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            if (message.holdingChangeList != null && message.hasOwnProperty("holdingChangeList")) {
                if (!Array.isArray(message.holdingChangeList))
                    return "holdingChangeList: array expected";
                for (var i = 0; i < message.holdingChangeList.length; ++i) {
                    var error = $root.Qot_Common.ShareHoldingChange.verify(message.holdingChangeList[i]);
                    if (error)
                        return "holdingChangeList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetHoldingChangeList.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetHoldingChangeList.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetHoldingChangeList.S2C)
                return object;
            var message = new $root.Qot_GetHoldingChangeList.S2C();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_GetHoldingChangeList.S2C.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            if (object.holdingChangeList) {
                if (!Array.isArray(object.holdingChangeList))
                    throw TypeError(".Qot_GetHoldingChangeList.S2C.holdingChangeList: array expected");
                message.holdingChangeList = [];
                for (var i = 0; i < object.holdingChangeList.length; ++i) {
                    if (typeof object.holdingChangeList[i] !== "object")
                        throw TypeError(".Qot_GetHoldingChangeList.S2C.holdingChangeList: object expected");
                    message.holdingChangeList[i] = $root.Qot_Common.ShareHoldingChange.fromObject(object.holdingChangeList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetHoldingChangeList.S2C
         * @static
         * @param {Qot_GetHoldingChangeList.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.holdingChangeList = [];
            if (options.defaults)
                object.security = null;
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            if (message.holdingChangeList && message.holdingChangeList.length) {
                object.holdingChangeList = [];
                for (var j = 0; j < message.holdingChangeList.length; ++j)
                    object.holdingChangeList[j] = $root.Qot_Common.ShareHoldingChange.toObject(message.holdingChangeList[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_GetHoldingChangeList.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_GetHoldingChangeList.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Qot_GetHoldingChangeList
         * @interface IRequest
         * @property {Qot_GetHoldingChangeList.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Qot_GetHoldingChangeList
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Qot_GetHoldingChangeList.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Qot_GetHoldingChangeList.IC2S} c2s
         * @memberof Qot_GetHoldingChangeList.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Qot_GetHoldingChangeList.Request
         * @static
         * @param {Qot_GetHoldingChangeList.IRequest=} [properties] Properties to set
         * @returns {Qot_GetHoldingChangeList.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Qot_GetHoldingChangeList.Request.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetHoldingChangeList.Request
         * @static
         * @param {Qot_GetHoldingChangeList.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_GetHoldingChangeList.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Qot_GetHoldingChangeList.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetHoldingChangeList.Request
         * @static
         * @param {Qot_GetHoldingChangeList.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetHoldingChangeList.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetHoldingChangeList.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetHoldingChangeList.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Qot_GetHoldingChangeList.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetHoldingChangeList.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetHoldingChangeList.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Qot_GetHoldingChangeList.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_GetHoldingChangeList.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetHoldingChangeList.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetHoldingChangeList.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetHoldingChangeList.Request)
                return object;
            var message = new $root.Qot_GetHoldingChangeList.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Qot_GetHoldingChangeList.Request.c2s: object expected");
                message.c2s = $root.Qot_GetHoldingChangeList.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetHoldingChangeList.Request
         * @static
         * @param {Qot_GetHoldingChangeList.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Qot_GetHoldingChangeList.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Qot_GetHoldingChangeList.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Qot_GetHoldingChangeList.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_GetHoldingChangeList
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_GetHoldingChangeList.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_GetHoldingChangeList
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_GetHoldingChangeList.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_GetHoldingChangeList.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_GetHoldingChangeList.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_GetHoldingChangeList.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_GetHoldingChangeList.IS2C|null|undefined} s2c
         * @memberof Qot_GetHoldingChangeList.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_GetHoldingChangeList.Response
         * @static
         * @param {Qot_GetHoldingChangeList.IResponse=} [properties] Properties to set
         * @returns {Qot_GetHoldingChangeList.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_GetHoldingChangeList.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetHoldingChangeList.Response
         * @static
         * @param {Qot_GetHoldingChangeList.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_GetHoldingChangeList.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_GetHoldingChangeList.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetHoldingChangeList.Response
         * @static
         * @param {Qot_GetHoldingChangeList.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetHoldingChangeList.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetHoldingChangeList.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetHoldingChangeList.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_GetHoldingChangeList.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetHoldingChangeList.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetHoldingChangeList.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_GetHoldingChangeList.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_GetHoldingChangeList.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetHoldingChangeList.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetHoldingChangeList.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetHoldingChangeList.Response)
                return object;
            var message = new $root.Qot_GetHoldingChangeList.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_GetHoldingChangeList.Response.s2c: object expected");
                message.s2c = $root.Qot_GetHoldingChangeList.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetHoldingChangeList.Response
         * @static
         * @param {Qot_GetHoldingChangeList.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_GetHoldingChangeList.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_GetHoldingChangeList.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_GetHoldingChangeList;
})();

$root.Qot_GetKL = (function() {

    /**
     * Namespace Qot_GetKL.
     * @exports Qot_GetKL
     * @namespace
     */
    var Qot_GetKL = {};

    Qot_GetKL.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Qot_GetKL
         * @interface IC2S
         * @property {number} rehabType C2S rehabType
         * @property {number} klType C2S klType
         * @property {Qot_Common.ISecurity} security C2S security
         * @property {number} reqNum C2S reqNum
         */

        /**
         * Constructs a new C2S.
         * @memberof Qot_GetKL
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Qot_GetKL.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S rehabType.
         * @member {number} rehabType
         * @memberof Qot_GetKL.C2S
         * @instance
         */
        C2S.prototype.rehabType = 0;

        /**
         * C2S klType.
         * @member {number} klType
         * @memberof Qot_GetKL.C2S
         * @instance
         */
        C2S.prototype.klType = 0;

        /**
         * C2S security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_GetKL.C2S
         * @instance
         */
        C2S.prototype.security = null;

        /**
         * C2S reqNum.
         * @member {number} reqNum
         * @memberof Qot_GetKL.C2S
         * @instance
         */
        C2S.prototype.reqNum = 0;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Qot_GetKL.C2S
         * @static
         * @param {Qot_GetKL.IC2S=} [properties] Properties to set
         * @returns {Qot_GetKL.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Qot_GetKL.C2S.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetKL.C2S
         * @static
         * @param {Qot_GetKL.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.rehabType);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.klType);
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.reqNum);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Qot_GetKL.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetKL.C2S
         * @static
         * @param {Qot_GetKL.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetKL.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetKL.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetKL.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rehabType = reader.int32();
                    break;
                case 2:
                    message.klType = reader.int32();
                    break;
                case 3:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.reqNum = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("rehabType"))
                throw $util.ProtocolError("missing required 'rehabType'", { instance: message });
            if (!message.hasOwnProperty("klType"))
                throw $util.ProtocolError("missing required 'klType'", { instance: message });
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            if (!message.hasOwnProperty("reqNum"))
                throw $util.ProtocolError("missing required 'reqNum'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetKL.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetKL.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Qot_GetKL.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.rehabType))
                return "rehabType: integer expected";
            if (!$util.isInteger(message.klType))
                return "klType: integer expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            if (!$util.isInteger(message.reqNum))
                return "reqNum: integer expected";
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetKL.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetKL.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetKL.C2S)
                return object;
            var message = new $root.Qot_GetKL.C2S();
            if (object.rehabType != null)
                message.rehabType = object.rehabType | 0;
            if (object.klType != null)
                message.klType = object.klType | 0;
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_GetKL.C2S.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            if (object.reqNum != null)
                message.reqNum = object.reqNum | 0;
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetKL.C2S
         * @static
         * @param {Qot_GetKL.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.rehabType = 0;
                object.klType = 0;
                object.security = null;
                object.reqNum = 0;
            }
            if (message.rehabType != null && message.hasOwnProperty("rehabType"))
                object.rehabType = message.rehabType;
            if (message.klType != null && message.hasOwnProperty("klType"))
                object.klType = message.klType;
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            if (message.reqNum != null && message.hasOwnProperty("reqNum"))
                object.reqNum = message.reqNum;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Qot_GetKL.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Qot_GetKL.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_GetKL
         * @interface IS2C
         * @property {Qot_Common.ISecurity} security S2C security
         * @property {Array.<Qot_Common.IKLine>|null} [klList] S2C klList
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_GetKL
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_GetKL.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.klList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_GetKL.S2C
         * @instance
         */
        S2C.prototype.security = null;

        /**
         * S2C klList.
         * @member {Array.<Qot_Common.IKLine>} klList
         * @memberof Qot_GetKL.S2C
         * @instance
         */
        S2C.prototype.klList = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_GetKL.S2C
         * @static
         * @param {Qot_GetKL.IS2C=} [properties] Properties to set
         * @returns {Qot_GetKL.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_GetKL.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetKL.S2C
         * @static
         * @param {Qot_GetKL.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.klList != null && message.klList.length)
                for (var i = 0; i < message.klList.length; ++i)
                    $root.Qot_Common.KLine.encode(message.klList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_GetKL.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetKL.S2C
         * @static
         * @param {Qot_GetKL.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetKL.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetKL.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetKL.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.klList && message.klList.length))
                        message.klList = [];
                    message.klList.push($root.Qot_Common.KLine.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetKL.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetKL.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_GetKL.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            if (message.klList != null && message.hasOwnProperty("klList")) {
                if (!Array.isArray(message.klList))
                    return "klList: array expected";
                for (var i = 0; i < message.klList.length; ++i) {
                    var error = $root.Qot_Common.KLine.verify(message.klList[i]);
                    if (error)
                        return "klList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetKL.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetKL.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetKL.S2C)
                return object;
            var message = new $root.Qot_GetKL.S2C();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_GetKL.S2C.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            if (object.klList) {
                if (!Array.isArray(object.klList))
                    throw TypeError(".Qot_GetKL.S2C.klList: array expected");
                message.klList = [];
                for (var i = 0; i < object.klList.length; ++i) {
                    if (typeof object.klList[i] !== "object")
                        throw TypeError(".Qot_GetKL.S2C.klList: object expected");
                    message.klList[i] = $root.Qot_Common.KLine.fromObject(object.klList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetKL.S2C
         * @static
         * @param {Qot_GetKL.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.klList = [];
            if (options.defaults)
                object.security = null;
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            if (message.klList && message.klList.length) {
                object.klList = [];
                for (var j = 0; j < message.klList.length; ++j)
                    object.klList[j] = $root.Qot_Common.KLine.toObject(message.klList[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_GetKL.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_GetKL.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Qot_GetKL
         * @interface IRequest
         * @property {Qot_GetKL.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Qot_GetKL
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Qot_GetKL.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Qot_GetKL.IC2S} c2s
         * @memberof Qot_GetKL.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Qot_GetKL.Request
         * @static
         * @param {Qot_GetKL.IRequest=} [properties] Properties to set
         * @returns {Qot_GetKL.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Qot_GetKL.Request.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetKL.Request
         * @static
         * @param {Qot_GetKL.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_GetKL.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Qot_GetKL.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetKL.Request
         * @static
         * @param {Qot_GetKL.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetKL.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetKL.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetKL.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Qot_GetKL.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetKL.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetKL.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Qot_GetKL.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_GetKL.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetKL.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetKL.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetKL.Request)
                return object;
            var message = new $root.Qot_GetKL.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Qot_GetKL.Request.c2s: object expected");
                message.c2s = $root.Qot_GetKL.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetKL.Request
         * @static
         * @param {Qot_GetKL.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Qot_GetKL.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Qot_GetKL.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Qot_GetKL.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_GetKL
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_GetKL.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_GetKL
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_GetKL.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_GetKL.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_GetKL.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_GetKL.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_GetKL.IS2C|null|undefined} s2c
         * @memberof Qot_GetKL.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_GetKL.Response
         * @static
         * @param {Qot_GetKL.IResponse=} [properties] Properties to set
         * @returns {Qot_GetKL.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_GetKL.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetKL.Response
         * @static
         * @param {Qot_GetKL.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_GetKL.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_GetKL.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetKL.Response
         * @static
         * @param {Qot_GetKL.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetKL.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetKL.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetKL.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_GetKL.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetKL.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetKL.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_GetKL.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_GetKL.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetKL.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetKL.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetKL.Response)
                return object;
            var message = new $root.Qot_GetKL.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_GetKL.Response.s2c: object expected");
                message.s2c = $root.Qot_GetKL.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetKL.Response
         * @static
         * @param {Qot_GetKL.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_GetKL.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_GetKL.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_GetKL;
})();

$root.Qot_GetOptionChain = (function() {

    /**
     * Namespace Qot_GetOptionChain.
     * @exports Qot_GetOptionChain
     * @namespace
     */
    var Qot_GetOptionChain = {};

    /**
     * OptionCondType enum.
     * @name Qot_GetOptionChain.OptionCondType
     * @enum {string}
     * @property {number} OptionCondType_Unknow=0 OptionCondType_Unknow value
     * @property {number} OptionCondType_WithIn=1 OptionCondType_WithIn value
     * @property {number} OptionCondType_Outside=2 OptionCondType_Outside value
     */
    Qot_GetOptionChain.OptionCondType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "OptionCondType_Unknow"] = 0;
        values[valuesById[1] = "OptionCondType_WithIn"] = 1;
        values[valuesById[2] = "OptionCondType_Outside"] = 2;
        return values;
    })();

    Qot_GetOptionChain.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Qot_GetOptionChain
         * @interface IC2S
         * @property {Qot_Common.ISecurity} owner C2S owner
         * @property {number|null} [type] C2S type
         * @property {number|null} [condition] C2S condition
         * @property {string} beginTime C2S beginTime
         * @property {string} endTime C2S endTime
         */

        /**
         * Constructs a new C2S.
         * @memberof Qot_GetOptionChain
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Qot_GetOptionChain.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S owner.
         * @member {Qot_Common.ISecurity} owner
         * @memberof Qot_GetOptionChain.C2S
         * @instance
         */
        C2S.prototype.owner = null;

        /**
         * C2S type.
         * @member {number} type
         * @memberof Qot_GetOptionChain.C2S
         * @instance
         */
        C2S.prototype.type = 0;

        /**
         * C2S condition.
         * @member {number} condition
         * @memberof Qot_GetOptionChain.C2S
         * @instance
         */
        C2S.prototype.condition = 0;

        /**
         * C2S beginTime.
         * @member {string} beginTime
         * @memberof Qot_GetOptionChain.C2S
         * @instance
         */
        C2S.prototype.beginTime = "";

        /**
         * C2S endTime.
         * @member {string} endTime
         * @memberof Qot_GetOptionChain.C2S
         * @instance
         */
        C2S.prototype.endTime = "";

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Qot_GetOptionChain.C2S
         * @static
         * @param {Qot_GetOptionChain.IC2S=} [properties] Properties to set
         * @returns {Qot_GetOptionChain.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Qot_GetOptionChain.C2S.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetOptionChain.C2S
         * @static
         * @param {Qot_GetOptionChain.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.owner, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
            if (message.condition != null && message.hasOwnProperty("condition"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.condition);
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.beginTime);
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.endTime);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Qot_GetOptionChain.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetOptionChain.C2S
         * @static
         * @param {Qot_GetOptionChain.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetOptionChain.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetOptionChain.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetOptionChain.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.owner = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.type = reader.int32();
                    break;
                case 3:
                    message.condition = reader.int32();
                    break;
                case 4:
                    message.beginTime = reader.string();
                    break;
                case 5:
                    message.endTime = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("owner"))
                throw $util.ProtocolError("missing required 'owner'", { instance: message });
            if (!message.hasOwnProperty("beginTime"))
                throw $util.ProtocolError("missing required 'beginTime'", { instance: message });
            if (!message.hasOwnProperty("endTime"))
                throw $util.ProtocolError("missing required 'endTime'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetOptionChain.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetOptionChain.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Qot_GetOptionChain.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.owner);
                if (error)
                    return "owner." + error;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.condition != null && message.hasOwnProperty("condition"))
                if (!$util.isInteger(message.condition))
                    return "condition: integer expected";
            if (!$util.isString(message.beginTime))
                return "beginTime: string expected";
            if (!$util.isString(message.endTime))
                return "endTime: string expected";
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetOptionChain.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetOptionChain.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetOptionChain.C2S)
                return object;
            var message = new $root.Qot_GetOptionChain.C2S();
            if (object.owner != null) {
                if (typeof object.owner !== "object")
                    throw TypeError(".Qot_GetOptionChain.C2S.owner: object expected");
                message.owner = $root.Qot_Common.Security.fromObject(object.owner);
            }
            if (object.type != null)
                message.type = object.type | 0;
            if (object.condition != null)
                message.condition = object.condition | 0;
            if (object.beginTime != null)
                message.beginTime = String(object.beginTime);
            if (object.endTime != null)
                message.endTime = String(object.endTime);
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetOptionChain.C2S
         * @static
         * @param {Qot_GetOptionChain.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.owner = null;
                object.type = 0;
                object.condition = 0;
                object.beginTime = "";
                object.endTime = "";
            }
            if (message.owner != null && message.hasOwnProperty("owner"))
                object.owner = $root.Qot_Common.Security.toObject(message.owner, options);
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.condition != null && message.hasOwnProperty("condition"))
                object.condition = message.condition;
            if (message.beginTime != null && message.hasOwnProperty("beginTime"))
                object.beginTime = message.beginTime;
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                object.endTime = message.endTime;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Qot_GetOptionChain.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Qot_GetOptionChain.OptionItem = (function() {

        /**
         * Properties of an OptionItem.
         * @memberof Qot_GetOptionChain
         * @interface IOptionItem
         * @property {Qot_Common.ISecurityStaticInfo|null} [call] OptionItem call
         * @property {Qot_Common.ISecurityStaticInfo|null} [put] OptionItem put
         */

        /**
         * Constructs a new OptionItem.
         * @memberof Qot_GetOptionChain
         * @classdesc Represents an OptionItem.
         * @implements IOptionItem
         * @constructor
         * @param {Qot_GetOptionChain.IOptionItem=} [properties] Properties to set
         */
        function OptionItem(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OptionItem call.
         * @member {Qot_Common.ISecurityStaticInfo|null|undefined} call
         * @memberof Qot_GetOptionChain.OptionItem
         * @instance
         */
        OptionItem.prototype.call = null;

        /**
         * OptionItem put.
         * @member {Qot_Common.ISecurityStaticInfo|null|undefined} put
         * @memberof Qot_GetOptionChain.OptionItem
         * @instance
         */
        OptionItem.prototype.put = null;

        /**
         * Creates a new OptionItem instance using the specified properties.
         * @function create
         * @memberof Qot_GetOptionChain.OptionItem
         * @static
         * @param {Qot_GetOptionChain.IOptionItem=} [properties] Properties to set
         * @returns {Qot_GetOptionChain.OptionItem} OptionItem instance
         */
        OptionItem.create = function create(properties) {
            return new OptionItem(properties);
        };

        /**
         * Encodes the specified OptionItem message. Does not implicitly {@link Qot_GetOptionChain.OptionItem.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetOptionChain.OptionItem
         * @static
         * @param {Qot_GetOptionChain.IOptionItem} message OptionItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OptionItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.call != null && message.hasOwnProperty("call"))
                $root.Qot_Common.SecurityStaticInfo.encode(message.call, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.put != null && message.hasOwnProperty("put"))
                $root.Qot_Common.SecurityStaticInfo.encode(message.put, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified OptionItem message, length delimited. Does not implicitly {@link Qot_GetOptionChain.OptionItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetOptionChain.OptionItem
         * @static
         * @param {Qot_GetOptionChain.IOptionItem} message OptionItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OptionItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OptionItem message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetOptionChain.OptionItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetOptionChain.OptionItem} OptionItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OptionItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetOptionChain.OptionItem();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.call = $root.Qot_Common.SecurityStaticInfo.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.put = $root.Qot_Common.SecurityStaticInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an OptionItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetOptionChain.OptionItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetOptionChain.OptionItem} OptionItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OptionItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OptionItem message.
         * @function verify
         * @memberof Qot_GetOptionChain.OptionItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OptionItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.call != null && message.hasOwnProperty("call")) {
                var error = $root.Qot_Common.SecurityStaticInfo.verify(message.call);
                if (error)
                    return "call." + error;
            }
            if (message.put != null && message.hasOwnProperty("put")) {
                var error = $root.Qot_Common.SecurityStaticInfo.verify(message.put);
                if (error)
                    return "put." + error;
            }
            return null;
        };

        /**
         * Creates an OptionItem message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetOptionChain.OptionItem
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetOptionChain.OptionItem} OptionItem
         */
        OptionItem.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetOptionChain.OptionItem)
                return object;
            var message = new $root.Qot_GetOptionChain.OptionItem();
            if (object.call != null) {
                if (typeof object.call !== "object")
                    throw TypeError(".Qot_GetOptionChain.OptionItem.call: object expected");
                message.call = $root.Qot_Common.SecurityStaticInfo.fromObject(object.call);
            }
            if (object.put != null) {
                if (typeof object.put !== "object")
                    throw TypeError(".Qot_GetOptionChain.OptionItem.put: object expected");
                message.put = $root.Qot_Common.SecurityStaticInfo.fromObject(object.put);
            }
            return message;
        };

        /**
         * Creates a plain object from an OptionItem message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetOptionChain.OptionItem
         * @static
         * @param {Qot_GetOptionChain.OptionItem} message OptionItem
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OptionItem.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.call = null;
                object.put = null;
            }
            if (message.call != null && message.hasOwnProperty("call"))
                object.call = $root.Qot_Common.SecurityStaticInfo.toObject(message.call, options);
            if (message.put != null && message.hasOwnProperty("put"))
                object.put = $root.Qot_Common.SecurityStaticInfo.toObject(message.put, options);
            return object;
        };

        /**
         * Converts this OptionItem to JSON.
         * @function toJSON
         * @memberof Qot_GetOptionChain.OptionItem
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OptionItem.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return OptionItem;
    })();

    Qot_GetOptionChain.OptionChain = (function() {

        /**
         * Properties of an OptionChain.
         * @memberof Qot_GetOptionChain
         * @interface IOptionChain
         * @property {string} strikeTime OptionChain strikeTime
         * @property {Array.<Qot_GetOptionChain.IOptionItem>|null} [option] OptionChain option
         * @property {number|null} [strikeTimestamp] OptionChain strikeTimestamp
         */

        /**
         * Constructs a new OptionChain.
         * @memberof Qot_GetOptionChain
         * @classdesc Represents an OptionChain.
         * @implements IOptionChain
         * @constructor
         * @param {Qot_GetOptionChain.IOptionChain=} [properties] Properties to set
         */
        function OptionChain(properties) {
            this.option = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OptionChain strikeTime.
         * @member {string} strikeTime
         * @memberof Qot_GetOptionChain.OptionChain
         * @instance
         */
        OptionChain.prototype.strikeTime = "";

        /**
         * OptionChain option.
         * @member {Array.<Qot_GetOptionChain.IOptionItem>} option
         * @memberof Qot_GetOptionChain.OptionChain
         * @instance
         */
        OptionChain.prototype.option = $util.emptyArray;

        /**
         * OptionChain strikeTimestamp.
         * @member {number} strikeTimestamp
         * @memberof Qot_GetOptionChain.OptionChain
         * @instance
         */
        OptionChain.prototype.strikeTimestamp = 0;

        /**
         * Creates a new OptionChain instance using the specified properties.
         * @function create
         * @memberof Qot_GetOptionChain.OptionChain
         * @static
         * @param {Qot_GetOptionChain.IOptionChain=} [properties] Properties to set
         * @returns {Qot_GetOptionChain.OptionChain} OptionChain instance
         */
        OptionChain.create = function create(properties) {
            return new OptionChain(properties);
        };

        /**
         * Encodes the specified OptionChain message. Does not implicitly {@link Qot_GetOptionChain.OptionChain.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetOptionChain.OptionChain
         * @static
         * @param {Qot_GetOptionChain.IOptionChain} message OptionChain message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OptionChain.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.strikeTime);
            if (message.option != null && message.option.length)
                for (var i = 0; i < message.option.length; ++i)
                    $root.Qot_GetOptionChain.OptionItem.encode(message.option[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.strikeTimestamp != null && message.hasOwnProperty("strikeTimestamp"))
                writer.uint32(/* id 3, wireType 1 =*/25).double(message.strikeTimestamp);
            return writer;
        };

        /**
         * Encodes the specified OptionChain message, length delimited. Does not implicitly {@link Qot_GetOptionChain.OptionChain.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetOptionChain.OptionChain
         * @static
         * @param {Qot_GetOptionChain.IOptionChain} message OptionChain message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OptionChain.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OptionChain message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetOptionChain.OptionChain
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetOptionChain.OptionChain} OptionChain
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OptionChain.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetOptionChain.OptionChain();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.strikeTime = reader.string();
                    break;
                case 2:
                    if (!(message.option && message.option.length))
                        message.option = [];
                    message.option.push($root.Qot_GetOptionChain.OptionItem.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.strikeTimestamp = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("strikeTime"))
                throw $util.ProtocolError("missing required 'strikeTime'", { instance: message });
            return message;
        };

        /**
         * Decodes an OptionChain message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetOptionChain.OptionChain
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetOptionChain.OptionChain} OptionChain
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OptionChain.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OptionChain message.
         * @function verify
         * @memberof Qot_GetOptionChain.OptionChain
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OptionChain.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.strikeTime))
                return "strikeTime: string expected";
            if (message.option != null && message.hasOwnProperty("option")) {
                if (!Array.isArray(message.option))
                    return "option: array expected";
                for (var i = 0; i < message.option.length; ++i) {
                    var error = $root.Qot_GetOptionChain.OptionItem.verify(message.option[i]);
                    if (error)
                        return "option." + error;
                }
            }
            if (message.strikeTimestamp != null && message.hasOwnProperty("strikeTimestamp"))
                if (typeof message.strikeTimestamp !== "number")
                    return "strikeTimestamp: number expected";
            return null;
        };

        /**
         * Creates an OptionChain message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetOptionChain.OptionChain
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetOptionChain.OptionChain} OptionChain
         */
        OptionChain.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetOptionChain.OptionChain)
                return object;
            var message = new $root.Qot_GetOptionChain.OptionChain();
            if (object.strikeTime != null)
                message.strikeTime = String(object.strikeTime);
            if (object.option) {
                if (!Array.isArray(object.option))
                    throw TypeError(".Qot_GetOptionChain.OptionChain.option: array expected");
                message.option = [];
                for (var i = 0; i < object.option.length; ++i) {
                    if (typeof object.option[i] !== "object")
                        throw TypeError(".Qot_GetOptionChain.OptionChain.option: object expected");
                    message.option[i] = $root.Qot_GetOptionChain.OptionItem.fromObject(object.option[i]);
                }
            }
            if (object.strikeTimestamp != null)
                message.strikeTimestamp = Number(object.strikeTimestamp);
            return message;
        };

        /**
         * Creates a plain object from an OptionChain message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetOptionChain.OptionChain
         * @static
         * @param {Qot_GetOptionChain.OptionChain} message OptionChain
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OptionChain.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.option = [];
            if (options.defaults) {
                object.strikeTime = "";
                object.strikeTimestamp = 0;
            }
            if (message.strikeTime != null && message.hasOwnProperty("strikeTime"))
                object.strikeTime = message.strikeTime;
            if (message.option && message.option.length) {
                object.option = [];
                for (var j = 0; j < message.option.length; ++j)
                    object.option[j] = $root.Qot_GetOptionChain.OptionItem.toObject(message.option[j], options);
            }
            if (message.strikeTimestamp != null && message.hasOwnProperty("strikeTimestamp"))
                object.strikeTimestamp = options.json && !isFinite(message.strikeTimestamp) ? String(message.strikeTimestamp) : message.strikeTimestamp;
            return object;
        };

        /**
         * Converts this OptionChain to JSON.
         * @function toJSON
         * @memberof Qot_GetOptionChain.OptionChain
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OptionChain.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return OptionChain;
    })();

    Qot_GetOptionChain.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_GetOptionChain
         * @interface IS2C
         * @property {Array.<Qot_GetOptionChain.IOptionChain>|null} [optionChain] S2C optionChain
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_GetOptionChain
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_GetOptionChain.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.optionChain = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C optionChain.
         * @member {Array.<Qot_GetOptionChain.IOptionChain>} optionChain
         * @memberof Qot_GetOptionChain.S2C
         * @instance
         */
        S2C.prototype.optionChain = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_GetOptionChain.S2C
         * @static
         * @param {Qot_GetOptionChain.IS2C=} [properties] Properties to set
         * @returns {Qot_GetOptionChain.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_GetOptionChain.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetOptionChain.S2C
         * @static
         * @param {Qot_GetOptionChain.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.optionChain != null && message.optionChain.length)
                for (var i = 0; i < message.optionChain.length; ++i)
                    $root.Qot_GetOptionChain.OptionChain.encode(message.optionChain[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_GetOptionChain.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetOptionChain.S2C
         * @static
         * @param {Qot_GetOptionChain.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetOptionChain.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetOptionChain.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetOptionChain.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.optionChain && message.optionChain.length))
                        message.optionChain = [];
                    message.optionChain.push($root.Qot_GetOptionChain.OptionChain.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetOptionChain.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetOptionChain.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_GetOptionChain.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.optionChain != null && message.hasOwnProperty("optionChain")) {
                if (!Array.isArray(message.optionChain))
                    return "optionChain: array expected";
                for (var i = 0; i < message.optionChain.length; ++i) {
                    var error = $root.Qot_GetOptionChain.OptionChain.verify(message.optionChain[i]);
                    if (error)
                        return "optionChain." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetOptionChain.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetOptionChain.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetOptionChain.S2C)
                return object;
            var message = new $root.Qot_GetOptionChain.S2C();
            if (object.optionChain) {
                if (!Array.isArray(object.optionChain))
                    throw TypeError(".Qot_GetOptionChain.S2C.optionChain: array expected");
                message.optionChain = [];
                for (var i = 0; i < object.optionChain.length; ++i) {
                    if (typeof object.optionChain[i] !== "object")
                        throw TypeError(".Qot_GetOptionChain.S2C.optionChain: object expected");
                    message.optionChain[i] = $root.Qot_GetOptionChain.OptionChain.fromObject(object.optionChain[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetOptionChain.S2C
         * @static
         * @param {Qot_GetOptionChain.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.optionChain = [];
            if (message.optionChain && message.optionChain.length) {
                object.optionChain = [];
                for (var j = 0; j < message.optionChain.length; ++j)
                    object.optionChain[j] = $root.Qot_GetOptionChain.OptionChain.toObject(message.optionChain[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_GetOptionChain.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_GetOptionChain.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Qot_GetOptionChain
         * @interface IRequest
         * @property {Qot_GetOptionChain.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Qot_GetOptionChain
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Qot_GetOptionChain.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Qot_GetOptionChain.IC2S} c2s
         * @memberof Qot_GetOptionChain.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Qot_GetOptionChain.Request
         * @static
         * @param {Qot_GetOptionChain.IRequest=} [properties] Properties to set
         * @returns {Qot_GetOptionChain.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Qot_GetOptionChain.Request.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetOptionChain.Request
         * @static
         * @param {Qot_GetOptionChain.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_GetOptionChain.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Qot_GetOptionChain.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetOptionChain.Request
         * @static
         * @param {Qot_GetOptionChain.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetOptionChain.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetOptionChain.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetOptionChain.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Qot_GetOptionChain.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetOptionChain.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetOptionChain.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Qot_GetOptionChain.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_GetOptionChain.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetOptionChain.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetOptionChain.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetOptionChain.Request)
                return object;
            var message = new $root.Qot_GetOptionChain.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Qot_GetOptionChain.Request.c2s: object expected");
                message.c2s = $root.Qot_GetOptionChain.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetOptionChain.Request
         * @static
         * @param {Qot_GetOptionChain.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Qot_GetOptionChain.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Qot_GetOptionChain.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Qot_GetOptionChain.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_GetOptionChain
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_GetOptionChain.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_GetOptionChain
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_GetOptionChain.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_GetOptionChain.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_GetOptionChain.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_GetOptionChain.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_GetOptionChain.IS2C|null|undefined} s2c
         * @memberof Qot_GetOptionChain.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_GetOptionChain.Response
         * @static
         * @param {Qot_GetOptionChain.IResponse=} [properties] Properties to set
         * @returns {Qot_GetOptionChain.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_GetOptionChain.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetOptionChain.Response
         * @static
         * @param {Qot_GetOptionChain.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_GetOptionChain.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_GetOptionChain.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetOptionChain.Response
         * @static
         * @param {Qot_GetOptionChain.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetOptionChain.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetOptionChain.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetOptionChain.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_GetOptionChain.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetOptionChain.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetOptionChain.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_GetOptionChain.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_GetOptionChain.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetOptionChain.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetOptionChain.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetOptionChain.Response)
                return object;
            var message = new $root.Qot_GetOptionChain.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_GetOptionChain.Response.s2c: object expected");
                message.s2c = $root.Qot_GetOptionChain.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetOptionChain.Response
         * @static
         * @param {Qot_GetOptionChain.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_GetOptionChain.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_GetOptionChain.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_GetOptionChain;
})();

$root.Qot_GetOrderBook = (function() {

    /**
     * Namespace Qot_GetOrderBook.
     * @exports Qot_GetOrderBook
     * @namespace
     */
    var Qot_GetOrderBook = {};

    Qot_GetOrderBook.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Qot_GetOrderBook
         * @interface IC2S
         * @property {Qot_Common.ISecurity} security C2S security
         * @property {number} num C2S num
         */

        /**
         * Constructs a new C2S.
         * @memberof Qot_GetOrderBook
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Qot_GetOrderBook.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_GetOrderBook.C2S
         * @instance
         */
        C2S.prototype.security = null;

        /**
         * C2S num.
         * @member {number} num
         * @memberof Qot_GetOrderBook.C2S
         * @instance
         */
        C2S.prototype.num = 0;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Qot_GetOrderBook.C2S
         * @static
         * @param {Qot_GetOrderBook.IC2S=} [properties] Properties to set
         * @returns {Qot_GetOrderBook.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Qot_GetOrderBook.C2S.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetOrderBook.C2S
         * @static
         * @param {Qot_GetOrderBook.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.num);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Qot_GetOrderBook.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetOrderBook.C2S
         * @static
         * @param {Qot_GetOrderBook.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetOrderBook.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetOrderBook.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetOrderBook.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.num = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            if (!message.hasOwnProperty("num"))
                throw $util.ProtocolError("missing required 'num'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetOrderBook.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetOrderBook.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Qot_GetOrderBook.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            if (!$util.isInteger(message.num))
                return "num: integer expected";
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetOrderBook.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetOrderBook.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetOrderBook.C2S)
                return object;
            var message = new $root.Qot_GetOrderBook.C2S();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_GetOrderBook.C2S.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            if (object.num != null)
                message.num = object.num | 0;
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetOrderBook.C2S
         * @static
         * @param {Qot_GetOrderBook.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.security = null;
                object.num = 0;
            }
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            if (message.num != null && message.hasOwnProperty("num"))
                object.num = message.num;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Qot_GetOrderBook.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Qot_GetOrderBook.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_GetOrderBook
         * @interface IS2C
         * @property {Qot_Common.ISecurity} security S2C security
         * @property {Array.<Qot_Common.IOrderBook>|null} [orderBookAskList] S2C orderBookAskList
         * @property {Array.<Qot_Common.IOrderBook>|null} [orderBookBidList] S2C orderBookBidList
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_GetOrderBook
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_GetOrderBook.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.orderBookAskList = [];
            this.orderBookBidList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_GetOrderBook.S2C
         * @instance
         */
        S2C.prototype.security = null;

        /**
         * S2C orderBookAskList.
         * @member {Array.<Qot_Common.IOrderBook>} orderBookAskList
         * @memberof Qot_GetOrderBook.S2C
         * @instance
         */
        S2C.prototype.orderBookAskList = $util.emptyArray;

        /**
         * S2C orderBookBidList.
         * @member {Array.<Qot_Common.IOrderBook>} orderBookBidList
         * @memberof Qot_GetOrderBook.S2C
         * @instance
         */
        S2C.prototype.orderBookBidList = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_GetOrderBook.S2C
         * @static
         * @param {Qot_GetOrderBook.IS2C=} [properties] Properties to set
         * @returns {Qot_GetOrderBook.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_GetOrderBook.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetOrderBook.S2C
         * @static
         * @param {Qot_GetOrderBook.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.orderBookAskList != null && message.orderBookAskList.length)
                for (var i = 0; i < message.orderBookAskList.length; ++i)
                    $root.Qot_Common.OrderBook.encode(message.orderBookAskList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.orderBookBidList != null && message.orderBookBidList.length)
                for (var i = 0; i < message.orderBookBidList.length; ++i)
                    $root.Qot_Common.OrderBook.encode(message.orderBookBidList[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_GetOrderBook.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetOrderBook.S2C
         * @static
         * @param {Qot_GetOrderBook.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetOrderBook.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetOrderBook.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetOrderBook.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.orderBookAskList && message.orderBookAskList.length))
                        message.orderBookAskList = [];
                    message.orderBookAskList.push($root.Qot_Common.OrderBook.decode(reader, reader.uint32()));
                    break;
                case 3:
                    if (!(message.orderBookBidList && message.orderBookBidList.length))
                        message.orderBookBidList = [];
                    message.orderBookBidList.push($root.Qot_Common.OrderBook.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetOrderBook.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetOrderBook.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_GetOrderBook.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            if (message.orderBookAskList != null && message.hasOwnProperty("orderBookAskList")) {
                if (!Array.isArray(message.orderBookAskList))
                    return "orderBookAskList: array expected";
                for (var i = 0; i < message.orderBookAskList.length; ++i) {
                    var error = $root.Qot_Common.OrderBook.verify(message.orderBookAskList[i]);
                    if (error)
                        return "orderBookAskList." + error;
                }
            }
            if (message.orderBookBidList != null && message.hasOwnProperty("orderBookBidList")) {
                if (!Array.isArray(message.orderBookBidList))
                    return "orderBookBidList: array expected";
                for (var i = 0; i < message.orderBookBidList.length; ++i) {
                    var error = $root.Qot_Common.OrderBook.verify(message.orderBookBidList[i]);
                    if (error)
                        return "orderBookBidList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetOrderBook.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetOrderBook.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetOrderBook.S2C)
                return object;
            var message = new $root.Qot_GetOrderBook.S2C();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_GetOrderBook.S2C.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            if (object.orderBookAskList) {
                if (!Array.isArray(object.orderBookAskList))
                    throw TypeError(".Qot_GetOrderBook.S2C.orderBookAskList: array expected");
                message.orderBookAskList = [];
                for (var i = 0; i < object.orderBookAskList.length; ++i) {
                    if (typeof object.orderBookAskList[i] !== "object")
                        throw TypeError(".Qot_GetOrderBook.S2C.orderBookAskList: object expected");
                    message.orderBookAskList[i] = $root.Qot_Common.OrderBook.fromObject(object.orderBookAskList[i]);
                }
            }
            if (object.orderBookBidList) {
                if (!Array.isArray(object.orderBookBidList))
                    throw TypeError(".Qot_GetOrderBook.S2C.orderBookBidList: array expected");
                message.orderBookBidList = [];
                for (var i = 0; i < object.orderBookBidList.length; ++i) {
                    if (typeof object.orderBookBidList[i] !== "object")
                        throw TypeError(".Qot_GetOrderBook.S2C.orderBookBidList: object expected");
                    message.orderBookBidList[i] = $root.Qot_Common.OrderBook.fromObject(object.orderBookBidList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetOrderBook.S2C
         * @static
         * @param {Qot_GetOrderBook.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.orderBookAskList = [];
                object.orderBookBidList = [];
            }
            if (options.defaults)
                object.security = null;
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            if (message.orderBookAskList && message.orderBookAskList.length) {
                object.orderBookAskList = [];
                for (var j = 0; j < message.orderBookAskList.length; ++j)
                    object.orderBookAskList[j] = $root.Qot_Common.OrderBook.toObject(message.orderBookAskList[j], options);
            }
            if (message.orderBookBidList && message.orderBookBidList.length) {
                object.orderBookBidList = [];
                for (var j = 0; j < message.orderBookBidList.length; ++j)
                    object.orderBookBidList[j] = $root.Qot_Common.OrderBook.toObject(message.orderBookBidList[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_GetOrderBook.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_GetOrderBook.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Qot_GetOrderBook
         * @interface IRequest
         * @property {Qot_GetOrderBook.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Qot_GetOrderBook
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Qot_GetOrderBook.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Qot_GetOrderBook.IC2S} c2s
         * @memberof Qot_GetOrderBook.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Qot_GetOrderBook.Request
         * @static
         * @param {Qot_GetOrderBook.IRequest=} [properties] Properties to set
         * @returns {Qot_GetOrderBook.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Qot_GetOrderBook.Request.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetOrderBook.Request
         * @static
         * @param {Qot_GetOrderBook.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_GetOrderBook.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Qot_GetOrderBook.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetOrderBook.Request
         * @static
         * @param {Qot_GetOrderBook.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetOrderBook.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetOrderBook.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetOrderBook.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Qot_GetOrderBook.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetOrderBook.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetOrderBook.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Qot_GetOrderBook.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_GetOrderBook.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetOrderBook.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetOrderBook.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetOrderBook.Request)
                return object;
            var message = new $root.Qot_GetOrderBook.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Qot_GetOrderBook.Request.c2s: object expected");
                message.c2s = $root.Qot_GetOrderBook.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetOrderBook.Request
         * @static
         * @param {Qot_GetOrderBook.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Qot_GetOrderBook.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Qot_GetOrderBook.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Qot_GetOrderBook.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_GetOrderBook
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_GetOrderBook.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_GetOrderBook
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_GetOrderBook.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_GetOrderBook.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_GetOrderBook.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_GetOrderBook.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_GetOrderBook.IS2C|null|undefined} s2c
         * @memberof Qot_GetOrderBook.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_GetOrderBook.Response
         * @static
         * @param {Qot_GetOrderBook.IResponse=} [properties] Properties to set
         * @returns {Qot_GetOrderBook.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_GetOrderBook.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetOrderBook.Response
         * @static
         * @param {Qot_GetOrderBook.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_GetOrderBook.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_GetOrderBook.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetOrderBook.Response
         * @static
         * @param {Qot_GetOrderBook.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetOrderBook.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetOrderBook.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetOrderBook.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_GetOrderBook.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetOrderBook.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetOrderBook.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_GetOrderBook.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_GetOrderBook.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetOrderBook.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetOrderBook.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetOrderBook.Response)
                return object;
            var message = new $root.Qot_GetOrderBook.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_GetOrderBook.Response.s2c: object expected");
                message.s2c = $root.Qot_GetOrderBook.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetOrderBook.Response
         * @static
         * @param {Qot_GetOrderBook.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_GetOrderBook.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_GetOrderBook.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_GetOrderBook;
})();

$root.Qot_GetOrderDetail = (function() {

    /**
     * Namespace Qot_GetOrderDetail.
     * @exports Qot_GetOrderDetail
     * @namespace
     */
    var Qot_GetOrderDetail = {};

    Qot_GetOrderDetail.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Qot_GetOrderDetail
         * @interface IC2S
         * @property {Qot_Common.ISecurity} security C2S security
         */

        /**
         * Constructs a new C2S.
         * @memberof Qot_GetOrderDetail
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Qot_GetOrderDetail.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_GetOrderDetail.C2S
         * @instance
         */
        C2S.prototype.security = null;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Qot_GetOrderDetail.C2S
         * @static
         * @param {Qot_GetOrderDetail.IC2S=} [properties] Properties to set
         * @returns {Qot_GetOrderDetail.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Qot_GetOrderDetail.C2S.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetOrderDetail.C2S
         * @static
         * @param {Qot_GetOrderDetail.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Qot_GetOrderDetail.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetOrderDetail.C2S
         * @static
         * @param {Qot_GetOrderDetail.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetOrderDetail.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetOrderDetail.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetOrderDetail.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetOrderDetail.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetOrderDetail.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Qot_GetOrderDetail.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetOrderDetail.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetOrderDetail.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetOrderDetail.C2S)
                return object;
            var message = new $root.Qot_GetOrderDetail.C2S();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_GetOrderDetail.C2S.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetOrderDetail.C2S
         * @static
         * @param {Qot_GetOrderDetail.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.security = null;
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Qot_GetOrderDetail.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Qot_GetOrderDetail.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_GetOrderDetail
         * @interface IS2C
         * @property {Qot_Common.ISecurity} security S2C security
         * @property {Qot_Common.IOrderDetail} orderDetailAsk S2C orderDetailAsk
         * @property {Qot_Common.IOrderDetail} orderDetailBid S2C orderDetailBid
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_GetOrderDetail
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_GetOrderDetail.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_GetOrderDetail.S2C
         * @instance
         */
        S2C.prototype.security = null;

        /**
         * S2C orderDetailAsk.
         * @member {Qot_Common.IOrderDetail} orderDetailAsk
         * @memberof Qot_GetOrderDetail.S2C
         * @instance
         */
        S2C.prototype.orderDetailAsk = null;

        /**
         * S2C orderDetailBid.
         * @member {Qot_Common.IOrderDetail} orderDetailBid
         * @memberof Qot_GetOrderDetail.S2C
         * @instance
         */
        S2C.prototype.orderDetailBid = null;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_GetOrderDetail.S2C
         * @static
         * @param {Qot_GetOrderDetail.IS2C=} [properties] Properties to set
         * @returns {Qot_GetOrderDetail.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_GetOrderDetail.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetOrderDetail.S2C
         * @static
         * @param {Qot_GetOrderDetail.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            $root.Qot_Common.OrderDetail.encode(message.orderDetailAsk, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            $root.Qot_Common.OrderDetail.encode(message.orderDetailBid, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_GetOrderDetail.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetOrderDetail.S2C
         * @static
         * @param {Qot_GetOrderDetail.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetOrderDetail.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetOrderDetail.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetOrderDetail.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.orderDetailAsk = $root.Qot_Common.OrderDetail.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.orderDetailBid = $root.Qot_Common.OrderDetail.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            if (!message.hasOwnProperty("orderDetailAsk"))
                throw $util.ProtocolError("missing required 'orderDetailAsk'", { instance: message });
            if (!message.hasOwnProperty("orderDetailBid"))
                throw $util.ProtocolError("missing required 'orderDetailBid'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetOrderDetail.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetOrderDetail.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_GetOrderDetail.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            {
                var error = $root.Qot_Common.OrderDetail.verify(message.orderDetailAsk);
                if (error)
                    return "orderDetailAsk." + error;
            }
            {
                var error = $root.Qot_Common.OrderDetail.verify(message.orderDetailBid);
                if (error)
                    return "orderDetailBid." + error;
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetOrderDetail.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetOrderDetail.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetOrderDetail.S2C)
                return object;
            var message = new $root.Qot_GetOrderDetail.S2C();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_GetOrderDetail.S2C.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            if (object.orderDetailAsk != null) {
                if (typeof object.orderDetailAsk !== "object")
                    throw TypeError(".Qot_GetOrderDetail.S2C.orderDetailAsk: object expected");
                message.orderDetailAsk = $root.Qot_Common.OrderDetail.fromObject(object.orderDetailAsk);
            }
            if (object.orderDetailBid != null) {
                if (typeof object.orderDetailBid !== "object")
                    throw TypeError(".Qot_GetOrderDetail.S2C.orderDetailBid: object expected");
                message.orderDetailBid = $root.Qot_Common.OrderDetail.fromObject(object.orderDetailBid);
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetOrderDetail.S2C
         * @static
         * @param {Qot_GetOrderDetail.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.security = null;
                object.orderDetailAsk = null;
                object.orderDetailBid = null;
            }
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            if (message.orderDetailAsk != null && message.hasOwnProperty("orderDetailAsk"))
                object.orderDetailAsk = $root.Qot_Common.OrderDetail.toObject(message.orderDetailAsk, options);
            if (message.orderDetailBid != null && message.hasOwnProperty("orderDetailBid"))
                object.orderDetailBid = $root.Qot_Common.OrderDetail.toObject(message.orderDetailBid, options);
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_GetOrderDetail.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_GetOrderDetail.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Qot_GetOrderDetail
         * @interface IRequest
         * @property {Qot_GetOrderDetail.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Qot_GetOrderDetail
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Qot_GetOrderDetail.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Qot_GetOrderDetail.IC2S} c2s
         * @memberof Qot_GetOrderDetail.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Qot_GetOrderDetail.Request
         * @static
         * @param {Qot_GetOrderDetail.IRequest=} [properties] Properties to set
         * @returns {Qot_GetOrderDetail.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Qot_GetOrderDetail.Request.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetOrderDetail.Request
         * @static
         * @param {Qot_GetOrderDetail.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_GetOrderDetail.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Qot_GetOrderDetail.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetOrderDetail.Request
         * @static
         * @param {Qot_GetOrderDetail.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetOrderDetail.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetOrderDetail.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetOrderDetail.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Qot_GetOrderDetail.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetOrderDetail.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetOrderDetail.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Qot_GetOrderDetail.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_GetOrderDetail.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetOrderDetail.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetOrderDetail.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetOrderDetail.Request)
                return object;
            var message = new $root.Qot_GetOrderDetail.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Qot_GetOrderDetail.Request.c2s: object expected");
                message.c2s = $root.Qot_GetOrderDetail.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetOrderDetail.Request
         * @static
         * @param {Qot_GetOrderDetail.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Qot_GetOrderDetail.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Qot_GetOrderDetail.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Qot_GetOrderDetail.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_GetOrderDetail
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_GetOrderDetail.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_GetOrderDetail
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_GetOrderDetail.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_GetOrderDetail.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_GetOrderDetail.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_GetOrderDetail.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_GetOrderDetail.IS2C|null|undefined} s2c
         * @memberof Qot_GetOrderDetail.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_GetOrderDetail.Response
         * @static
         * @param {Qot_GetOrderDetail.IResponse=} [properties] Properties to set
         * @returns {Qot_GetOrderDetail.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_GetOrderDetail.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetOrderDetail.Response
         * @static
         * @param {Qot_GetOrderDetail.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_GetOrderDetail.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_GetOrderDetail.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetOrderDetail.Response
         * @static
         * @param {Qot_GetOrderDetail.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetOrderDetail.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetOrderDetail.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetOrderDetail.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_GetOrderDetail.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetOrderDetail.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetOrderDetail.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_GetOrderDetail.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_GetOrderDetail.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetOrderDetail.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetOrderDetail.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetOrderDetail.Response)
                return object;
            var message = new $root.Qot_GetOrderDetail.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_GetOrderDetail.Response.s2c: object expected");
                message.s2c = $root.Qot_GetOrderDetail.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetOrderDetail.Response
         * @static
         * @param {Qot_GetOrderDetail.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_GetOrderDetail.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_GetOrderDetail.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_GetOrderDetail;
})();

$root.Qot_GetOwnerPlate = (function() {

    /**
     * Namespace Qot_GetOwnerPlate.
     * @exports Qot_GetOwnerPlate
     * @namespace
     */
    var Qot_GetOwnerPlate = {};

    Qot_GetOwnerPlate.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Qot_GetOwnerPlate
         * @interface IC2S
         * @property {Array.<Qot_Common.ISecurity>|null} [securityList] C2S securityList
         */

        /**
         * Constructs a new C2S.
         * @memberof Qot_GetOwnerPlate
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Qot_GetOwnerPlate.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            this.securityList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S securityList.
         * @member {Array.<Qot_Common.ISecurity>} securityList
         * @memberof Qot_GetOwnerPlate.C2S
         * @instance
         */
        C2S.prototype.securityList = $util.emptyArray;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Qot_GetOwnerPlate.C2S
         * @static
         * @param {Qot_GetOwnerPlate.IC2S=} [properties] Properties to set
         * @returns {Qot_GetOwnerPlate.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Qot_GetOwnerPlate.C2S.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetOwnerPlate.C2S
         * @static
         * @param {Qot_GetOwnerPlate.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.securityList != null && message.securityList.length)
                for (var i = 0; i < message.securityList.length; ++i)
                    $root.Qot_Common.Security.encode(message.securityList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Qot_GetOwnerPlate.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetOwnerPlate.C2S
         * @static
         * @param {Qot_GetOwnerPlate.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetOwnerPlate.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetOwnerPlate.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetOwnerPlate.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.securityList && message.securityList.length))
                        message.securityList = [];
                    message.securityList.push($root.Qot_Common.Security.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetOwnerPlate.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetOwnerPlate.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Qot_GetOwnerPlate.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.securityList != null && message.hasOwnProperty("securityList")) {
                if (!Array.isArray(message.securityList))
                    return "securityList: array expected";
                for (var i = 0; i < message.securityList.length; ++i) {
                    var error = $root.Qot_Common.Security.verify(message.securityList[i]);
                    if (error)
                        return "securityList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetOwnerPlate.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetOwnerPlate.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetOwnerPlate.C2S)
                return object;
            var message = new $root.Qot_GetOwnerPlate.C2S();
            if (object.securityList) {
                if (!Array.isArray(object.securityList))
                    throw TypeError(".Qot_GetOwnerPlate.C2S.securityList: array expected");
                message.securityList = [];
                for (var i = 0; i < object.securityList.length; ++i) {
                    if (typeof object.securityList[i] !== "object")
                        throw TypeError(".Qot_GetOwnerPlate.C2S.securityList: object expected");
                    message.securityList[i] = $root.Qot_Common.Security.fromObject(object.securityList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetOwnerPlate.C2S
         * @static
         * @param {Qot_GetOwnerPlate.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.securityList = [];
            if (message.securityList && message.securityList.length) {
                object.securityList = [];
                for (var j = 0; j < message.securityList.length; ++j)
                    object.securityList[j] = $root.Qot_Common.Security.toObject(message.securityList[j], options);
            }
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Qot_GetOwnerPlate.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Qot_GetOwnerPlate.SecurityOwnerPlate = (function() {

        /**
         * Properties of a SecurityOwnerPlate.
         * @memberof Qot_GetOwnerPlate
         * @interface ISecurityOwnerPlate
         * @property {Qot_Common.ISecurity} security SecurityOwnerPlate security
         * @property {Array.<Qot_Common.IPlateInfo>|null} [plateInfoList] SecurityOwnerPlate plateInfoList
         */

        /**
         * Constructs a new SecurityOwnerPlate.
         * @memberof Qot_GetOwnerPlate
         * @classdesc Represents a SecurityOwnerPlate.
         * @implements ISecurityOwnerPlate
         * @constructor
         * @param {Qot_GetOwnerPlate.ISecurityOwnerPlate=} [properties] Properties to set
         */
        function SecurityOwnerPlate(properties) {
            this.plateInfoList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SecurityOwnerPlate security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_GetOwnerPlate.SecurityOwnerPlate
         * @instance
         */
        SecurityOwnerPlate.prototype.security = null;

        /**
         * SecurityOwnerPlate plateInfoList.
         * @member {Array.<Qot_Common.IPlateInfo>} plateInfoList
         * @memberof Qot_GetOwnerPlate.SecurityOwnerPlate
         * @instance
         */
        SecurityOwnerPlate.prototype.plateInfoList = $util.emptyArray;

        /**
         * Creates a new SecurityOwnerPlate instance using the specified properties.
         * @function create
         * @memberof Qot_GetOwnerPlate.SecurityOwnerPlate
         * @static
         * @param {Qot_GetOwnerPlate.ISecurityOwnerPlate=} [properties] Properties to set
         * @returns {Qot_GetOwnerPlate.SecurityOwnerPlate} SecurityOwnerPlate instance
         */
        SecurityOwnerPlate.create = function create(properties) {
            return new SecurityOwnerPlate(properties);
        };

        /**
         * Encodes the specified SecurityOwnerPlate message. Does not implicitly {@link Qot_GetOwnerPlate.SecurityOwnerPlate.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetOwnerPlate.SecurityOwnerPlate
         * @static
         * @param {Qot_GetOwnerPlate.ISecurityOwnerPlate} message SecurityOwnerPlate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SecurityOwnerPlate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.plateInfoList != null && message.plateInfoList.length)
                for (var i = 0; i < message.plateInfoList.length; ++i)
                    $root.Qot_Common.PlateInfo.encode(message.plateInfoList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SecurityOwnerPlate message, length delimited. Does not implicitly {@link Qot_GetOwnerPlate.SecurityOwnerPlate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetOwnerPlate.SecurityOwnerPlate
         * @static
         * @param {Qot_GetOwnerPlate.ISecurityOwnerPlate} message SecurityOwnerPlate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SecurityOwnerPlate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SecurityOwnerPlate message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetOwnerPlate.SecurityOwnerPlate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetOwnerPlate.SecurityOwnerPlate} SecurityOwnerPlate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SecurityOwnerPlate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetOwnerPlate.SecurityOwnerPlate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.plateInfoList && message.plateInfoList.length))
                        message.plateInfoList = [];
                    message.plateInfoList.push($root.Qot_Common.PlateInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            return message;
        };

        /**
         * Decodes a SecurityOwnerPlate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetOwnerPlate.SecurityOwnerPlate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetOwnerPlate.SecurityOwnerPlate} SecurityOwnerPlate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SecurityOwnerPlate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SecurityOwnerPlate message.
         * @function verify
         * @memberof Qot_GetOwnerPlate.SecurityOwnerPlate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SecurityOwnerPlate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            if (message.plateInfoList != null && message.hasOwnProperty("plateInfoList")) {
                if (!Array.isArray(message.plateInfoList))
                    return "plateInfoList: array expected";
                for (var i = 0; i < message.plateInfoList.length; ++i) {
                    var error = $root.Qot_Common.PlateInfo.verify(message.plateInfoList[i]);
                    if (error)
                        return "plateInfoList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a SecurityOwnerPlate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetOwnerPlate.SecurityOwnerPlate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetOwnerPlate.SecurityOwnerPlate} SecurityOwnerPlate
         */
        SecurityOwnerPlate.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetOwnerPlate.SecurityOwnerPlate)
                return object;
            var message = new $root.Qot_GetOwnerPlate.SecurityOwnerPlate();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_GetOwnerPlate.SecurityOwnerPlate.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            if (object.plateInfoList) {
                if (!Array.isArray(object.plateInfoList))
                    throw TypeError(".Qot_GetOwnerPlate.SecurityOwnerPlate.plateInfoList: array expected");
                message.plateInfoList = [];
                for (var i = 0; i < object.plateInfoList.length; ++i) {
                    if (typeof object.plateInfoList[i] !== "object")
                        throw TypeError(".Qot_GetOwnerPlate.SecurityOwnerPlate.plateInfoList: object expected");
                    message.plateInfoList[i] = $root.Qot_Common.PlateInfo.fromObject(object.plateInfoList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a SecurityOwnerPlate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetOwnerPlate.SecurityOwnerPlate
         * @static
         * @param {Qot_GetOwnerPlate.SecurityOwnerPlate} message SecurityOwnerPlate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SecurityOwnerPlate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.plateInfoList = [];
            if (options.defaults)
                object.security = null;
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            if (message.plateInfoList && message.plateInfoList.length) {
                object.plateInfoList = [];
                for (var j = 0; j < message.plateInfoList.length; ++j)
                    object.plateInfoList[j] = $root.Qot_Common.PlateInfo.toObject(message.plateInfoList[j], options);
            }
            return object;
        };

        /**
         * Converts this SecurityOwnerPlate to JSON.
         * @function toJSON
         * @memberof Qot_GetOwnerPlate.SecurityOwnerPlate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SecurityOwnerPlate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SecurityOwnerPlate;
    })();

    Qot_GetOwnerPlate.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_GetOwnerPlate
         * @interface IS2C
         * @property {Array.<Qot_GetOwnerPlate.ISecurityOwnerPlate>|null} [ownerPlateList] S2C ownerPlateList
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_GetOwnerPlate
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_GetOwnerPlate.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.ownerPlateList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C ownerPlateList.
         * @member {Array.<Qot_GetOwnerPlate.ISecurityOwnerPlate>} ownerPlateList
         * @memberof Qot_GetOwnerPlate.S2C
         * @instance
         */
        S2C.prototype.ownerPlateList = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_GetOwnerPlate.S2C
         * @static
         * @param {Qot_GetOwnerPlate.IS2C=} [properties] Properties to set
         * @returns {Qot_GetOwnerPlate.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_GetOwnerPlate.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetOwnerPlate.S2C
         * @static
         * @param {Qot_GetOwnerPlate.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ownerPlateList != null && message.ownerPlateList.length)
                for (var i = 0; i < message.ownerPlateList.length; ++i)
                    $root.Qot_GetOwnerPlate.SecurityOwnerPlate.encode(message.ownerPlateList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_GetOwnerPlate.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetOwnerPlate.S2C
         * @static
         * @param {Qot_GetOwnerPlate.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetOwnerPlate.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetOwnerPlate.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetOwnerPlate.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.ownerPlateList && message.ownerPlateList.length))
                        message.ownerPlateList = [];
                    message.ownerPlateList.push($root.Qot_GetOwnerPlate.SecurityOwnerPlate.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetOwnerPlate.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetOwnerPlate.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_GetOwnerPlate.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ownerPlateList != null && message.hasOwnProperty("ownerPlateList")) {
                if (!Array.isArray(message.ownerPlateList))
                    return "ownerPlateList: array expected";
                for (var i = 0; i < message.ownerPlateList.length; ++i) {
                    var error = $root.Qot_GetOwnerPlate.SecurityOwnerPlate.verify(message.ownerPlateList[i]);
                    if (error)
                        return "ownerPlateList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetOwnerPlate.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetOwnerPlate.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetOwnerPlate.S2C)
                return object;
            var message = new $root.Qot_GetOwnerPlate.S2C();
            if (object.ownerPlateList) {
                if (!Array.isArray(object.ownerPlateList))
                    throw TypeError(".Qot_GetOwnerPlate.S2C.ownerPlateList: array expected");
                message.ownerPlateList = [];
                for (var i = 0; i < object.ownerPlateList.length; ++i) {
                    if (typeof object.ownerPlateList[i] !== "object")
                        throw TypeError(".Qot_GetOwnerPlate.S2C.ownerPlateList: object expected");
                    message.ownerPlateList[i] = $root.Qot_GetOwnerPlate.SecurityOwnerPlate.fromObject(object.ownerPlateList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetOwnerPlate.S2C
         * @static
         * @param {Qot_GetOwnerPlate.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.ownerPlateList = [];
            if (message.ownerPlateList && message.ownerPlateList.length) {
                object.ownerPlateList = [];
                for (var j = 0; j < message.ownerPlateList.length; ++j)
                    object.ownerPlateList[j] = $root.Qot_GetOwnerPlate.SecurityOwnerPlate.toObject(message.ownerPlateList[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_GetOwnerPlate.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_GetOwnerPlate.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Qot_GetOwnerPlate
         * @interface IRequest
         * @property {Qot_GetOwnerPlate.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Qot_GetOwnerPlate
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Qot_GetOwnerPlate.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Qot_GetOwnerPlate.IC2S} c2s
         * @memberof Qot_GetOwnerPlate.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Qot_GetOwnerPlate.Request
         * @static
         * @param {Qot_GetOwnerPlate.IRequest=} [properties] Properties to set
         * @returns {Qot_GetOwnerPlate.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Qot_GetOwnerPlate.Request.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetOwnerPlate.Request
         * @static
         * @param {Qot_GetOwnerPlate.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_GetOwnerPlate.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Qot_GetOwnerPlate.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetOwnerPlate.Request
         * @static
         * @param {Qot_GetOwnerPlate.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetOwnerPlate.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetOwnerPlate.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetOwnerPlate.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Qot_GetOwnerPlate.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetOwnerPlate.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetOwnerPlate.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Qot_GetOwnerPlate.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_GetOwnerPlate.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetOwnerPlate.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetOwnerPlate.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetOwnerPlate.Request)
                return object;
            var message = new $root.Qot_GetOwnerPlate.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Qot_GetOwnerPlate.Request.c2s: object expected");
                message.c2s = $root.Qot_GetOwnerPlate.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetOwnerPlate.Request
         * @static
         * @param {Qot_GetOwnerPlate.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Qot_GetOwnerPlate.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Qot_GetOwnerPlate.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Qot_GetOwnerPlate.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_GetOwnerPlate
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_GetOwnerPlate.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_GetOwnerPlate
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_GetOwnerPlate.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_GetOwnerPlate.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_GetOwnerPlate.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_GetOwnerPlate.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_GetOwnerPlate.IS2C|null|undefined} s2c
         * @memberof Qot_GetOwnerPlate.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_GetOwnerPlate.Response
         * @static
         * @param {Qot_GetOwnerPlate.IResponse=} [properties] Properties to set
         * @returns {Qot_GetOwnerPlate.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_GetOwnerPlate.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetOwnerPlate.Response
         * @static
         * @param {Qot_GetOwnerPlate.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_GetOwnerPlate.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_GetOwnerPlate.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetOwnerPlate.Response
         * @static
         * @param {Qot_GetOwnerPlate.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetOwnerPlate.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetOwnerPlate.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetOwnerPlate.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_GetOwnerPlate.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetOwnerPlate.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetOwnerPlate.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_GetOwnerPlate.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_GetOwnerPlate.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetOwnerPlate.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetOwnerPlate.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetOwnerPlate.Response)
                return object;
            var message = new $root.Qot_GetOwnerPlate.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_GetOwnerPlate.Response.s2c: object expected");
                message.s2c = $root.Qot_GetOwnerPlate.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetOwnerPlate.Response
         * @static
         * @param {Qot_GetOwnerPlate.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_GetOwnerPlate.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_GetOwnerPlate.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_GetOwnerPlate;
})();

$root.Qot_GetPlateSecurity = (function() {

    /**
     * Namespace Qot_GetPlateSecurity.
     * @exports Qot_GetPlateSecurity
     * @namespace
     */
    var Qot_GetPlateSecurity = {};

    Qot_GetPlateSecurity.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Qot_GetPlateSecurity
         * @interface IC2S
         * @property {Qot_Common.ISecurity} plate C2S plate
         */

        /**
         * Constructs a new C2S.
         * @memberof Qot_GetPlateSecurity
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Qot_GetPlateSecurity.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S plate.
         * @member {Qot_Common.ISecurity} plate
         * @memberof Qot_GetPlateSecurity.C2S
         * @instance
         */
        C2S.prototype.plate = null;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Qot_GetPlateSecurity.C2S
         * @static
         * @param {Qot_GetPlateSecurity.IC2S=} [properties] Properties to set
         * @returns {Qot_GetPlateSecurity.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Qot_GetPlateSecurity.C2S.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetPlateSecurity.C2S
         * @static
         * @param {Qot_GetPlateSecurity.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.plate, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Qot_GetPlateSecurity.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetPlateSecurity.C2S
         * @static
         * @param {Qot_GetPlateSecurity.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetPlateSecurity.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetPlateSecurity.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetPlateSecurity.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.plate = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("plate"))
                throw $util.ProtocolError("missing required 'plate'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetPlateSecurity.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetPlateSecurity.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Qot_GetPlateSecurity.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.plate);
                if (error)
                    return "plate." + error;
            }
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetPlateSecurity.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetPlateSecurity.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetPlateSecurity.C2S)
                return object;
            var message = new $root.Qot_GetPlateSecurity.C2S();
            if (object.plate != null) {
                if (typeof object.plate !== "object")
                    throw TypeError(".Qot_GetPlateSecurity.C2S.plate: object expected");
                message.plate = $root.Qot_Common.Security.fromObject(object.plate);
            }
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetPlateSecurity.C2S
         * @static
         * @param {Qot_GetPlateSecurity.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.plate = null;
            if (message.plate != null && message.hasOwnProperty("plate"))
                object.plate = $root.Qot_Common.Security.toObject(message.plate, options);
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Qot_GetPlateSecurity.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Qot_GetPlateSecurity.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_GetPlateSecurity
         * @interface IS2C
         * @property {Array.<Qot_Common.ISecurityStaticInfo>|null} [staticInfoList] S2C staticInfoList
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_GetPlateSecurity
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_GetPlateSecurity.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.staticInfoList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C staticInfoList.
         * @member {Array.<Qot_Common.ISecurityStaticInfo>} staticInfoList
         * @memberof Qot_GetPlateSecurity.S2C
         * @instance
         */
        S2C.prototype.staticInfoList = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_GetPlateSecurity.S2C
         * @static
         * @param {Qot_GetPlateSecurity.IS2C=} [properties] Properties to set
         * @returns {Qot_GetPlateSecurity.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_GetPlateSecurity.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetPlateSecurity.S2C
         * @static
         * @param {Qot_GetPlateSecurity.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.staticInfoList != null && message.staticInfoList.length)
                for (var i = 0; i < message.staticInfoList.length; ++i)
                    $root.Qot_Common.SecurityStaticInfo.encode(message.staticInfoList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_GetPlateSecurity.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetPlateSecurity.S2C
         * @static
         * @param {Qot_GetPlateSecurity.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetPlateSecurity.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetPlateSecurity.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetPlateSecurity.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.staticInfoList && message.staticInfoList.length))
                        message.staticInfoList = [];
                    message.staticInfoList.push($root.Qot_Common.SecurityStaticInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetPlateSecurity.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetPlateSecurity.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_GetPlateSecurity.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.staticInfoList != null && message.hasOwnProperty("staticInfoList")) {
                if (!Array.isArray(message.staticInfoList))
                    return "staticInfoList: array expected";
                for (var i = 0; i < message.staticInfoList.length; ++i) {
                    var error = $root.Qot_Common.SecurityStaticInfo.verify(message.staticInfoList[i]);
                    if (error)
                        return "staticInfoList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetPlateSecurity.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetPlateSecurity.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetPlateSecurity.S2C)
                return object;
            var message = new $root.Qot_GetPlateSecurity.S2C();
            if (object.staticInfoList) {
                if (!Array.isArray(object.staticInfoList))
                    throw TypeError(".Qot_GetPlateSecurity.S2C.staticInfoList: array expected");
                message.staticInfoList = [];
                for (var i = 0; i < object.staticInfoList.length; ++i) {
                    if (typeof object.staticInfoList[i] !== "object")
                        throw TypeError(".Qot_GetPlateSecurity.S2C.staticInfoList: object expected");
                    message.staticInfoList[i] = $root.Qot_Common.SecurityStaticInfo.fromObject(object.staticInfoList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetPlateSecurity.S2C
         * @static
         * @param {Qot_GetPlateSecurity.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.staticInfoList = [];
            if (message.staticInfoList && message.staticInfoList.length) {
                object.staticInfoList = [];
                for (var j = 0; j < message.staticInfoList.length; ++j)
                    object.staticInfoList[j] = $root.Qot_Common.SecurityStaticInfo.toObject(message.staticInfoList[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_GetPlateSecurity.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_GetPlateSecurity.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Qot_GetPlateSecurity
         * @interface IRequest
         * @property {Qot_GetPlateSecurity.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Qot_GetPlateSecurity
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Qot_GetPlateSecurity.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Qot_GetPlateSecurity.IC2S} c2s
         * @memberof Qot_GetPlateSecurity.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Qot_GetPlateSecurity.Request
         * @static
         * @param {Qot_GetPlateSecurity.IRequest=} [properties] Properties to set
         * @returns {Qot_GetPlateSecurity.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Qot_GetPlateSecurity.Request.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetPlateSecurity.Request
         * @static
         * @param {Qot_GetPlateSecurity.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_GetPlateSecurity.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Qot_GetPlateSecurity.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetPlateSecurity.Request
         * @static
         * @param {Qot_GetPlateSecurity.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetPlateSecurity.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetPlateSecurity.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetPlateSecurity.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Qot_GetPlateSecurity.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetPlateSecurity.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetPlateSecurity.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Qot_GetPlateSecurity.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_GetPlateSecurity.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetPlateSecurity.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetPlateSecurity.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetPlateSecurity.Request)
                return object;
            var message = new $root.Qot_GetPlateSecurity.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Qot_GetPlateSecurity.Request.c2s: object expected");
                message.c2s = $root.Qot_GetPlateSecurity.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetPlateSecurity.Request
         * @static
         * @param {Qot_GetPlateSecurity.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Qot_GetPlateSecurity.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Qot_GetPlateSecurity.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Qot_GetPlateSecurity.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_GetPlateSecurity
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_GetPlateSecurity.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_GetPlateSecurity
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_GetPlateSecurity.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_GetPlateSecurity.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_GetPlateSecurity.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_GetPlateSecurity.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_GetPlateSecurity.IS2C|null|undefined} s2c
         * @memberof Qot_GetPlateSecurity.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_GetPlateSecurity.Response
         * @static
         * @param {Qot_GetPlateSecurity.IResponse=} [properties] Properties to set
         * @returns {Qot_GetPlateSecurity.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_GetPlateSecurity.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetPlateSecurity.Response
         * @static
         * @param {Qot_GetPlateSecurity.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_GetPlateSecurity.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_GetPlateSecurity.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetPlateSecurity.Response
         * @static
         * @param {Qot_GetPlateSecurity.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetPlateSecurity.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetPlateSecurity.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetPlateSecurity.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_GetPlateSecurity.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetPlateSecurity.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetPlateSecurity.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_GetPlateSecurity.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_GetPlateSecurity.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetPlateSecurity.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetPlateSecurity.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetPlateSecurity.Response)
                return object;
            var message = new $root.Qot_GetPlateSecurity.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_GetPlateSecurity.Response.s2c: object expected");
                message.s2c = $root.Qot_GetPlateSecurity.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetPlateSecurity.Response
         * @static
         * @param {Qot_GetPlateSecurity.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_GetPlateSecurity.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_GetPlateSecurity.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_GetPlateSecurity;
})();

$root.Qot_GetPlateSet = (function() {

    /**
     * Namespace Qot_GetPlateSet.
     * @exports Qot_GetPlateSet
     * @namespace
     */
    var Qot_GetPlateSet = {};

    Qot_GetPlateSet.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Qot_GetPlateSet
         * @interface IC2S
         * @property {number} market C2S market
         * @property {number} plateSetType C2S plateSetType
         */

        /**
         * Constructs a new C2S.
         * @memberof Qot_GetPlateSet
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Qot_GetPlateSet.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S market.
         * @member {number} market
         * @memberof Qot_GetPlateSet.C2S
         * @instance
         */
        C2S.prototype.market = 0;

        /**
         * C2S plateSetType.
         * @member {number} plateSetType
         * @memberof Qot_GetPlateSet.C2S
         * @instance
         */
        C2S.prototype.plateSetType = 0;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Qot_GetPlateSet.C2S
         * @static
         * @param {Qot_GetPlateSet.IC2S=} [properties] Properties to set
         * @returns {Qot_GetPlateSet.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Qot_GetPlateSet.C2S.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetPlateSet.C2S
         * @static
         * @param {Qot_GetPlateSet.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.market);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.plateSetType);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Qot_GetPlateSet.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetPlateSet.C2S
         * @static
         * @param {Qot_GetPlateSet.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetPlateSet.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetPlateSet.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetPlateSet.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.market = reader.int32();
                    break;
                case 2:
                    message.plateSetType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("market"))
                throw $util.ProtocolError("missing required 'market'", { instance: message });
            if (!message.hasOwnProperty("plateSetType"))
                throw $util.ProtocolError("missing required 'plateSetType'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetPlateSet.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetPlateSet.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Qot_GetPlateSet.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.market))
                return "market: integer expected";
            if (!$util.isInteger(message.plateSetType))
                return "plateSetType: integer expected";
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetPlateSet.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetPlateSet.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetPlateSet.C2S)
                return object;
            var message = new $root.Qot_GetPlateSet.C2S();
            if (object.market != null)
                message.market = object.market | 0;
            if (object.plateSetType != null)
                message.plateSetType = object.plateSetType | 0;
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetPlateSet.C2S
         * @static
         * @param {Qot_GetPlateSet.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.market = 0;
                object.plateSetType = 0;
            }
            if (message.market != null && message.hasOwnProperty("market"))
                object.market = message.market;
            if (message.plateSetType != null && message.hasOwnProperty("plateSetType"))
                object.plateSetType = message.plateSetType;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Qot_GetPlateSet.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Qot_GetPlateSet.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_GetPlateSet
         * @interface IS2C
         * @property {Array.<Qot_Common.IPlateInfo>|null} [plateInfoList] S2C plateInfoList
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_GetPlateSet
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_GetPlateSet.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.plateInfoList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C plateInfoList.
         * @member {Array.<Qot_Common.IPlateInfo>} plateInfoList
         * @memberof Qot_GetPlateSet.S2C
         * @instance
         */
        S2C.prototype.plateInfoList = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_GetPlateSet.S2C
         * @static
         * @param {Qot_GetPlateSet.IS2C=} [properties] Properties to set
         * @returns {Qot_GetPlateSet.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_GetPlateSet.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetPlateSet.S2C
         * @static
         * @param {Qot_GetPlateSet.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.plateInfoList != null && message.plateInfoList.length)
                for (var i = 0; i < message.plateInfoList.length; ++i)
                    $root.Qot_Common.PlateInfo.encode(message.plateInfoList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_GetPlateSet.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetPlateSet.S2C
         * @static
         * @param {Qot_GetPlateSet.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetPlateSet.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetPlateSet.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetPlateSet.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.plateInfoList && message.plateInfoList.length))
                        message.plateInfoList = [];
                    message.plateInfoList.push($root.Qot_Common.PlateInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetPlateSet.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetPlateSet.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_GetPlateSet.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.plateInfoList != null && message.hasOwnProperty("plateInfoList")) {
                if (!Array.isArray(message.plateInfoList))
                    return "plateInfoList: array expected";
                for (var i = 0; i < message.plateInfoList.length; ++i) {
                    var error = $root.Qot_Common.PlateInfo.verify(message.plateInfoList[i]);
                    if (error)
                        return "plateInfoList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetPlateSet.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetPlateSet.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetPlateSet.S2C)
                return object;
            var message = new $root.Qot_GetPlateSet.S2C();
            if (object.plateInfoList) {
                if (!Array.isArray(object.plateInfoList))
                    throw TypeError(".Qot_GetPlateSet.S2C.plateInfoList: array expected");
                message.plateInfoList = [];
                for (var i = 0; i < object.plateInfoList.length; ++i) {
                    if (typeof object.plateInfoList[i] !== "object")
                        throw TypeError(".Qot_GetPlateSet.S2C.plateInfoList: object expected");
                    message.plateInfoList[i] = $root.Qot_Common.PlateInfo.fromObject(object.plateInfoList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetPlateSet.S2C
         * @static
         * @param {Qot_GetPlateSet.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.plateInfoList = [];
            if (message.plateInfoList && message.plateInfoList.length) {
                object.plateInfoList = [];
                for (var j = 0; j < message.plateInfoList.length; ++j)
                    object.plateInfoList[j] = $root.Qot_Common.PlateInfo.toObject(message.plateInfoList[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_GetPlateSet.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_GetPlateSet.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Qot_GetPlateSet
         * @interface IRequest
         * @property {Qot_GetPlateSet.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Qot_GetPlateSet
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Qot_GetPlateSet.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Qot_GetPlateSet.IC2S} c2s
         * @memberof Qot_GetPlateSet.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Qot_GetPlateSet.Request
         * @static
         * @param {Qot_GetPlateSet.IRequest=} [properties] Properties to set
         * @returns {Qot_GetPlateSet.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Qot_GetPlateSet.Request.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetPlateSet.Request
         * @static
         * @param {Qot_GetPlateSet.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_GetPlateSet.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Qot_GetPlateSet.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetPlateSet.Request
         * @static
         * @param {Qot_GetPlateSet.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetPlateSet.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetPlateSet.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetPlateSet.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Qot_GetPlateSet.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetPlateSet.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetPlateSet.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Qot_GetPlateSet.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_GetPlateSet.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetPlateSet.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetPlateSet.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetPlateSet.Request)
                return object;
            var message = new $root.Qot_GetPlateSet.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Qot_GetPlateSet.Request.c2s: object expected");
                message.c2s = $root.Qot_GetPlateSet.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetPlateSet.Request
         * @static
         * @param {Qot_GetPlateSet.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Qot_GetPlateSet.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Qot_GetPlateSet.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Qot_GetPlateSet.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_GetPlateSet
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_GetPlateSet.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_GetPlateSet
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_GetPlateSet.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_GetPlateSet.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_GetPlateSet.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_GetPlateSet.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_GetPlateSet.IS2C|null|undefined} s2c
         * @memberof Qot_GetPlateSet.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_GetPlateSet.Response
         * @static
         * @param {Qot_GetPlateSet.IResponse=} [properties] Properties to set
         * @returns {Qot_GetPlateSet.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_GetPlateSet.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetPlateSet.Response
         * @static
         * @param {Qot_GetPlateSet.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_GetPlateSet.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_GetPlateSet.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetPlateSet.Response
         * @static
         * @param {Qot_GetPlateSet.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetPlateSet.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetPlateSet.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetPlateSet.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_GetPlateSet.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetPlateSet.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetPlateSet.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_GetPlateSet.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_GetPlateSet.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetPlateSet.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetPlateSet.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetPlateSet.Response)
                return object;
            var message = new $root.Qot_GetPlateSet.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_GetPlateSet.Response.s2c: object expected");
                message.s2c = $root.Qot_GetPlateSet.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetPlateSet.Response
         * @static
         * @param {Qot_GetPlateSet.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_GetPlateSet.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_GetPlateSet.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_GetPlateSet;
})();

$root.Qot_GetRT = (function() {

    /**
     * Namespace Qot_GetRT.
     * @exports Qot_GetRT
     * @namespace
     */
    var Qot_GetRT = {};

    Qot_GetRT.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Qot_GetRT
         * @interface IC2S
         * @property {Qot_Common.ISecurity} security C2S security
         */

        /**
         * Constructs a new C2S.
         * @memberof Qot_GetRT
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Qot_GetRT.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_GetRT.C2S
         * @instance
         */
        C2S.prototype.security = null;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Qot_GetRT.C2S
         * @static
         * @param {Qot_GetRT.IC2S=} [properties] Properties to set
         * @returns {Qot_GetRT.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Qot_GetRT.C2S.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetRT.C2S
         * @static
         * @param {Qot_GetRT.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Qot_GetRT.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetRT.C2S
         * @static
         * @param {Qot_GetRT.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetRT.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetRT.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetRT.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetRT.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetRT.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Qot_GetRT.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetRT.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetRT.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetRT.C2S)
                return object;
            var message = new $root.Qot_GetRT.C2S();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_GetRT.C2S.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetRT.C2S
         * @static
         * @param {Qot_GetRT.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.security = null;
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Qot_GetRT.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Qot_GetRT.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_GetRT
         * @interface IS2C
         * @property {Qot_Common.ISecurity} security S2C security
         * @property {Array.<Qot_Common.ITimeShare>|null} [rtList] S2C rtList
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_GetRT
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_GetRT.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.rtList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_GetRT.S2C
         * @instance
         */
        S2C.prototype.security = null;

        /**
         * S2C rtList.
         * @member {Array.<Qot_Common.ITimeShare>} rtList
         * @memberof Qot_GetRT.S2C
         * @instance
         */
        S2C.prototype.rtList = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_GetRT.S2C
         * @static
         * @param {Qot_GetRT.IS2C=} [properties] Properties to set
         * @returns {Qot_GetRT.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_GetRT.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetRT.S2C
         * @static
         * @param {Qot_GetRT.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.rtList != null && message.rtList.length)
                for (var i = 0; i < message.rtList.length; ++i)
                    $root.Qot_Common.TimeShare.encode(message.rtList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_GetRT.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetRT.S2C
         * @static
         * @param {Qot_GetRT.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetRT.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetRT.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetRT.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.rtList && message.rtList.length))
                        message.rtList = [];
                    message.rtList.push($root.Qot_Common.TimeShare.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetRT.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetRT.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_GetRT.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            if (message.rtList != null && message.hasOwnProperty("rtList")) {
                if (!Array.isArray(message.rtList))
                    return "rtList: array expected";
                for (var i = 0; i < message.rtList.length; ++i) {
                    var error = $root.Qot_Common.TimeShare.verify(message.rtList[i]);
                    if (error)
                        return "rtList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetRT.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetRT.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetRT.S2C)
                return object;
            var message = new $root.Qot_GetRT.S2C();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_GetRT.S2C.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            if (object.rtList) {
                if (!Array.isArray(object.rtList))
                    throw TypeError(".Qot_GetRT.S2C.rtList: array expected");
                message.rtList = [];
                for (var i = 0; i < object.rtList.length; ++i) {
                    if (typeof object.rtList[i] !== "object")
                        throw TypeError(".Qot_GetRT.S2C.rtList: object expected");
                    message.rtList[i] = $root.Qot_Common.TimeShare.fromObject(object.rtList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetRT.S2C
         * @static
         * @param {Qot_GetRT.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.rtList = [];
            if (options.defaults)
                object.security = null;
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            if (message.rtList && message.rtList.length) {
                object.rtList = [];
                for (var j = 0; j < message.rtList.length; ++j)
                    object.rtList[j] = $root.Qot_Common.TimeShare.toObject(message.rtList[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_GetRT.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_GetRT.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Qot_GetRT
         * @interface IRequest
         * @property {Qot_GetRT.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Qot_GetRT
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Qot_GetRT.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Qot_GetRT.IC2S} c2s
         * @memberof Qot_GetRT.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Qot_GetRT.Request
         * @static
         * @param {Qot_GetRT.IRequest=} [properties] Properties to set
         * @returns {Qot_GetRT.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Qot_GetRT.Request.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetRT.Request
         * @static
         * @param {Qot_GetRT.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_GetRT.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Qot_GetRT.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetRT.Request
         * @static
         * @param {Qot_GetRT.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetRT.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetRT.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetRT.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Qot_GetRT.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetRT.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetRT.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Qot_GetRT.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_GetRT.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetRT.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetRT.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetRT.Request)
                return object;
            var message = new $root.Qot_GetRT.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Qot_GetRT.Request.c2s: object expected");
                message.c2s = $root.Qot_GetRT.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetRT.Request
         * @static
         * @param {Qot_GetRT.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Qot_GetRT.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Qot_GetRT.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Qot_GetRT.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_GetRT
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_GetRT.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_GetRT
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_GetRT.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_GetRT.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_GetRT.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_GetRT.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_GetRT.IS2C|null|undefined} s2c
         * @memberof Qot_GetRT.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_GetRT.Response
         * @static
         * @param {Qot_GetRT.IResponse=} [properties] Properties to set
         * @returns {Qot_GetRT.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_GetRT.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetRT.Response
         * @static
         * @param {Qot_GetRT.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_GetRT.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_GetRT.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetRT.Response
         * @static
         * @param {Qot_GetRT.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetRT.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetRT.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetRT.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_GetRT.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetRT.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetRT.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_GetRT.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_GetRT.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetRT.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetRT.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetRT.Response)
                return object;
            var message = new $root.Qot_GetRT.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_GetRT.Response.s2c: object expected");
                message.s2c = $root.Qot_GetRT.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetRT.Response
         * @static
         * @param {Qot_GetRT.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_GetRT.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_GetRT.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_GetRT;
})();

$root.Qot_GetReference = (function() {

    /**
     * Namespace Qot_GetReference.
     * @exports Qot_GetReference
     * @namespace
     */
    var Qot_GetReference = {};

    /**
     * ReferenceType enum.
     * @name Qot_GetReference.ReferenceType
     * @enum {string}
     * @property {number} ReferenceType_Unknow=0 ReferenceType_Unknow value
     * @property {number} ReferenceType_Warrant=1 ReferenceType_Warrant value
     */
    Qot_GetReference.ReferenceType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "ReferenceType_Unknow"] = 0;
        values[valuesById[1] = "ReferenceType_Warrant"] = 1;
        return values;
    })();

    Qot_GetReference.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Qot_GetReference
         * @interface IC2S
         * @property {Qot_Common.ISecurity} security C2S security
         * @property {number} referenceType C2S referenceType
         */

        /**
         * Constructs a new C2S.
         * @memberof Qot_GetReference
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Qot_GetReference.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_GetReference.C2S
         * @instance
         */
        C2S.prototype.security = null;

        /**
         * C2S referenceType.
         * @member {number} referenceType
         * @memberof Qot_GetReference.C2S
         * @instance
         */
        C2S.prototype.referenceType = 0;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Qot_GetReference.C2S
         * @static
         * @param {Qot_GetReference.IC2S=} [properties] Properties to set
         * @returns {Qot_GetReference.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Qot_GetReference.C2S.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetReference.C2S
         * @static
         * @param {Qot_GetReference.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.referenceType);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Qot_GetReference.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetReference.C2S
         * @static
         * @param {Qot_GetReference.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetReference.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetReference.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetReference.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.referenceType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            if (!message.hasOwnProperty("referenceType"))
                throw $util.ProtocolError("missing required 'referenceType'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetReference.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetReference.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Qot_GetReference.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            if (!$util.isInteger(message.referenceType))
                return "referenceType: integer expected";
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetReference.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetReference.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetReference.C2S)
                return object;
            var message = new $root.Qot_GetReference.C2S();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_GetReference.C2S.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            if (object.referenceType != null)
                message.referenceType = object.referenceType | 0;
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetReference.C2S
         * @static
         * @param {Qot_GetReference.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.security = null;
                object.referenceType = 0;
            }
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            if (message.referenceType != null && message.hasOwnProperty("referenceType"))
                object.referenceType = message.referenceType;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Qot_GetReference.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Qot_GetReference.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_GetReference
         * @interface IS2C
         * @property {Array.<Qot_Common.ISecurityStaticInfo>|null} [staticInfoList] S2C staticInfoList
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_GetReference
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_GetReference.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.staticInfoList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C staticInfoList.
         * @member {Array.<Qot_Common.ISecurityStaticInfo>} staticInfoList
         * @memberof Qot_GetReference.S2C
         * @instance
         */
        S2C.prototype.staticInfoList = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_GetReference.S2C
         * @static
         * @param {Qot_GetReference.IS2C=} [properties] Properties to set
         * @returns {Qot_GetReference.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_GetReference.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetReference.S2C
         * @static
         * @param {Qot_GetReference.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.staticInfoList != null && message.staticInfoList.length)
                for (var i = 0; i < message.staticInfoList.length; ++i)
                    $root.Qot_Common.SecurityStaticInfo.encode(message.staticInfoList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_GetReference.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetReference.S2C
         * @static
         * @param {Qot_GetReference.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetReference.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetReference.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetReference.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 2:
                    if (!(message.staticInfoList && message.staticInfoList.length))
                        message.staticInfoList = [];
                    message.staticInfoList.push($root.Qot_Common.SecurityStaticInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetReference.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetReference.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_GetReference.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.staticInfoList != null && message.hasOwnProperty("staticInfoList")) {
                if (!Array.isArray(message.staticInfoList))
                    return "staticInfoList: array expected";
                for (var i = 0; i < message.staticInfoList.length; ++i) {
                    var error = $root.Qot_Common.SecurityStaticInfo.verify(message.staticInfoList[i]);
                    if (error)
                        return "staticInfoList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetReference.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetReference.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetReference.S2C)
                return object;
            var message = new $root.Qot_GetReference.S2C();
            if (object.staticInfoList) {
                if (!Array.isArray(object.staticInfoList))
                    throw TypeError(".Qot_GetReference.S2C.staticInfoList: array expected");
                message.staticInfoList = [];
                for (var i = 0; i < object.staticInfoList.length; ++i) {
                    if (typeof object.staticInfoList[i] !== "object")
                        throw TypeError(".Qot_GetReference.S2C.staticInfoList: object expected");
                    message.staticInfoList[i] = $root.Qot_Common.SecurityStaticInfo.fromObject(object.staticInfoList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetReference.S2C
         * @static
         * @param {Qot_GetReference.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.staticInfoList = [];
            if (message.staticInfoList && message.staticInfoList.length) {
                object.staticInfoList = [];
                for (var j = 0; j < message.staticInfoList.length; ++j)
                    object.staticInfoList[j] = $root.Qot_Common.SecurityStaticInfo.toObject(message.staticInfoList[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_GetReference.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_GetReference.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Qot_GetReference
         * @interface IRequest
         * @property {Qot_GetReference.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Qot_GetReference
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Qot_GetReference.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Qot_GetReference.IC2S} c2s
         * @memberof Qot_GetReference.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Qot_GetReference.Request
         * @static
         * @param {Qot_GetReference.IRequest=} [properties] Properties to set
         * @returns {Qot_GetReference.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Qot_GetReference.Request.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetReference.Request
         * @static
         * @param {Qot_GetReference.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_GetReference.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Qot_GetReference.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetReference.Request
         * @static
         * @param {Qot_GetReference.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetReference.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetReference.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetReference.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Qot_GetReference.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetReference.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetReference.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Qot_GetReference.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_GetReference.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetReference.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetReference.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetReference.Request)
                return object;
            var message = new $root.Qot_GetReference.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Qot_GetReference.Request.c2s: object expected");
                message.c2s = $root.Qot_GetReference.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetReference.Request
         * @static
         * @param {Qot_GetReference.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Qot_GetReference.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Qot_GetReference.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Qot_GetReference.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_GetReference
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_GetReference.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_GetReference
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_GetReference.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_GetReference.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_GetReference.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_GetReference.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_GetReference.IS2C|null|undefined} s2c
         * @memberof Qot_GetReference.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_GetReference.Response
         * @static
         * @param {Qot_GetReference.IResponse=} [properties] Properties to set
         * @returns {Qot_GetReference.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_GetReference.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetReference.Response
         * @static
         * @param {Qot_GetReference.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_GetReference.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_GetReference.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetReference.Response
         * @static
         * @param {Qot_GetReference.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetReference.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetReference.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetReference.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_GetReference.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetReference.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetReference.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_GetReference.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_GetReference.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetReference.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetReference.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetReference.Response)
                return object;
            var message = new $root.Qot_GetReference.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_GetReference.Response.s2c: object expected");
                message.s2c = $root.Qot_GetReference.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetReference.Response
         * @static
         * @param {Qot_GetReference.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_GetReference.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_GetReference.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_GetReference;
})();

$root.Qot_GetRehab = (function() {

    /**
     * Namespace Qot_GetRehab.
     * @exports Qot_GetRehab
     * @namespace
     */
    var Qot_GetRehab = {};

    Qot_GetRehab.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Qot_GetRehab
         * @interface IC2S
         * @property {Array.<Qot_Common.ISecurity>|null} [securityList] C2S securityList
         */

        /**
         * Constructs a new C2S.
         * @memberof Qot_GetRehab
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Qot_GetRehab.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            this.securityList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S securityList.
         * @member {Array.<Qot_Common.ISecurity>} securityList
         * @memberof Qot_GetRehab.C2S
         * @instance
         */
        C2S.prototype.securityList = $util.emptyArray;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Qot_GetRehab.C2S
         * @static
         * @param {Qot_GetRehab.IC2S=} [properties] Properties to set
         * @returns {Qot_GetRehab.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Qot_GetRehab.C2S.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetRehab.C2S
         * @static
         * @param {Qot_GetRehab.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.securityList != null && message.securityList.length)
                for (var i = 0; i < message.securityList.length; ++i)
                    $root.Qot_Common.Security.encode(message.securityList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Qot_GetRehab.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetRehab.C2S
         * @static
         * @param {Qot_GetRehab.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetRehab.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetRehab.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetRehab.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.securityList && message.securityList.length))
                        message.securityList = [];
                    message.securityList.push($root.Qot_Common.Security.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetRehab.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetRehab.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Qot_GetRehab.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.securityList != null && message.hasOwnProperty("securityList")) {
                if (!Array.isArray(message.securityList))
                    return "securityList: array expected";
                for (var i = 0; i < message.securityList.length; ++i) {
                    var error = $root.Qot_Common.Security.verify(message.securityList[i]);
                    if (error)
                        return "securityList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetRehab.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetRehab.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetRehab.C2S)
                return object;
            var message = new $root.Qot_GetRehab.C2S();
            if (object.securityList) {
                if (!Array.isArray(object.securityList))
                    throw TypeError(".Qot_GetRehab.C2S.securityList: array expected");
                message.securityList = [];
                for (var i = 0; i < object.securityList.length; ++i) {
                    if (typeof object.securityList[i] !== "object")
                        throw TypeError(".Qot_GetRehab.C2S.securityList: object expected");
                    message.securityList[i] = $root.Qot_Common.Security.fromObject(object.securityList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetRehab.C2S
         * @static
         * @param {Qot_GetRehab.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.securityList = [];
            if (message.securityList && message.securityList.length) {
                object.securityList = [];
                for (var j = 0; j < message.securityList.length; ++j)
                    object.securityList[j] = $root.Qot_Common.Security.toObject(message.securityList[j], options);
            }
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Qot_GetRehab.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Qot_GetRehab.SecurityRehab = (function() {

        /**
         * Properties of a SecurityRehab.
         * @memberof Qot_GetRehab
         * @interface ISecurityRehab
         * @property {Qot_Common.ISecurity} security SecurityRehab security
         * @property {Array.<Qot_Common.IRehab>|null} [rehabList] SecurityRehab rehabList
         */

        /**
         * Constructs a new SecurityRehab.
         * @memberof Qot_GetRehab
         * @classdesc Represents a SecurityRehab.
         * @implements ISecurityRehab
         * @constructor
         * @param {Qot_GetRehab.ISecurityRehab=} [properties] Properties to set
         */
        function SecurityRehab(properties) {
            this.rehabList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SecurityRehab security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_GetRehab.SecurityRehab
         * @instance
         */
        SecurityRehab.prototype.security = null;

        /**
         * SecurityRehab rehabList.
         * @member {Array.<Qot_Common.IRehab>} rehabList
         * @memberof Qot_GetRehab.SecurityRehab
         * @instance
         */
        SecurityRehab.prototype.rehabList = $util.emptyArray;

        /**
         * Creates a new SecurityRehab instance using the specified properties.
         * @function create
         * @memberof Qot_GetRehab.SecurityRehab
         * @static
         * @param {Qot_GetRehab.ISecurityRehab=} [properties] Properties to set
         * @returns {Qot_GetRehab.SecurityRehab} SecurityRehab instance
         */
        SecurityRehab.create = function create(properties) {
            return new SecurityRehab(properties);
        };

        /**
         * Encodes the specified SecurityRehab message. Does not implicitly {@link Qot_GetRehab.SecurityRehab.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetRehab.SecurityRehab
         * @static
         * @param {Qot_GetRehab.ISecurityRehab} message SecurityRehab message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SecurityRehab.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.rehabList != null && message.rehabList.length)
                for (var i = 0; i < message.rehabList.length; ++i)
                    $root.Qot_Common.Rehab.encode(message.rehabList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SecurityRehab message, length delimited. Does not implicitly {@link Qot_GetRehab.SecurityRehab.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetRehab.SecurityRehab
         * @static
         * @param {Qot_GetRehab.ISecurityRehab} message SecurityRehab message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SecurityRehab.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SecurityRehab message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetRehab.SecurityRehab
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetRehab.SecurityRehab} SecurityRehab
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SecurityRehab.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetRehab.SecurityRehab();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.rehabList && message.rehabList.length))
                        message.rehabList = [];
                    message.rehabList.push($root.Qot_Common.Rehab.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            return message;
        };

        /**
         * Decodes a SecurityRehab message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetRehab.SecurityRehab
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetRehab.SecurityRehab} SecurityRehab
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SecurityRehab.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SecurityRehab message.
         * @function verify
         * @memberof Qot_GetRehab.SecurityRehab
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SecurityRehab.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            if (message.rehabList != null && message.hasOwnProperty("rehabList")) {
                if (!Array.isArray(message.rehabList))
                    return "rehabList: array expected";
                for (var i = 0; i < message.rehabList.length; ++i) {
                    var error = $root.Qot_Common.Rehab.verify(message.rehabList[i]);
                    if (error)
                        return "rehabList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a SecurityRehab message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetRehab.SecurityRehab
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetRehab.SecurityRehab} SecurityRehab
         */
        SecurityRehab.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetRehab.SecurityRehab)
                return object;
            var message = new $root.Qot_GetRehab.SecurityRehab();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_GetRehab.SecurityRehab.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            if (object.rehabList) {
                if (!Array.isArray(object.rehabList))
                    throw TypeError(".Qot_GetRehab.SecurityRehab.rehabList: array expected");
                message.rehabList = [];
                for (var i = 0; i < object.rehabList.length; ++i) {
                    if (typeof object.rehabList[i] !== "object")
                        throw TypeError(".Qot_GetRehab.SecurityRehab.rehabList: object expected");
                    message.rehabList[i] = $root.Qot_Common.Rehab.fromObject(object.rehabList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a SecurityRehab message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetRehab.SecurityRehab
         * @static
         * @param {Qot_GetRehab.SecurityRehab} message SecurityRehab
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SecurityRehab.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.rehabList = [];
            if (options.defaults)
                object.security = null;
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            if (message.rehabList && message.rehabList.length) {
                object.rehabList = [];
                for (var j = 0; j < message.rehabList.length; ++j)
                    object.rehabList[j] = $root.Qot_Common.Rehab.toObject(message.rehabList[j], options);
            }
            return object;
        };

        /**
         * Converts this SecurityRehab to JSON.
         * @function toJSON
         * @memberof Qot_GetRehab.SecurityRehab
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SecurityRehab.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SecurityRehab;
    })();

    Qot_GetRehab.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_GetRehab
         * @interface IS2C
         * @property {Array.<Qot_GetRehab.ISecurityRehab>|null} [securityRehabList] S2C securityRehabList
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_GetRehab
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_GetRehab.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.securityRehabList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C securityRehabList.
         * @member {Array.<Qot_GetRehab.ISecurityRehab>} securityRehabList
         * @memberof Qot_GetRehab.S2C
         * @instance
         */
        S2C.prototype.securityRehabList = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_GetRehab.S2C
         * @static
         * @param {Qot_GetRehab.IS2C=} [properties] Properties to set
         * @returns {Qot_GetRehab.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_GetRehab.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetRehab.S2C
         * @static
         * @param {Qot_GetRehab.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.securityRehabList != null && message.securityRehabList.length)
                for (var i = 0; i < message.securityRehabList.length; ++i)
                    $root.Qot_GetRehab.SecurityRehab.encode(message.securityRehabList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_GetRehab.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetRehab.S2C
         * @static
         * @param {Qot_GetRehab.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetRehab.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetRehab.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetRehab.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.securityRehabList && message.securityRehabList.length))
                        message.securityRehabList = [];
                    message.securityRehabList.push($root.Qot_GetRehab.SecurityRehab.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetRehab.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetRehab.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_GetRehab.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.securityRehabList != null && message.hasOwnProperty("securityRehabList")) {
                if (!Array.isArray(message.securityRehabList))
                    return "securityRehabList: array expected";
                for (var i = 0; i < message.securityRehabList.length; ++i) {
                    var error = $root.Qot_GetRehab.SecurityRehab.verify(message.securityRehabList[i]);
                    if (error)
                        return "securityRehabList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetRehab.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetRehab.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetRehab.S2C)
                return object;
            var message = new $root.Qot_GetRehab.S2C();
            if (object.securityRehabList) {
                if (!Array.isArray(object.securityRehabList))
                    throw TypeError(".Qot_GetRehab.S2C.securityRehabList: array expected");
                message.securityRehabList = [];
                for (var i = 0; i < object.securityRehabList.length; ++i) {
                    if (typeof object.securityRehabList[i] !== "object")
                        throw TypeError(".Qot_GetRehab.S2C.securityRehabList: object expected");
                    message.securityRehabList[i] = $root.Qot_GetRehab.SecurityRehab.fromObject(object.securityRehabList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetRehab.S2C
         * @static
         * @param {Qot_GetRehab.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.securityRehabList = [];
            if (message.securityRehabList && message.securityRehabList.length) {
                object.securityRehabList = [];
                for (var j = 0; j < message.securityRehabList.length; ++j)
                    object.securityRehabList[j] = $root.Qot_GetRehab.SecurityRehab.toObject(message.securityRehabList[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_GetRehab.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_GetRehab.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Qot_GetRehab
         * @interface IRequest
         * @property {Qot_GetRehab.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Qot_GetRehab
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Qot_GetRehab.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Qot_GetRehab.IC2S} c2s
         * @memberof Qot_GetRehab.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Qot_GetRehab.Request
         * @static
         * @param {Qot_GetRehab.IRequest=} [properties] Properties to set
         * @returns {Qot_GetRehab.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Qot_GetRehab.Request.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetRehab.Request
         * @static
         * @param {Qot_GetRehab.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_GetRehab.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Qot_GetRehab.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetRehab.Request
         * @static
         * @param {Qot_GetRehab.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetRehab.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetRehab.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetRehab.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Qot_GetRehab.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetRehab.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetRehab.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Qot_GetRehab.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_GetRehab.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetRehab.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetRehab.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetRehab.Request)
                return object;
            var message = new $root.Qot_GetRehab.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Qot_GetRehab.Request.c2s: object expected");
                message.c2s = $root.Qot_GetRehab.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetRehab.Request
         * @static
         * @param {Qot_GetRehab.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Qot_GetRehab.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Qot_GetRehab.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Qot_GetRehab.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_GetRehab
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_GetRehab.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_GetRehab
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_GetRehab.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_GetRehab.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_GetRehab.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_GetRehab.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_GetRehab.IS2C|null|undefined} s2c
         * @memberof Qot_GetRehab.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_GetRehab.Response
         * @static
         * @param {Qot_GetRehab.IResponse=} [properties] Properties to set
         * @returns {Qot_GetRehab.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_GetRehab.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetRehab.Response
         * @static
         * @param {Qot_GetRehab.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_GetRehab.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_GetRehab.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetRehab.Response
         * @static
         * @param {Qot_GetRehab.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetRehab.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetRehab.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetRehab.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_GetRehab.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetRehab.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetRehab.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_GetRehab.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_GetRehab.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetRehab.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetRehab.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetRehab.Response)
                return object;
            var message = new $root.Qot_GetRehab.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_GetRehab.Response.s2c: object expected");
                message.s2c = $root.Qot_GetRehab.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetRehab.Response
         * @static
         * @param {Qot_GetRehab.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_GetRehab.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_GetRehab.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_GetRehab;
})();

$root.Qot_GetSecuritySnapshot = (function() {

    /**
     * Namespace Qot_GetSecuritySnapshot.
     * @exports Qot_GetSecuritySnapshot
     * @namespace
     */
    var Qot_GetSecuritySnapshot = {};

    Qot_GetSecuritySnapshot.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Qot_GetSecuritySnapshot
         * @interface IC2S
         * @property {Array.<Qot_Common.ISecurity>|null} [securityList] C2S securityList
         */

        /**
         * Constructs a new C2S.
         * @memberof Qot_GetSecuritySnapshot
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Qot_GetSecuritySnapshot.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            this.securityList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S securityList.
         * @member {Array.<Qot_Common.ISecurity>} securityList
         * @memberof Qot_GetSecuritySnapshot.C2S
         * @instance
         */
        C2S.prototype.securityList = $util.emptyArray;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Qot_GetSecuritySnapshot.C2S
         * @static
         * @param {Qot_GetSecuritySnapshot.IC2S=} [properties] Properties to set
         * @returns {Qot_GetSecuritySnapshot.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Qot_GetSecuritySnapshot.C2S.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetSecuritySnapshot.C2S
         * @static
         * @param {Qot_GetSecuritySnapshot.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.securityList != null && message.securityList.length)
                for (var i = 0; i < message.securityList.length; ++i)
                    $root.Qot_Common.Security.encode(message.securityList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Qot_GetSecuritySnapshot.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetSecuritySnapshot.C2S
         * @static
         * @param {Qot_GetSecuritySnapshot.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetSecuritySnapshot.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetSecuritySnapshot.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetSecuritySnapshot.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.securityList && message.securityList.length))
                        message.securityList = [];
                    message.securityList.push($root.Qot_Common.Security.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetSecuritySnapshot.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetSecuritySnapshot.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Qot_GetSecuritySnapshot.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.securityList != null && message.hasOwnProperty("securityList")) {
                if (!Array.isArray(message.securityList))
                    return "securityList: array expected";
                for (var i = 0; i < message.securityList.length; ++i) {
                    var error = $root.Qot_Common.Security.verify(message.securityList[i]);
                    if (error)
                        return "securityList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetSecuritySnapshot.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetSecuritySnapshot.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetSecuritySnapshot.C2S)
                return object;
            var message = new $root.Qot_GetSecuritySnapshot.C2S();
            if (object.securityList) {
                if (!Array.isArray(object.securityList))
                    throw TypeError(".Qot_GetSecuritySnapshot.C2S.securityList: array expected");
                message.securityList = [];
                for (var i = 0; i < object.securityList.length; ++i) {
                    if (typeof object.securityList[i] !== "object")
                        throw TypeError(".Qot_GetSecuritySnapshot.C2S.securityList: object expected");
                    message.securityList[i] = $root.Qot_Common.Security.fromObject(object.securityList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetSecuritySnapshot.C2S
         * @static
         * @param {Qot_GetSecuritySnapshot.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.securityList = [];
            if (message.securityList && message.securityList.length) {
                object.securityList = [];
                for (var j = 0; j < message.securityList.length; ++j)
                    object.securityList[j] = $root.Qot_Common.Security.toObject(message.securityList[j], options);
            }
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Qot_GetSecuritySnapshot.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Qot_GetSecuritySnapshot.EquitySnapshotExData = (function() {

        /**
         * Properties of an EquitySnapshotExData.
         * @memberof Qot_GetSecuritySnapshot
         * @interface IEquitySnapshotExData
         * @property {number|Long} issuedShares EquitySnapshotExData issuedShares
         * @property {number} issuedMarketVal EquitySnapshotExData issuedMarketVal
         * @property {number} netAsset EquitySnapshotExData netAsset
         * @property {number} netProfit EquitySnapshotExData netProfit
         * @property {number} earningsPershare EquitySnapshotExData earningsPershare
         * @property {number|Long} outstandingShares EquitySnapshotExData outstandingShares
         * @property {number} outstandingMarketVal EquitySnapshotExData outstandingMarketVal
         * @property {number} netAssetPershare EquitySnapshotExData netAssetPershare
         * @property {number} eyRate EquitySnapshotExData eyRate
         * @property {number} peRate EquitySnapshotExData peRate
         * @property {number} pbRate EquitySnapshotExData pbRate
         * @property {number} peTTMRate EquitySnapshotExData peTTMRate
         */

        /**
         * Constructs a new EquitySnapshotExData.
         * @memberof Qot_GetSecuritySnapshot
         * @classdesc Represents an EquitySnapshotExData.
         * @implements IEquitySnapshotExData
         * @constructor
         * @param {Qot_GetSecuritySnapshot.IEquitySnapshotExData=} [properties] Properties to set
         */
        function EquitySnapshotExData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EquitySnapshotExData issuedShares.
         * @member {number|Long} issuedShares
         * @memberof Qot_GetSecuritySnapshot.EquitySnapshotExData
         * @instance
         */
        EquitySnapshotExData.prototype.issuedShares = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * EquitySnapshotExData issuedMarketVal.
         * @member {number} issuedMarketVal
         * @memberof Qot_GetSecuritySnapshot.EquitySnapshotExData
         * @instance
         */
        EquitySnapshotExData.prototype.issuedMarketVal = 0;

        /**
         * EquitySnapshotExData netAsset.
         * @member {number} netAsset
         * @memberof Qot_GetSecuritySnapshot.EquitySnapshotExData
         * @instance
         */
        EquitySnapshotExData.prototype.netAsset = 0;

        /**
         * EquitySnapshotExData netProfit.
         * @member {number} netProfit
         * @memberof Qot_GetSecuritySnapshot.EquitySnapshotExData
         * @instance
         */
        EquitySnapshotExData.prototype.netProfit = 0;

        /**
         * EquitySnapshotExData earningsPershare.
         * @member {number} earningsPershare
         * @memberof Qot_GetSecuritySnapshot.EquitySnapshotExData
         * @instance
         */
        EquitySnapshotExData.prototype.earningsPershare = 0;

        /**
         * EquitySnapshotExData outstandingShares.
         * @member {number|Long} outstandingShares
         * @memberof Qot_GetSecuritySnapshot.EquitySnapshotExData
         * @instance
         */
        EquitySnapshotExData.prototype.outstandingShares = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * EquitySnapshotExData outstandingMarketVal.
         * @member {number} outstandingMarketVal
         * @memberof Qot_GetSecuritySnapshot.EquitySnapshotExData
         * @instance
         */
        EquitySnapshotExData.prototype.outstandingMarketVal = 0;

        /**
         * EquitySnapshotExData netAssetPershare.
         * @member {number} netAssetPershare
         * @memberof Qot_GetSecuritySnapshot.EquitySnapshotExData
         * @instance
         */
        EquitySnapshotExData.prototype.netAssetPershare = 0;

        /**
         * EquitySnapshotExData eyRate.
         * @member {number} eyRate
         * @memberof Qot_GetSecuritySnapshot.EquitySnapshotExData
         * @instance
         */
        EquitySnapshotExData.prototype.eyRate = 0;

        /**
         * EquitySnapshotExData peRate.
         * @member {number} peRate
         * @memberof Qot_GetSecuritySnapshot.EquitySnapshotExData
         * @instance
         */
        EquitySnapshotExData.prototype.peRate = 0;

        /**
         * EquitySnapshotExData pbRate.
         * @member {number} pbRate
         * @memberof Qot_GetSecuritySnapshot.EquitySnapshotExData
         * @instance
         */
        EquitySnapshotExData.prototype.pbRate = 0;

        /**
         * EquitySnapshotExData peTTMRate.
         * @member {number} peTTMRate
         * @memberof Qot_GetSecuritySnapshot.EquitySnapshotExData
         * @instance
         */
        EquitySnapshotExData.prototype.peTTMRate = 0;

        /**
         * Creates a new EquitySnapshotExData instance using the specified properties.
         * @function create
         * @memberof Qot_GetSecuritySnapshot.EquitySnapshotExData
         * @static
         * @param {Qot_GetSecuritySnapshot.IEquitySnapshotExData=} [properties] Properties to set
         * @returns {Qot_GetSecuritySnapshot.EquitySnapshotExData} EquitySnapshotExData instance
         */
        EquitySnapshotExData.create = function create(properties) {
            return new EquitySnapshotExData(properties);
        };

        /**
         * Encodes the specified EquitySnapshotExData message. Does not implicitly {@link Qot_GetSecuritySnapshot.EquitySnapshotExData.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetSecuritySnapshot.EquitySnapshotExData
         * @static
         * @param {Qot_GetSecuritySnapshot.IEquitySnapshotExData} message EquitySnapshotExData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EquitySnapshotExData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.issuedShares);
            writer.uint32(/* id 2, wireType 1 =*/17).double(message.issuedMarketVal);
            writer.uint32(/* id 3, wireType 1 =*/25).double(message.netAsset);
            writer.uint32(/* id 4, wireType 1 =*/33).double(message.netProfit);
            writer.uint32(/* id 5, wireType 1 =*/41).double(message.earningsPershare);
            writer.uint32(/* id 6, wireType 0 =*/48).int64(message.outstandingShares);
            writer.uint32(/* id 7, wireType 1 =*/57).double(message.outstandingMarketVal);
            writer.uint32(/* id 8, wireType 1 =*/65).double(message.netAssetPershare);
            writer.uint32(/* id 9, wireType 1 =*/73).double(message.eyRate);
            writer.uint32(/* id 10, wireType 1 =*/81).double(message.peRate);
            writer.uint32(/* id 11, wireType 1 =*/89).double(message.pbRate);
            writer.uint32(/* id 12, wireType 1 =*/97).double(message.peTTMRate);
            return writer;
        };

        /**
         * Encodes the specified EquitySnapshotExData message, length delimited. Does not implicitly {@link Qot_GetSecuritySnapshot.EquitySnapshotExData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetSecuritySnapshot.EquitySnapshotExData
         * @static
         * @param {Qot_GetSecuritySnapshot.IEquitySnapshotExData} message EquitySnapshotExData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EquitySnapshotExData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EquitySnapshotExData message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetSecuritySnapshot.EquitySnapshotExData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetSecuritySnapshot.EquitySnapshotExData} EquitySnapshotExData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EquitySnapshotExData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetSecuritySnapshot.EquitySnapshotExData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.issuedShares = reader.int64();
                    break;
                case 2:
                    message.issuedMarketVal = reader.double();
                    break;
                case 3:
                    message.netAsset = reader.double();
                    break;
                case 4:
                    message.netProfit = reader.double();
                    break;
                case 5:
                    message.earningsPershare = reader.double();
                    break;
                case 6:
                    message.outstandingShares = reader.int64();
                    break;
                case 7:
                    message.outstandingMarketVal = reader.double();
                    break;
                case 8:
                    message.netAssetPershare = reader.double();
                    break;
                case 9:
                    message.eyRate = reader.double();
                    break;
                case 10:
                    message.peRate = reader.double();
                    break;
                case 11:
                    message.pbRate = reader.double();
                    break;
                case 12:
                    message.peTTMRate = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("issuedShares"))
                throw $util.ProtocolError("missing required 'issuedShares'", { instance: message });
            if (!message.hasOwnProperty("issuedMarketVal"))
                throw $util.ProtocolError("missing required 'issuedMarketVal'", { instance: message });
            if (!message.hasOwnProperty("netAsset"))
                throw $util.ProtocolError("missing required 'netAsset'", { instance: message });
            if (!message.hasOwnProperty("netProfit"))
                throw $util.ProtocolError("missing required 'netProfit'", { instance: message });
            if (!message.hasOwnProperty("earningsPershare"))
                throw $util.ProtocolError("missing required 'earningsPershare'", { instance: message });
            if (!message.hasOwnProperty("outstandingShares"))
                throw $util.ProtocolError("missing required 'outstandingShares'", { instance: message });
            if (!message.hasOwnProperty("outstandingMarketVal"))
                throw $util.ProtocolError("missing required 'outstandingMarketVal'", { instance: message });
            if (!message.hasOwnProperty("netAssetPershare"))
                throw $util.ProtocolError("missing required 'netAssetPershare'", { instance: message });
            if (!message.hasOwnProperty("eyRate"))
                throw $util.ProtocolError("missing required 'eyRate'", { instance: message });
            if (!message.hasOwnProperty("peRate"))
                throw $util.ProtocolError("missing required 'peRate'", { instance: message });
            if (!message.hasOwnProperty("pbRate"))
                throw $util.ProtocolError("missing required 'pbRate'", { instance: message });
            if (!message.hasOwnProperty("peTTMRate"))
                throw $util.ProtocolError("missing required 'peTTMRate'", { instance: message });
            return message;
        };

        /**
         * Decodes an EquitySnapshotExData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetSecuritySnapshot.EquitySnapshotExData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetSecuritySnapshot.EquitySnapshotExData} EquitySnapshotExData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EquitySnapshotExData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EquitySnapshotExData message.
         * @function verify
         * @memberof Qot_GetSecuritySnapshot.EquitySnapshotExData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EquitySnapshotExData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.issuedShares) && !(message.issuedShares && $util.isInteger(message.issuedShares.low) && $util.isInteger(message.issuedShares.high)))
                return "issuedShares: integer|Long expected";
            if (typeof message.issuedMarketVal !== "number")
                return "issuedMarketVal: number expected";
            if (typeof message.netAsset !== "number")
                return "netAsset: number expected";
            if (typeof message.netProfit !== "number")
                return "netProfit: number expected";
            if (typeof message.earningsPershare !== "number")
                return "earningsPershare: number expected";
            if (!$util.isInteger(message.outstandingShares) && !(message.outstandingShares && $util.isInteger(message.outstandingShares.low) && $util.isInteger(message.outstandingShares.high)))
                return "outstandingShares: integer|Long expected";
            if (typeof message.outstandingMarketVal !== "number")
                return "outstandingMarketVal: number expected";
            if (typeof message.netAssetPershare !== "number")
                return "netAssetPershare: number expected";
            if (typeof message.eyRate !== "number")
                return "eyRate: number expected";
            if (typeof message.peRate !== "number")
                return "peRate: number expected";
            if (typeof message.pbRate !== "number")
                return "pbRate: number expected";
            if (typeof message.peTTMRate !== "number")
                return "peTTMRate: number expected";
            return null;
        };

        /**
         * Creates an EquitySnapshotExData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetSecuritySnapshot.EquitySnapshotExData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetSecuritySnapshot.EquitySnapshotExData} EquitySnapshotExData
         */
        EquitySnapshotExData.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetSecuritySnapshot.EquitySnapshotExData)
                return object;
            var message = new $root.Qot_GetSecuritySnapshot.EquitySnapshotExData();
            if (object.issuedShares != null)
                if ($util.Long)
                    (message.issuedShares = $util.Long.fromValue(object.issuedShares)).unsigned = false;
                else if (typeof object.issuedShares === "string")
                    message.issuedShares = parseInt(object.issuedShares, 10);
                else if (typeof object.issuedShares === "number")
                    message.issuedShares = object.issuedShares;
                else if (typeof object.issuedShares === "object")
                    message.issuedShares = new $util.LongBits(object.issuedShares.low >>> 0, object.issuedShares.high >>> 0).toNumber();
            if (object.issuedMarketVal != null)
                message.issuedMarketVal = Number(object.issuedMarketVal);
            if (object.netAsset != null)
                message.netAsset = Number(object.netAsset);
            if (object.netProfit != null)
                message.netProfit = Number(object.netProfit);
            if (object.earningsPershare != null)
                message.earningsPershare = Number(object.earningsPershare);
            if (object.outstandingShares != null)
                if ($util.Long)
                    (message.outstandingShares = $util.Long.fromValue(object.outstandingShares)).unsigned = false;
                else if (typeof object.outstandingShares === "string")
                    message.outstandingShares = parseInt(object.outstandingShares, 10);
                else if (typeof object.outstandingShares === "number")
                    message.outstandingShares = object.outstandingShares;
                else if (typeof object.outstandingShares === "object")
                    message.outstandingShares = new $util.LongBits(object.outstandingShares.low >>> 0, object.outstandingShares.high >>> 0).toNumber();
            if (object.outstandingMarketVal != null)
                message.outstandingMarketVal = Number(object.outstandingMarketVal);
            if (object.netAssetPershare != null)
                message.netAssetPershare = Number(object.netAssetPershare);
            if (object.eyRate != null)
                message.eyRate = Number(object.eyRate);
            if (object.peRate != null)
                message.peRate = Number(object.peRate);
            if (object.pbRate != null)
                message.pbRate = Number(object.pbRate);
            if (object.peTTMRate != null)
                message.peTTMRate = Number(object.peTTMRate);
            return message;
        };

        /**
         * Creates a plain object from an EquitySnapshotExData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetSecuritySnapshot.EquitySnapshotExData
         * @static
         * @param {Qot_GetSecuritySnapshot.EquitySnapshotExData} message EquitySnapshotExData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EquitySnapshotExData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.issuedShares = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.issuedShares = options.longs === String ? "0" : 0;
                object.issuedMarketVal = 0;
                object.netAsset = 0;
                object.netProfit = 0;
                object.earningsPershare = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.outstandingShares = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.outstandingShares = options.longs === String ? "0" : 0;
                object.outstandingMarketVal = 0;
                object.netAssetPershare = 0;
                object.eyRate = 0;
                object.peRate = 0;
                object.pbRate = 0;
                object.peTTMRate = 0;
            }
            if (message.issuedShares != null && message.hasOwnProperty("issuedShares"))
                if (typeof message.issuedShares === "number")
                    object.issuedShares = options.longs === String ? String(message.issuedShares) : message.issuedShares;
                else
                    object.issuedShares = options.longs === String ? $util.Long.prototype.toString.call(message.issuedShares) : options.longs === Number ? new $util.LongBits(message.issuedShares.low >>> 0, message.issuedShares.high >>> 0).toNumber() : message.issuedShares;
            if (message.issuedMarketVal != null && message.hasOwnProperty("issuedMarketVal"))
                object.issuedMarketVal = options.json && !isFinite(message.issuedMarketVal) ? String(message.issuedMarketVal) : message.issuedMarketVal;
            if (message.netAsset != null && message.hasOwnProperty("netAsset"))
                object.netAsset = options.json && !isFinite(message.netAsset) ? String(message.netAsset) : message.netAsset;
            if (message.netProfit != null && message.hasOwnProperty("netProfit"))
                object.netProfit = options.json && !isFinite(message.netProfit) ? String(message.netProfit) : message.netProfit;
            if (message.earningsPershare != null && message.hasOwnProperty("earningsPershare"))
                object.earningsPershare = options.json && !isFinite(message.earningsPershare) ? String(message.earningsPershare) : message.earningsPershare;
            if (message.outstandingShares != null && message.hasOwnProperty("outstandingShares"))
                if (typeof message.outstandingShares === "number")
                    object.outstandingShares = options.longs === String ? String(message.outstandingShares) : message.outstandingShares;
                else
                    object.outstandingShares = options.longs === String ? $util.Long.prototype.toString.call(message.outstandingShares) : options.longs === Number ? new $util.LongBits(message.outstandingShares.low >>> 0, message.outstandingShares.high >>> 0).toNumber() : message.outstandingShares;
            if (message.outstandingMarketVal != null && message.hasOwnProperty("outstandingMarketVal"))
                object.outstandingMarketVal = options.json && !isFinite(message.outstandingMarketVal) ? String(message.outstandingMarketVal) : message.outstandingMarketVal;
            if (message.netAssetPershare != null && message.hasOwnProperty("netAssetPershare"))
                object.netAssetPershare = options.json && !isFinite(message.netAssetPershare) ? String(message.netAssetPershare) : message.netAssetPershare;
            if (message.eyRate != null && message.hasOwnProperty("eyRate"))
                object.eyRate = options.json && !isFinite(message.eyRate) ? String(message.eyRate) : message.eyRate;
            if (message.peRate != null && message.hasOwnProperty("peRate"))
                object.peRate = options.json && !isFinite(message.peRate) ? String(message.peRate) : message.peRate;
            if (message.pbRate != null && message.hasOwnProperty("pbRate"))
                object.pbRate = options.json && !isFinite(message.pbRate) ? String(message.pbRate) : message.pbRate;
            if (message.peTTMRate != null && message.hasOwnProperty("peTTMRate"))
                object.peTTMRate = options.json && !isFinite(message.peTTMRate) ? String(message.peTTMRate) : message.peTTMRate;
            return object;
        };

        /**
         * Converts this EquitySnapshotExData to JSON.
         * @function toJSON
         * @memberof Qot_GetSecuritySnapshot.EquitySnapshotExData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EquitySnapshotExData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EquitySnapshotExData;
    })();

    Qot_GetSecuritySnapshot.WarrantSnapshotExData = (function() {

        /**
         * Properties of a WarrantSnapshotExData.
         * @memberof Qot_GetSecuritySnapshot
         * @interface IWarrantSnapshotExData
         * @property {number} conversionRate WarrantSnapshotExData conversionRate
         * @property {number} warrantType WarrantSnapshotExData warrantType
         * @property {number} strikePrice WarrantSnapshotExData strikePrice
         * @property {string} maturityTime WarrantSnapshotExData maturityTime
         * @property {string} endTradeTime WarrantSnapshotExData endTradeTime
         * @property {Qot_Common.ISecurity} owner WarrantSnapshotExData owner
         * @property {number} recoveryPrice WarrantSnapshotExData recoveryPrice
         * @property {number|Long} streetVolumn WarrantSnapshotExData streetVolumn
         * @property {number|Long} issueVolumn WarrantSnapshotExData issueVolumn
         * @property {number} streetRate WarrantSnapshotExData streetRate
         * @property {number} delta WarrantSnapshotExData delta
         * @property {number} impliedVolatility WarrantSnapshotExData impliedVolatility
         * @property {number} premium WarrantSnapshotExData premium
         * @property {number|null} [maturityTimestamp] WarrantSnapshotExData maturityTimestamp
         * @property {number|null} [endTradeTimestamp] WarrantSnapshotExData endTradeTimestamp
         */

        /**
         * Constructs a new WarrantSnapshotExData.
         * @memberof Qot_GetSecuritySnapshot
         * @classdesc Represents a WarrantSnapshotExData.
         * @implements IWarrantSnapshotExData
         * @constructor
         * @param {Qot_GetSecuritySnapshot.IWarrantSnapshotExData=} [properties] Properties to set
         */
        function WarrantSnapshotExData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WarrantSnapshotExData conversionRate.
         * @member {number} conversionRate
         * @memberof Qot_GetSecuritySnapshot.WarrantSnapshotExData
         * @instance
         */
        WarrantSnapshotExData.prototype.conversionRate = 0;

        /**
         * WarrantSnapshotExData warrantType.
         * @member {number} warrantType
         * @memberof Qot_GetSecuritySnapshot.WarrantSnapshotExData
         * @instance
         */
        WarrantSnapshotExData.prototype.warrantType = 0;

        /**
         * WarrantSnapshotExData strikePrice.
         * @member {number} strikePrice
         * @memberof Qot_GetSecuritySnapshot.WarrantSnapshotExData
         * @instance
         */
        WarrantSnapshotExData.prototype.strikePrice = 0;

        /**
         * WarrantSnapshotExData maturityTime.
         * @member {string} maturityTime
         * @memberof Qot_GetSecuritySnapshot.WarrantSnapshotExData
         * @instance
         */
        WarrantSnapshotExData.prototype.maturityTime = "";

        /**
         * WarrantSnapshotExData endTradeTime.
         * @member {string} endTradeTime
         * @memberof Qot_GetSecuritySnapshot.WarrantSnapshotExData
         * @instance
         */
        WarrantSnapshotExData.prototype.endTradeTime = "";

        /**
         * WarrantSnapshotExData owner.
         * @member {Qot_Common.ISecurity} owner
         * @memberof Qot_GetSecuritySnapshot.WarrantSnapshotExData
         * @instance
         */
        WarrantSnapshotExData.prototype.owner = null;

        /**
         * WarrantSnapshotExData recoveryPrice.
         * @member {number} recoveryPrice
         * @memberof Qot_GetSecuritySnapshot.WarrantSnapshotExData
         * @instance
         */
        WarrantSnapshotExData.prototype.recoveryPrice = 0;

        /**
         * WarrantSnapshotExData streetVolumn.
         * @member {number|Long} streetVolumn
         * @memberof Qot_GetSecuritySnapshot.WarrantSnapshotExData
         * @instance
         */
        WarrantSnapshotExData.prototype.streetVolumn = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * WarrantSnapshotExData issueVolumn.
         * @member {number|Long} issueVolumn
         * @memberof Qot_GetSecuritySnapshot.WarrantSnapshotExData
         * @instance
         */
        WarrantSnapshotExData.prototype.issueVolumn = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * WarrantSnapshotExData streetRate.
         * @member {number} streetRate
         * @memberof Qot_GetSecuritySnapshot.WarrantSnapshotExData
         * @instance
         */
        WarrantSnapshotExData.prototype.streetRate = 0;

        /**
         * WarrantSnapshotExData delta.
         * @member {number} delta
         * @memberof Qot_GetSecuritySnapshot.WarrantSnapshotExData
         * @instance
         */
        WarrantSnapshotExData.prototype.delta = 0;

        /**
         * WarrantSnapshotExData impliedVolatility.
         * @member {number} impliedVolatility
         * @memberof Qot_GetSecuritySnapshot.WarrantSnapshotExData
         * @instance
         */
        WarrantSnapshotExData.prototype.impliedVolatility = 0;

        /**
         * WarrantSnapshotExData premium.
         * @member {number} premium
         * @memberof Qot_GetSecuritySnapshot.WarrantSnapshotExData
         * @instance
         */
        WarrantSnapshotExData.prototype.premium = 0;

        /**
         * WarrantSnapshotExData maturityTimestamp.
         * @member {number} maturityTimestamp
         * @memberof Qot_GetSecuritySnapshot.WarrantSnapshotExData
         * @instance
         */
        WarrantSnapshotExData.prototype.maturityTimestamp = 0;

        /**
         * WarrantSnapshotExData endTradeTimestamp.
         * @member {number} endTradeTimestamp
         * @memberof Qot_GetSecuritySnapshot.WarrantSnapshotExData
         * @instance
         */
        WarrantSnapshotExData.prototype.endTradeTimestamp = 0;

        /**
         * Creates a new WarrantSnapshotExData instance using the specified properties.
         * @function create
         * @memberof Qot_GetSecuritySnapshot.WarrantSnapshotExData
         * @static
         * @param {Qot_GetSecuritySnapshot.IWarrantSnapshotExData=} [properties] Properties to set
         * @returns {Qot_GetSecuritySnapshot.WarrantSnapshotExData} WarrantSnapshotExData instance
         */
        WarrantSnapshotExData.create = function create(properties) {
            return new WarrantSnapshotExData(properties);
        };

        /**
         * Encodes the specified WarrantSnapshotExData message. Does not implicitly {@link Qot_GetSecuritySnapshot.WarrantSnapshotExData.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetSecuritySnapshot.WarrantSnapshotExData
         * @static
         * @param {Qot_GetSecuritySnapshot.IWarrantSnapshotExData} message WarrantSnapshotExData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WarrantSnapshotExData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 1 =*/9).double(message.conversionRate);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.warrantType);
            writer.uint32(/* id 3, wireType 1 =*/25).double(message.strikePrice);
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.maturityTime);
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.endTradeTime);
            $root.Qot_Common.Security.encode(message.owner, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            writer.uint32(/* id 7, wireType 1 =*/57).double(message.recoveryPrice);
            writer.uint32(/* id 8, wireType 0 =*/64).int64(message.streetVolumn);
            writer.uint32(/* id 9, wireType 0 =*/72).int64(message.issueVolumn);
            writer.uint32(/* id 10, wireType 1 =*/81).double(message.streetRate);
            writer.uint32(/* id 11, wireType 1 =*/89).double(message.delta);
            writer.uint32(/* id 12, wireType 1 =*/97).double(message.impliedVolatility);
            writer.uint32(/* id 13, wireType 1 =*/105).double(message.premium);
            if (message.maturityTimestamp != null && message.hasOwnProperty("maturityTimestamp"))
                writer.uint32(/* id 14, wireType 1 =*/113).double(message.maturityTimestamp);
            if (message.endTradeTimestamp != null && message.hasOwnProperty("endTradeTimestamp"))
                writer.uint32(/* id 15, wireType 1 =*/121).double(message.endTradeTimestamp);
            return writer;
        };

        /**
         * Encodes the specified WarrantSnapshotExData message, length delimited. Does not implicitly {@link Qot_GetSecuritySnapshot.WarrantSnapshotExData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetSecuritySnapshot.WarrantSnapshotExData
         * @static
         * @param {Qot_GetSecuritySnapshot.IWarrantSnapshotExData} message WarrantSnapshotExData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WarrantSnapshotExData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WarrantSnapshotExData message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetSecuritySnapshot.WarrantSnapshotExData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetSecuritySnapshot.WarrantSnapshotExData} WarrantSnapshotExData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WarrantSnapshotExData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetSecuritySnapshot.WarrantSnapshotExData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.conversionRate = reader.double();
                    break;
                case 2:
                    message.warrantType = reader.int32();
                    break;
                case 3:
                    message.strikePrice = reader.double();
                    break;
                case 4:
                    message.maturityTime = reader.string();
                    break;
                case 5:
                    message.endTradeTime = reader.string();
                    break;
                case 6:
                    message.owner = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.recoveryPrice = reader.double();
                    break;
                case 8:
                    message.streetVolumn = reader.int64();
                    break;
                case 9:
                    message.issueVolumn = reader.int64();
                    break;
                case 10:
                    message.streetRate = reader.double();
                    break;
                case 11:
                    message.delta = reader.double();
                    break;
                case 12:
                    message.impliedVolatility = reader.double();
                    break;
                case 13:
                    message.premium = reader.double();
                    break;
                case 14:
                    message.maturityTimestamp = reader.double();
                    break;
                case 15:
                    message.endTradeTimestamp = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("conversionRate"))
                throw $util.ProtocolError("missing required 'conversionRate'", { instance: message });
            if (!message.hasOwnProperty("warrantType"))
                throw $util.ProtocolError("missing required 'warrantType'", { instance: message });
            if (!message.hasOwnProperty("strikePrice"))
                throw $util.ProtocolError("missing required 'strikePrice'", { instance: message });
            if (!message.hasOwnProperty("maturityTime"))
                throw $util.ProtocolError("missing required 'maturityTime'", { instance: message });
            if (!message.hasOwnProperty("endTradeTime"))
                throw $util.ProtocolError("missing required 'endTradeTime'", { instance: message });
            if (!message.hasOwnProperty("owner"))
                throw $util.ProtocolError("missing required 'owner'", { instance: message });
            if (!message.hasOwnProperty("recoveryPrice"))
                throw $util.ProtocolError("missing required 'recoveryPrice'", { instance: message });
            if (!message.hasOwnProperty("streetVolumn"))
                throw $util.ProtocolError("missing required 'streetVolumn'", { instance: message });
            if (!message.hasOwnProperty("issueVolumn"))
                throw $util.ProtocolError("missing required 'issueVolumn'", { instance: message });
            if (!message.hasOwnProperty("streetRate"))
                throw $util.ProtocolError("missing required 'streetRate'", { instance: message });
            if (!message.hasOwnProperty("delta"))
                throw $util.ProtocolError("missing required 'delta'", { instance: message });
            if (!message.hasOwnProperty("impliedVolatility"))
                throw $util.ProtocolError("missing required 'impliedVolatility'", { instance: message });
            if (!message.hasOwnProperty("premium"))
                throw $util.ProtocolError("missing required 'premium'", { instance: message });
            return message;
        };

        /**
         * Decodes a WarrantSnapshotExData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetSecuritySnapshot.WarrantSnapshotExData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetSecuritySnapshot.WarrantSnapshotExData} WarrantSnapshotExData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WarrantSnapshotExData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WarrantSnapshotExData message.
         * @function verify
         * @memberof Qot_GetSecuritySnapshot.WarrantSnapshotExData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WarrantSnapshotExData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (typeof message.conversionRate !== "number")
                return "conversionRate: number expected";
            if (!$util.isInteger(message.warrantType))
                return "warrantType: integer expected";
            if (typeof message.strikePrice !== "number")
                return "strikePrice: number expected";
            if (!$util.isString(message.maturityTime))
                return "maturityTime: string expected";
            if (!$util.isString(message.endTradeTime))
                return "endTradeTime: string expected";
            {
                var error = $root.Qot_Common.Security.verify(message.owner);
                if (error)
                    return "owner." + error;
            }
            if (typeof message.recoveryPrice !== "number")
                return "recoveryPrice: number expected";
            if (!$util.isInteger(message.streetVolumn) && !(message.streetVolumn && $util.isInteger(message.streetVolumn.low) && $util.isInteger(message.streetVolumn.high)))
                return "streetVolumn: integer|Long expected";
            if (!$util.isInteger(message.issueVolumn) && !(message.issueVolumn && $util.isInteger(message.issueVolumn.low) && $util.isInteger(message.issueVolumn.high)))
                return "issueVolumn: integer|Long expected";
            if (typeof message.streetRate !== "number")
                return "streetRate: number expected";
            if (typeof message.delta !== "number")
                return "delta: number expected";
            if (typeof message.impliedVolatility !== "number")
                return "impliedVolatility: number expected";
            if (typeof message.premium !== "number")
                return "premium: number expected";
            if (message.maturityTimestamp != null && message.hasOwnProperty("maturityTimestamp"))
                if (typeof message.maturityTimestamp !== "number")
                    return "maturityTimestamp: number expected";
            if (message.endTradeTimestamp != null && message.hasOwnProperty("endTradeTimestamp"))
                if (typeof message.endTradeTimestamp !== "number")
                    return "endTradeTimestamp: number expected";
            return null;
        };

        /**
         * Creates a WarrantSnapshotExData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetSecuritySnapshot.WarrantSnapshotExData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetSecuritySnapshot.WarrantSnapshotExData} WarrantSnapshotExData
         */
        WarrantSnapshotExData.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetSecuritySnapshot.WarrantSnapshotExData)
                return object;
            var message = new $root.Qot_GetSecuritySnapshot.WarrantSnapshotExData();
            if (object.conversionRate != null)
                message.conversionRate = Number(object.conversionRate);
            if (object.warrantType != null)
                message.warrantType = object.warrantType | 0;
            if (object.strikePrice != null)
                message.strikePrice = Number(object.strikePrice);
            if (object.maturityTime != null)
                message.maturityTime = String(object.maturityTime);
            if (object.endTradeTime != null)
                message.endTradeTime = String(object.endTradeTime);
            if (object.owner != null) {
                if (typeof object.owner !== "object")
                    throw TypeError(".Qot_GetSecuritySnapshot.WarrantSnapshotExData.owner: object expected");
                message.owner = $root.Qot_Common.Security.fromObject(object.owner);
            }
            if (object.recoveryPrice != null)
                message.recoveryPrice = Number(object.recoveryPrice);
            if (object.streetVolumn != null)
                if ($util.Long)
                    (message.streetVolumn = $util.Long.fromValue(object.streetVolumn)).unsigned = false;
                else if (typeof object.streetVolumn === "string")
                    message.streetVolumn = parseInt(object.streetVolumn, 10);
                else if (typeof object.streetVolumn === "number")
                    message.streetVolumn = object.streetVolumn;
                else if (typeof object.streetVolumn === "object")
                    message.streetVolumn = new $util.LongBits(object.streetVolumn.low >>> 0, object.streetVolumn.high >>> 0).toNumber();
            if (object.issueVolumn != null)
                if ($util.Long)
                    (message.issueVolumn = $util.Long.fromValue(object.issueVolumn)).unsigned = false;
                else if (typeof object.issueVolumn === "string")
                    message.issueVolumn = parseInt(object.issueVolumn, 10);
                else if (typeof object.issueVolumn === "number")
                    message.issueVolumn = object.issueVolumn;
                else if (typeof object.issueVolumn === "object")
                    message.issueVolumn = new $util.LongBits(object.issueVolumn.low >>> 0, object.issueVolumn.high >>> 0).toNumber();
            if (object.streetRate != null)
                message.streetRate = Number(object.streetRate);
            if (object.delta != null)
                message.delta = Number(object.delta);
            if (object.impliedVolatility != null)
                message.impliedVolatility = Number(object.impliedVolatility);
            if (object.premium != null)
                message.premium = Number(object.premium);
            if (object.maturityTimestamp != null)
                message.maturityTimestamp = Number(object.maturityTimestamp);
            if (object.endTradeTimestamp != null)
                message.endTradeTimestamp = Number(object.endTradeTimestamp);
            return message;
        };

        /**
         * Creates a plain object from a WarrantSnapshotExData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetSecuritySnapshot.WarrantSnapshotExData
         * @static
         * @param {Qot_GetSecuritySnapshot.WarrantSnapshotExData} message WarrantSnapshotExData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WarrantSnapshotExData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.conversionRate = 0;
                object.warrantType = 0;
                object.strikePrice = 0;
                object.maturityTime = "";
                object.endTradeTime = "";
                object.owner = null;
                object.recoveryPrice = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.streetVolumn = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.streetVolumn = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.issueVolumn = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.issueVolumn = options.longs === String ? "0" : 0;
                object.streetRate = 0;
                object.delta = 0;
                object.impliedVolatility = 0;
                object.premium = 0;
                object.maturityTimestamp = 0;
                object.endTradeTimestamp = 0;
            }
            if (message.conversionRate != null && message.hasOwnProperty("conversionRate"))
                object.conversionRate = options.json && !isFinite(message.conversionRate) ? String(message.conversionRate) : message.conversionRate;
            if (message.warrantType != null && message.hasOwnProperty("warrantType"))
                object.warrantType = message.warrantType;
            if (message.strikePrice != null && message.hasOwnProperty("strikePrice"))
                object.strikePrice = options.json && !isFinite(message.strikePrice) ? String(message.strikePrice) : message.strikePrice;
            if (message.maturityTime != null && message.hasOwnProperty("maturityTime"))
                object.maturityTime = message.maturityTime;
            if (message.endTradeTime != null && message.hasOwnProperty("endTradeTime"))
                object.endTradeTime = message.endTradeTime;
            if (message.owner != null && message.hasOwnProperty("owner"))
                object.owner = $root.Qot_Common.Security.toObject(message.owner, options);
            if (message.recoveryPrice != null && message.hasOwnProperty("recoveryPrice"))
                object.recoveryPrice = options.json && !isFinite(message.recoveryPrice) ? String(message.recoveryPrice) : message.recoveryPrice;
            if (message.streetVolumn != null && message.hasOwnProperty("streetVolumn"))
                if (typeof message.streetVolumn === "number")
                    object.streetVolumn = options.longs === String ? String(message.streetVolumn) : message.streetVolumn;
                else
                    object.streetVolumn = options.longs === String ? $util.Long.prototype.toString.call(message.streetVolumn) : options.longs === Number ? new $util.LongBits(message.streetVolumn.low >>> 0, message.streetVolumn.high >>> 0).toNumber() : message.streetVolumn;
            if (message.issueVolumn != null && message.hasOwnProperty("issueVolumn"))
                if (typeof message.issueVolumn === "number")
                    object.issueVolumn = options.longs === String ? String(message.issueVolumn) : message.issueVolumn;
                else
                    object.issueVolumn = options.longs === String ? $util.Long.prototype.toString.call(message.issueVolumn) : options.longs === Number ? new $util.LongBits(message.issueVolumn.low >>> 0, message.issueVolumn.high >>> 0).toNumber() : message.issueVolumn;
            if (message.streetRate != null && message.hasOwnProperty("streetRate"))
                object.streetRate = options.json && !isFinite(message.streetRate) ? String(message.streetRate) : message.streetRate;
            if (message.delta != null && message.hasOwnProperty("delta"))
                object.delta = options.json && !isFinite(message.delta) ? String(message.delta) : message.delta;
            if (message.impliedVolatility != null && message.hasOwnProperty("impliedVolatility"))
                object.impliedVolatility = options.json && !isFinite(message.impliedVolatility) ? String(message.impliedVolatility) : message.impliedVolatility;
            if (message.premium != null && message.hasOwnProperty("premium"))
                object.premium = options.json && !isFinite(message.premium) ? String(message.premium) : message.premium;
            if (message.maturityTimestamp != null && message.hasOwnProperty("maturityTimestamp"))
                object.maturityTimestamp = options.json && !isFinite(message.maturityTimestamp) ? String(message.maturityTimestamp) : message.maturityTimestamp;
            if (message.endTradeTimestamp != null && message.hasOwnProperty("endTradeTimestamp"))
                object.endTradeTimestamp = options.json && !isFinite(message.endTradeTimestamp) ? String(message.endTradeTimestamp) : message.endTradeTimestamp;
            return object;
        };

        /**
         * Converts this WarrantSnapshotExData to JSON.
         * @function toJSON
         * @memberof Qot_GetSecuritySnapshot.WarrantSnapshotExData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WarrantSnapshotExData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return WarrantSnapshotExData;
    })();

    Qot_GetSecuritySnapshot.OptionSnapshotExData = (function() {

        /**
         * Properties of an OptionSnapshotExData.
         * @memberof Qot_GetSecuritySnapshot
         * @interface IOptionSnapshotExData
         * @property {number} type OptionSnapshotExData type
         * @property {Qot_Common.ISecurity} owner OptionSnapshotExData owner
         * @property {string} strikeTime OptionSnapshotExData strikeTime
         * @property {number} strikePrice OptionSnapshotExData strikePrice
         * @property {number} contractSize OptionSnapshotExData contractSize
         * @property {number} openInterest OptionSnapshotExData openInterest
         * @property {number} impliedVolatility OptionSnapshotExData impliedVolatility
         * @property {number} premium OptionSnapshotExData premium
         * @property {number} delta OptionSnapshotExData delta
         * @property {number} gamma OptionSnapshotExData gamma
         * @property {number} vega OptionSnapshotExData vega
         * @property {number} theta OptionSnapshotExData theta
         * @property {number} rho OptionSnapshotExData rho
         * @property {number|null} [strikeTimestamp] OptionSnapshotExData strikeTimestamp
         */

        /**
         * Constructs a new OptionSnapshotExData.
         * @memberof Qot_GetSecuritySnapshot
         * @classdesc Represents an OptionSnapshotExData.
         * @implements IOptionSnapshotExData
         * @constructor
         * @param {Qot_GetSecuritySnapshot.IOptionSnapshotExData=} [properties] Properties to set
         */
        function OptionSnapshotExData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OptionSnapshotExData type.
         * @member {number} type
         * @memberof Qot_GetSecuritySnapshot.OptionSnapshotExData
         * @instance
         */
        OptionSnapshotExData.prototype.type = 0;

        /**
         * OptionSnapshotExData owner.
         * @member {Qot_Common.ISecurity} owner
         * @memberof Qot_GetSecuritySnapshot.OptionSnapshotExData
         * @instance
         */
        OptionSnapshotExData.prototype.owner = null;

        /**
         * OptionSnapshotExData strikeTime.
         * @member {string} strikeTime
         * @memberof Qot_GetSecuritySnapshot.OptionSnapshotExData
         * @instance
         */
        OptionSnapshotExData.prototype.strikeTime = "";

        /**
         * OptionSnapshotExData strikePrice.
         * @member {number} strikePrice
         * @memberof Qot_GetSecuritySnapshot.OptionSnapshotExData
         * @instance
         */
        OptionSnapshotExData.prototype.strikePrice = 0;

        /**
         * OptionSnapshotExData contractSize.
         * @member {number} contractSize
         * @memberof Qot_GetSecuritySnapshot.OptionSnapshotExData
         * @instance
         */
        OptionSnapshotExData.prototype.contractSize = 0;

        /**
         * OptionSnapshotExData openInterest.
         * @member {number} openInterest
         * @memberof Qot_GetSecuritySnapshot.OptionSnapshotExData
         * @instance
         */
        OptionSnapshotExData.prototype.openInterest = 0;

        /**
         * OptionSnapshotExData impliedVolatility.
         * @member {number} impliedVolatility
         * @memberof Qot_GetSecuritySnapshot.OptionSnapshotExData
         * @instance
         */
        OptionSnapshotExData.prototype.impliedVolatility = 0;

        /**
         * OptionSnapshotExData premium.
         * @member {number} premium
         * @memberof Qot_GetSecuritySnapshot.OptionSnapshotExData
         * @instance
         */
        OptionSnapshotExData.prototype.premium = 0;

        /**
         * OptionSnapshotExData delta.
         * @member {number} delta
         * @memberof Qot_GetSecuritySnapshot.OptionSnapshotExData
         * @instance
         */
        OptionSnapshotExData.prototype.delta = 0;

        /**
         * OptionSnapshotExData gamma.
         * @member {number} gamma
         * @memberof Qot_GetSecuritySnapshot.OptionSnapshotExData
         * @instance
         */
        OptionSnapshotExData.prototype.gamma = 0;

        /**
         * OptionSnapshotExData vega.
         * @member {number} vega
         * @memberof Qot_GetSecuritySnapshot.OptionSnapshotExData
         * @instance
         */
        OptionSnapshotExData.prototype.vega = 0;

        /**
         * OptionSnapshotExData theta.
         * @member {number} theta
         * @memberof Qot_GetSecuritySnapshot.OptionSnapshotExData
         * @instance
         */
        OptionSnapshotExData.prototype.theta = 0;

        /**
         * OptionSnapshotExData rho.
         * @member {number} rho
         * @memberof Qot_GetSecuritySnapshot.OptionSnapshotExData
         * @instance
         */
        OptionSnapshotExData.prototype.rho = 0;

        /**
         * OptionSnapshotExData strikeTimestamp.
         * @member {number} strikeTimestamp
         * @memberof Qot_GetSecuritySnapshot.OptionSnapshotExData
         * @instance
         */
        OptionSnapshotExData.prototype.strikeTimestamp = 0;

        /**
         * Creates a new OptionSnapshotExData instance using the specified properties.
         * @function create
         * @memberof Qot_GetSecuritySnapshot.OptionSnapshotExData
         * @static
         * @param {Qot_GetSecuritySnapshot.IOptionSnapshotExData=} [properties] Properties to set
         * @returns {Qot_GetSecuritySnapshot.OptionSnapshotExData} OptionSnapshotExData instance
         */
        OptionSnapshotExData.create = function create(properties) {
            return new OptionSnapshotExData(properties);
        };

        /**
         * Encodes the specified OptionSnapshotExData message. Does not implicitly {@link Qot_GetSecuritySnapshot.OptionSnapshotExData.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetSecuritySnapshot.OptionSnapshotExData
         * @static
         * @param {Qot_GetSecuritySnapshot.IOptionSnapshotExData} message OptionSnapshotExData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OptionSnapshotExData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            $root.Qot_Common.Security.encode(message.owner, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.strikeTime);
            writer.uint32(/* id 4, wireType 1 =*/33).double(message.strikePrice);
            writer.uint32(/* id 5, wireType 0 =*/40).int32(message.contractSize);
            writer.uint32(/* id 6, wireType 0 =*/48).int32(message.openInterest);
            writer.uint32(/* id 7, wireType 1 =*/57).double(message.impliedVolatility);
            writer.uint32(/* id 8, wireType 1 =*/65).double(message.premium);
            writer.uint32(/* id 9, wireType 1 =*/73).double(message.delta);
            writer.uint32(/* id 10, wireType 1 =*/81).double(message.gamma);
            writer.uint32(/* id 11, wireType 1 =*/89).double(message.vega);
            writer.uint32(/* id 12, wireType 1 =*/97).double(message.theta);
            writer.uint32(/* id 13, wireType 1 =*/105).double(message.rho);
            if (message.strikeTimestamp != null && message.hasOwnProperty("strikeTimestamp"))
                writer.uint32(/* id 14, wireType 1 =*/113).double(message.strikeTimestamp);
            return writer;
        };

        /**
         * Encodes the specified OptionSnapshotExData message, length delimited. Does not implicitly {@link Qot_GetSecuritySnapshot.OptionSnapshotExData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetSecuritySnapshot.OptionSnapshotExData
         * @static
         * @param {Qot_GetSecuritySnapshot.IOptionSnapshotExData} message OptionSnapshotExData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OptionSnapshotExData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OptionSnapshotExData message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetSecuritySnapshot.OptionSnapshotExData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetSecuritySnapshot.OptionSnapshotExData} OptionSnapshotExData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OptionSnapshotExData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetSecuritySnapshot.OptionSnapshotExData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.owner = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.strikeTime = reader.string();
                    break;
                case 4:
                    message.strikePrice = reader.double();
                    break;
                case 5:
                    message.contractSize = reader.int32();
                    break;
                case 6:
                    message.openInterest = reader.int32();
                    break;
                case 7:
                    message.impliedVolatility = reader.double();
                    break;
                case 8:
                    message.premium = reader.double();
                    break;
                case 9:
                    message.delta = reader.double();
                    break;
                case 10:
                    message.gamma = reader.double();
                    break;
                case 11:
                    message.vega = reader.double();
                    break;
                case 12:
                    message.theta = reader.double();
                    break;
                case 13:
                    message.rho = reader.double();
                    break;
                case 14:
                    message.strikeTimestamp = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("type"))
                throw $util.ProtocolError("missing required 'type'", { instance: message });
            if (!message.hasOwnProperty("owner"))
                throw $util.ProtocolError("missing required 'owner'", { instance: message });
            if (!message.hasOwnProperty("strikeTime"))
                throw $util.ProtocolError("missing required 'strikeTime'", { instance: message });
            if (!message.hasOwnProperty("strikePrice"))
                throw $util.ProtocolError("missing required 'strikePrice'", { instance: message });
            if (!message.hasOwnProperty("contractSize"))
                throw $util.ProtocolError("missing required 'contractSize'", { instance: message });
            if (!message.hasOwnProperty("openInterest"))
                throw $util.ProtocolError("missing required 'openInterest'", { instance: message });
            if (!message.hasOwnProperty("impliedVolatility"))
                throw $util.ProtocolError("missing required 'impliedVolatility'", { instance: message });
            if (!message.hasOwnProperty("premium"))
                throw $util.ProtocolError("missing required 'premium'", { instance: message });
            if (!message.hasOwnProperty("delta"))
                throw $util.ProtocolError("missing required 'delta'", { instance: message });
            if (!message.hasOwnProperty("gamma"))
                throw $util.ProtocolError("missing required 'gamma'", { instance: message });
            if (!message.hasOwnProperty("vega"))
                throw $util.ProtocolError("missing required 'vega'", { instance: message });
            if (!message.hasOwnProperty("theta"))
                throw $util.ProtocolError("missing required 'theta'", { instance: message });
            if (!message.hasOwnProperty("rho"))
                throw $util.ProtocolError("missing required 'rho'", { instance: message });
            return message;
        };

        /**
         * Decodes an OptionSnapshotExData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetSecuritySnapshot.OptionSnapshotExData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetSecuritySnapshot.OptionSnapshotExData} OptionSnapshotExData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OptionSnapshotExData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OptionSnapshotExData message.
         * @function verify
         * @memberof Qot_GetSecuritySnapshot.OptionSnapshotExData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OptionSnapshotExData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.type))
                return "type: integer expected";
            {
                var error = $root.Qot_Common.Security.verify(message.owner);
                if (error)
                    return "owner." + error;
            }
            if (!$util.isString(message.strikeTime))
                return "strikeTime: string expected";
            if (typeof message.strikePrice !== "number")
                return "strikePrice: number expected";
            if (!$util.isInteger(message.contractSize))
                return "contractSize: integer expected";
            if (!$util.isInteger(message.openInterest))
                return "openInterest: integer expected";
            if (typeof message.impliedVolatility !== "number")
                return "impliedVolatility: number expected";
            if (typeof message.premium !== "number")
                return "premium: number expected";
            if (typeof message.delta !== "number")
                return "delta: number expected";
            if (typeof message.gamma !== "number")
                return "gamma: number expected";
            if (typeof message.vega !== "number")
                return "vega: number expected";
            if (typeof message.theta !== "number")
                return "theta: number expected";
            if (typeof message.rho !== "number")
                return "rho: number expected";
            if (message.strikeTimestamp != null && message.hasOwnProperty("strikeTimestamp"))
                if (typeof message.strikeTimestamp !== "number")
                    return "strikeTimestamp: number expected";
            return null;
        };

        /**
         * Creates an OptionSnapshotExData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetSecuritySnapshot.OptionSnapshotExData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetSecuritySnapshot.OptionSnapshotExData} OptionSnapshotExData
         */
        OptionSnapshotExData.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetSecuritySnapshot.OptionSnapshotExData)
                return object;
            var message = new $root.Qot_GetSecuritySnapshot.OptionSnapshotExData();
            if (object.type != null)
                message.type = object.type | 0;
            if (object.owner != null) {
                if (typeof object.owner !== "object")
                    throw TypeError(".Qot_GetSecuritySnapshot.OptionSnapshotExData.owner: object expected");
                message.owner = $root.Qot_Common.Security.fromObject(object.owner);
            }
            if (object.strikeTime != null)
                message.strikeTime = String(object.strikeTime);
            if (object.strikePrice != null)
                message.strikePrice = Number(object.strikePrice);
            if (object.contractSize != null)
                message.contractSize = object.contractSize | 0;
            if (object.openInterest != null)
                message.openInterest = object.openInterest | 0;
            if (object.impliedVolatility != null)
                message.impliedVolatility = Number(object.impliedVolatility);
            if (object.premium != null)
                message.premium = Number(object.premium);
            if (object.delta != null)
                message.delta = Number(object.delta);
            if (object.gamma != null)
                message.gamma = Number(object.gamma);
            if (object.vega != null)
                message.vega = Number(object.vega);
            if (object.theta != null)
                message.theta = Number(object.theta);
            if (object.rho != null)
                message.rho = Number(object.rho);
            if (object.strikeTimestamp != null)
                message.strikeTimestamp = Number(object.strikeTimestamp);
            return message;
        };

        /**
         * Creates a plain object from an OptionSnapshotExData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetSecuritySnapshot.OptionSnapshotExData
         * @static
         * @param {Qot_GetSecuritySnapshot.OptionSnapshotExData} message OptionSnapshotExData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OptionSnapshotExData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = 0;
                object.owner = null;
                object.strikeTime = "";
                object.strikePrice = 0;
                object.contractSize = 0;
                object.openInterest = 0;
                object.impliedVolatility = 0;
                object.premium = 0;
                object.delta = 0;
                object.gamma = 0;
                object.vega = 0;
                object.theta = 0;
                object.rho = 0;
                object.strikeTimestamp = 0;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.owner != null && message.hasOwnProperty("owner"))
                object.owner = $root.Qot_Common.Security.toObject(message.owner, options);
            if (message.strikeTime != null && message.hasOwnProperty("strikeTime"))
                object.strikeTime = message.strikeTime;
            if (message.strikePrice != null && message.hasOwnProperty("strikePrice"))
                object.strikePrice = options.json && !isFinite(message.strikePrice) ? String(message.strikePrice) : message.strikePrice;
            if (message.contractSize != null && message.hasOwnProperty("contractSize"))
                object.contractSize = message.contractSize;
            if (message.openInterest != null && message.hasOwnProperty("openInterest"))
                object.openInterest = message.openInterest;
            if (message.impliedVolatility != null && message.hasOwnProperty("impliedVolatility"))
                object.impliedVolatility = options.json && !isFinite(message.impliedVolatility) ? String(message.impliedVolatility) : message.impliedVolatility;
            if (message.premium != null && message.hasOwnProperty("premium"))
                object.premium = options.json && !isFinite(message.premium) ? String(message.premium) : message.premium;
            if (message.delta != null && message.hasOwnProperty("delta"))
                object.delta = options.json && !isFinite(message.delta) ? String(message.delta) : message.delta;
            if (message.gamma != null && message.hasOwnProperty("gamma"))
                object.gamma = options.json && !isFinite(message.gamma) ? String(message.gamma) : message.gamma;
            if (message.vega != null && message.hasOwnProperty("vega"))
                object.vega = options.json && !isFinite(message.vega) ? String(message.vega) : message.vega;
            if (message.theta != null && message.hasOwnProperty("theta"))
                object.theta = options.json && !isFinite(message.theta) ? String(message.theta) : message.theta;
            if (message.rho != null && message.hasOwnProperty("rho"))
                object.rho = options.json && !isFinite(message.rho) ? String(message.rho) : message.rho;
            if (message.strikeTimestamp != null && message.hasOwnProperty("strikeTimestamp"))
                object.strikeTimestamp = options.json && !isFinite(message.strikeTimestamp) ? String(message.strikeTimestamp) : message.strikeTimestamp;
            return object;
        };

        /**
         * Converts this OptionSnapshotExData to JSON.
         * @function toJSON
         * @memberof Qot_GetSecuritySnapshot.OptionSnapshotExData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OptionSnapshotExData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return OptionSnapshotExData;
    })();

    Qot_GetSecuritySnapshot.SnapshotBasicData = (function() {

        /**
         * Properties of a SnapshotBasicData.
         * @memberof Qot_GetSecuritySnapshot
         * @interface ISnapshotBasicData
         * @property {Qot_Common.ISecurity} security SnapshotBasicData security
         * @property {number} type SnapshotBasicData type
         * @property {boolean} isSuspend SnapshotBasicData isSuspend
         * @property {string} listTime SnapshotBasicData listTime
         * @property {number} lotSize SnapshotBasicData lotSize
         * @property {number} priceSpread SnapshotBasicData priceSpread
         * @property {string} updateTime SnapshotBasicData updateTime
         * @property {number} highPrice SnapshotBasicData highPrice
         * @property {number} openPrice SnapshotBasicData openPrice
         * @property {number} lowPrice SnapshotBasicData lowPrice
         * @property {number} lastClosePrice SnapshotBasicData lastClosePrice
         * @property {number} curPrice SnapshotBasicData curPrice
         * @property {number|Long} volume SnapshotBasicData volume
         * @property {number} turnover SnapshotBasicData turnover
         * @property {number} turnoverRate SnapshotBasicData turnoverRate
         * @property {number|null} [listTimestamp] SnapshotBasicData listTimestamp
         * @property {number|null} [updateTimestamp] SnapshotBasicData updateTimestamp
         * @property {number|null} [askPrice] SnapshotBasicData askPrice
         * @property {number|null} [bidPrice] SnapshotBasicData bidPrice
         * @property {number|Long|null} [askVol] SnapshotBasicData askVol
         * @property {number|Long|null} [bidVol] SnapshotBasicData bidVol
         * @property {boolean|null} [enableMargin] SnapshotBasicData enableMargin
         * @property {number|null} [mortgageRatio] SnapshotBasicData mortgageRatio
         * @property {number|null} [longMarginInitialRatio] SnapshotBasicData longMarginInitialRatio
         * @property {boolean|null} [enableShortSell] SnapshotBasicData enableShortSell
         * @property {number|null} [shortSellRate] SnapshotBasicData shortSellRate
         * @property {number|Long|null} [shortAvailableVolume] SnapshotBasicData shortAvailableVolume
         * @property {number|null} [shortMarginInitialRatio] SnapshotBasicData shortMarginInitialRatio
         */

        /**
         * Constructs a new SnapshotBasicData.
         * @memberof Qot_GetSecuritySnapshot
         * @classdesc Represents a SnapshotBasicData.
         * @implements ISnapshotBasicData
         * @constructor
         * @param {Qot_GetSecuritySnapshot.ISnapshotBasicData=} [properties] Properties to set
         */
        function SnapshotBasicData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SnapshotBasicData security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.security = null;

        /**
         * SnapshotBasicData type.
         * @member {number} type
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.type = 0;

        /**
         * SnapshotBasicData isSuspend.
         * @member {boolean} isSuspend
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.isSuspend = false;

        /**
         * SnapshotBasicData listTime.
         * @member {string} listTime
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.listTime = "";

        /**
         * SnapshotBasicData lotSize.
         * @member {number} lotSize
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.lotSize = 0;

        /**
         * SnapshotBasicData priceSpread.
         * @member {number} priceSpread
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.priceSpread = 0;

        /**
         * SnapshotBasicData updateTime.
         * @member {string} updateTime
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.updateTime = "";

        /**
         * SnapshotBasicData highPrice.
         * @member {number} highPrice
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.highPrice = 0;

        /**
         * SnapshotBasicData openPrice.
         * @member {number} openPrice
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.openPrice = 0;

        /**
         * SnapshotBasicData lowPrice.
         * @member {number} lowPrice
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.lowPrice = 0;

        /**
         * SnapshotBasicData lastClosePrice.
         * @member {number} lastClosePrice
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.lastClosePrice = 0;

        /**
         * SnapshotBasicData curPrice.
         * @member {number} curPrice
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.curPrice = 0;

        /**
         * SnapshotBasicData volume.
         * @member {number|Long} volume
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.volume = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SnapshotBasicData turnover.
         * @member {number} turnover
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.turnover = 0;

        /**
         * SnapshotBasicData turnoverRate.
         * @member {number} turnoverRate
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.turnoverRate = 0;

        /**
         * SnapshotBasicData listTimestamp.
         * @member {number} listTimestamp
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.listTimestamp = 0;

        /**
         * SnapshotBasicData updateTimestamp.
         * @member {number} updateTimestamp
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.updateTimestamp = 0;

        /**
         * SnapshotBasicData askPrice.
         * @member {number} askPrice
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.askPrice = 0;

        /**
         * SnapshotBasicData bidPrice.
         * @member {number} bidPrice
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.bidPrice = 0;

        /**
         * SnapshotBasicData askVol.
         * @member {number|Long} askVol
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.askVol = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SnapshotBasicData bidVol.
         * @member {number|Long} bidVol
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.bidVol = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SnapshotBasicData enableMargin.
         * @member {boolean} enableMargin
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.enableMargin = false;

        /**
         * SnapshotBasicData mortgageRatio.
         * @member {number} mortgageRatio
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.mortgageRatio = 0;

        /**
         * SnapshotBasicData longMarginInitialRatio.
         * @member {number} longMarginInitialRatio
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.longMarginInitialRatio = 0;

        /**
         * SnapshotBasicData enableShortSell.
         * @member {boolean} enableShortSell
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.enableShortSell = false;

        /**
         * SnapshotBasicData shortSellRate.
         * @member {number} shortSellRate
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.shortSellRate = 0;

        /**
         * SnapshotBasicData shortAvailableVolume.
         * @member {number|Long} shortAvailableVolume
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.shortAvailableVolume = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SnapshotBasicData shortMarginInitialRatio.
         * @member {number} shortMarginInitialRatio
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         */
        SnapshotBasicData.prototype.shortMarginInitialRatio = 0;

        /**
         * Creates a new SnapshotBasicData instance using the specified properties.
         * @function create
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @static
         * @param {Qot_GetSecuritySnapshot.ISnapshotBasicData=} [properties] Properties to set
         * @returns {Qot_GetSecuritySnapshot.SnapshotBasicData} SnapshotBasicData instance
         */
        SnapshotBasicData.create = function create(properties) {
            return new SnapshotBasicData(properties);
        };

        /**
         * Encodes the specified SnapshotBasicData message. Does not implicitly {@link Qot_GetSecuritySnapshot.SnapshotBasicData.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @static
         * @param {Qot_GetSecuritySnapshot.ISnapshotBasicData} message SnapshotBasicData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SnapshotBasicData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
            writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isSuspend);
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.listTime);
            writer.uint32(/* id 5, wireType 0 =*/40).int32(message.lotSize);
            writer.uint32(/* id 6, wireType 1 =*/49).double(message.priceSpread);
            writer.uint32(/* id 7, wireType 2 =*/58).string(message.updateTime);
            writer.uint32(/* id 8, wireType 1 =*/65).double(message.highPrice);
            writer.uint32(/* id 9, wireType 1 =*/73).double(message.openPrice);
            writer.uint32(/* id 10, wireType 1 =*/81).double(message.lowPrice);
            writer.uint32(/* id 11, wireType 1 =*/89).double(message.lastClosePrice);
            writer.uint32(/* id 12, wireType 1 =*/97).double(message.curPrice);
            writer.uint32(/* id 13, wireType 0 =*/104).int64(message.volume);
            writer.uint32(/* id 14, wireType 1 =*/113).double(message.turnover);
            writer.uint32(/* id 15, wireType 1 =*/121).double(message.turnoverRate);
            if (message.listTimestamp != null && message.hasOwnProperty("listTimestamp"))
                writer.uint32(/* id 16, wireType 1 =*/129).double(message.listTimestamp);
            if (message.updateTimestamp != null && message.hasOwnProperty("updateTimestamp"))
                writer.uint32(/* id 17, wireType 1 =*/137).double(message.updateTimestamp);
            if (message.askPrice != null && message.hasOwnProperty("askPrice"))
                writer.uint32(/* id 18, wireType 1 =*/145).double(message.askPrice);
            if (message.bidPrice != null && message.hasOwnProperty("bidPrice"))
                writer.uint32(/* id 19, wireType 1 =*/153).double(message.bidPrice);
            if (message.askVol != null && message.hasOwnProperty("askVol"))
                writer.uint32(/* id 20, wireType 0 =*/160).int64(message.askVol);
            if (message.bidVol != null && message.hasOwnProperty("bidVol"))
                writer.uint32(/* id 21, wireType 0 =*/168).int64(message.bidVol);
            if (message.enableMargin != null && message.hasOwnProperty("enableMargin"))
                writer.uint32(/* id 22, wireType 0 =*/176).bool(message.enableMargin);
            if (message.mortgageRatio != null && message.hasOwnProperty("mortgageRatio"))
                writer.uint32(/* id 23, wireType 1 =*/185).double(message.mortgageRatio);
            if (message.longMarginInitialRatio != null && message.hasOwnProperty("longMarginInitialRatio"))
                writer.uint32(/* id 24, wireType 1 =*/193).double(message.longMarginInitialRatio);
            if (message.enableShortSell != null && message.hasOwnProperty("enableShortSell"))
                writer.uint32(/* id 25, wireType 0 =*/200).bool(message.enableShortSell);
            if (message.shortSellRate != null && message.hasOwnProperty("shortSellRate"))
                writer.uint32(/* id 26, wireType 1 =*/209).double(message.shortSellRate);
            if (message.shortAvailableVolume != null && message.hasOwnProperty("shortAvailableVolume"))
                writer.uint32(/* id 27, wireType 0 =*/216).int64(message.shortAvailableVolume);
            if (message.shortMarginInitialRatio != null && message.hasOwnProperty("shortMarginInitialRatio"))
                writer.uint32(/* id 28, wireType 1 =*/225).double(message.shortMarginInitialRatio);
            return writer;
        };

        /**
         * Encodes the specified SnapshotBasicData message, length delimited. Does not implicitly {@link Qot_GetSecuritySnapshot.SnapshotBasicData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @static
         * @param {Qot_GetSecuritySnapshot.ISnapshotBasicData} message SnapshotBasicData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SnapshotBasicData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SnapshotBasicData message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetSecuritySnapshot.SnapshotBasicData} SnapshotBasicData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SnapshotBasicData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetSecuritySnapshot.SnapshotBasicData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.type = reader.int32();
                    break;
                case 3:
                    message.isSuspend = reader.bool();
                    break;
                case 4:
                    message.listTime = reader.string();
                    break;
                case 5:
                    message.lotSize = reader.int32();
                    break;
                case 6:
                    message.priceSpread = reader.double();
                    break;
                case 7:
                    message.updateTime = reader.string();
                    break;
                case 8:
                    message.highPrice = reader.double();
                    break;
                case 9:
                    message.openPrice = reader.double();
                    break;
                case 10:
                    message.lowPrice = reader.double();
                    break;
                case 11:
                    message.lastClosePrice = reader.double();
                    break;
                case 12:
                    message.curPrice = reader.double();
                    break;
                case 13:
                    message.volume = reader.int64();
                    break;
                case 14:
                    message.turnover = reader.double();
                    break;
                case 15:
                    message.turnoverRate = reader.double();
                    break;
                case 16:
                    message.listTimestamp = reader.double();
                    break;
                case 17:
                    message.updateTimestamp = reader.double();
                    break;
                case 18:
                    message.askPrice = reader.double();
                    break;
                case 19:
                    message.bidPrice = reader.double();
                    break;
                case 20:
                    message.askVol = reader.int64();
                    break;
                case 21:
                    message.bidVol = reader.int64();
                    break;
                case 22:
                    message.enableMargin = reader.bool();
                    break;
                case 23:
                    message.mortgageRatio = reader.double();
                    break;
                case 24:
                    message.longMarginInitialRatio = reader.double();
                    break;
                case 25:
                    message.enableShortSell = reader.bool();
                    break;
                case 26:
                    message.shortSellRate = reader.double();
                    break;
                case 27:
                    message.shortAvailableVolume = reader.int64();
                    break;
                case 28:
                    message.shortMarginInitialRatio = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            if (!message.hasOwnProperty("type"))
                throw $util.ProtocolError("missing required 'type'", { instance: message });
            if (!message.hasOwnProperty("isSuspend"))
                throw $util.ProtocolError("missing required 'isSuspend'", { instance: message });
            if (!message.hasOwnProperty("listTime"))
                throw $util.ProtocolError("missing required 'listTime'", { instance: message });
            if (!message.hasOwnProperty("lotSize"))
                throw $util.ProtocolError("missing required 'lotSize'", { instance: message });
            if (!message.hasOwnProperty("priceSpread"))
                throw $util.ProtocolError("missing required 'priceSpread'", { instance: message });
            if (!message.hasOwnProperty("updateTime"))
                throw $util.ProtocolError("missing required 'updateTime'", { instance: message });
            if (!message.hasOwnProperty("highPrice"))
                throw $util.ProtocolError("missing required 'highPrice'", { instance: message });
            if (!message.hasOwnProperty("openPrice"))
                throw $util.ProtocolError("missing required 'openPrice'", { instance: message });
            if (!message.hasOwnProperty("lowPrice"))
                throw $util.ProtocolError("missing required 'lowPrice'", { instance: message });
            if (!message.hasOwnProperty("lastClosePrice"))
                throw $util.ProtocolError("missing required 'lastClosePrice'", { instance: message });
            if (!message.hasOwnProperty("curPrice"))
                throw $util.ProtocolError("missing required 'curPrice'", { instance: message });
            if (!message.hasOwnProperty("volume"))
                throw $util.ProtocolError("missing required 'volume'", { instance: message });
            if (!message.hasOwnProperty("turnover"))
                throw $util.ProtocolError("missing required 'turnover'", { instance: message });
            if (!message.hasOwnProperty("turnoverRate"))
                throw $util.ProtocolError("missing required 'turnoverRate'", { instance: message });
            return message;
        };

        /**
         * Decodes a SnapshotBasicData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetSecuritySnapshot.SnapshotBasicData} SnapshotBasicData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SnapshotBasicData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SnapshotBasicData message.
         * @function verify
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SnapshotBasicData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            if (!$util.isInteger(message.type))
                return "type: integer expected";
            if (typeof message.isSuspend !== "boolean")
                return "isSuspend: boolean expected";
            if (!$util.isString(message.listTime))
                return "listTime: string expected";
            if (!$util.isInteger(message.lotSize))
                return "lotSize: integer expected";
            if (typeof message.priceSpread !== "number")
                return "priceSpread: number expected";
            if (!$util.isString(message.updateTime))
                return "updateTime: string expected";
            if (typeof message.highPrice !== "number")
                return "highPrice: number expected";
            if (typeof message.openPrice !== "number")
                return "openPrice: number expected";
            if (typeof message.lowPrice !== "number")
                return "lowPrice: number expected";
            if (typeof message.lastClosePrice !== "number")
                return "lastClosePrice: number expected";
            if (typeof message.curPrice !== "number")
                return "curPrice: number expected";
            if (!$util.isInteger(message.volume) && !(message.volume && $util.isInteger(message.volume.low) && $util.isInteger(message.volume.high)))
                return "volume: integer|Long expected";
            if (typeof message.turnover !== "number")
                return "turnover: number expected";
            if (typeof message.turnoverRate !== "number")
                return "turnoverRate: number expected";
            if (message.listTimestamp != null && message.hasOwnProperty("listTimestamp"))
                if (typeof message.listTimestamp !== "number")
                    return "listTimestamp: number expected";
            if (message.updateTimestamp != null && message.hasOwnProperty("updateTimestamp"))
                if (typeof message.updateTimestamp !== "number")
                    return "updateTimestamp: number expected";
            if (message.askPrice != null && message.hasOwnProperty("askPrice"))
                if (typeof message.askPrice !== "number")
                    return "askPrice: number expected";
            if (message.bidPrice != null && message.hasOwnProperty("bidPrice"))
                if (typeof message.bidPrice !== "number")
                    return "bidPrice: number expected";
            if (message.askVol != null && message.hasOwnProperty("askVol"))
                if (!$util.isInteger(message.askVol) && !(message.askVol && $util.isInteger(message.askVol.low) && $util.isInteger(message.askVol.high)))
                    return "askVol: integer|Long expected";
            if (message.bidVol != null && message.hasOwnProperty("bidVol"))
                if (!$util.isInteger(message.bidVol) && !(message.bidVol && $util.isInteger(message.bidVol.low) && $util.isInteger(message.bidVol.high)))
                    return "bidVol: integer|Long expected";
            if (message.enableMargin != null && message.hasOwnProperty("enableMargin"))
                if (typeof message.enableMargin !== "boolean")
                    return "enableMargin: boolean expected";
            if (message.mortgageRatio != null && message.hasOwnProperty("mortgageRatio"))
                if (typeof message.mortgageRatio !== "number")
                    return "mortgageRatio: number expected";
            if (message.longMarginInitialRatio != null && message.hasOwnProperty("longMarginInitialRatio"))
                if (typeof message.longMarginInitialRatio !== "number")
                    return "longMarginInitialRatio: number expected";
            if (message.enableShortSell != null && message.hasOwnProperty("enableShortSell"))
                if (typeof message.enableShortSell !== "boolean")
                    return "enableShortSell: boolean expected";
            if (message.shortSellRate != null && message.hasOwnProperty("shortSellRate"))
                if (typeof message.shortSellRate !== "number")
                    return "shortSellRate: number expected";
            if (message.shortAvailableVolume != null && message.hasOwnProperty("shortAvailableVolume"))
                if (!$util.isInteger(message.shortAvailableVolume) && !(message.shortAvailableVolume && $util.isInteger(message.shortAvailableVolume.low) && $util.isInteger(message.shortAvailableVolume.high)))
                    return "shortAvailableVolume: integer|Long expected";
            if (message.shortMarginInitialRatio != null && message.hasOwnProperty("shortMarginInitialRatio"))
                if (typeof message.shortMarginInitialRatio !== "number")
                    return "shortMarginInitialRatio: number expected";
            return null;
        };

        /**
         * Creates a SnapshotBasicData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetSecuritySnapshot.SnapshotBasicData} SnapshotBasicData
         */
        SnapshotBasicData.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetSecuritySnapshot.SnapshotBasicData)
                return object;
            var message = new $root.Qot_GetSecuritySnapshot.SnapshotBasicData();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_GetSecuritySnapshot.SnapshotBasicData.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            if (object.type != null)
                message.type = object.type | 0;
            if (object.isSuspend != null)
                message.isSuspend = Boolean(object.isSuspend);
            if (object.listTime != null)
                message.listTime = String(object.listTime);
            if (object.lotSize != null)
                message.lotSize = object.lotSize | 0;
            if (object.priceSpread != null)
                message.priceSpread = Number(object.priceSpread);
            if (object.updateTime != null)
                message.updateTime = String(object.updateTime);
            if (object.highPrice != null)
                message.highPrice = Number(object.highPrice);
            if (object.openPrice != null)
                message.openPrice = Number(object.openPrice);
            if (object.lowPrice != null)
                message.lowPrice = Number(object.lowPrice);
            if (object.lastClosePrice != null)
                message.lastClosePrice = Number(object.lastClosePrice);
            if (object.curPrice != null)
                message.curPrice = Number(object.curPrice);
            if (object.volume != null)
                if ($util.Long)
                    (message.volume = $util.Long.fromValue(object.volume)).unsigned = false;
                else if (typeof object.volume === "string")
                    message.volume = parseInt(object.volume, 10);
                else if (typeof object.volume === "number")
                    message.volume = object.volume;
                else if (typeof object.volume === "object")
                    message.volume = new $util.LongBits(object.volume.low >>> 0, object.volume.high >>> 0).toNumber();
            if (object.turnover != null)
                message.turnover = Number(object.turnover);
            if (object.turnoverRate != null)
                message.turnoverRate = Number(object.turnoverRate);
            if (object.listTimestamp != null)
                message.listTimestamp = Number(object.listTimestamp);
            if (object.updateTimestamp != null)
                message.updateTimestamp = Number(object.updateTimestamp);
            if (object.askPrice != null)
                message.askPrice = Number(object.askPrice);
            if (object.bidPrice != null)
                message.bidPrice = Number(object.bidPrice);
            if (object.askVol != null)
                if ($util.Long)
                    (message.askVol = $util.Long.fromValue(object.askVol)).unsigned = false;
                else if (typeof object.askVol === "string")
                    message.askVol = parseInt(object.askVol, 10);
                else if (typeof object.askVol === "number")
                    message.askVol = object.askVol;
                else if (typeof object.askVol === "object")
                    message.askVol = new $util.LongBits(object.askVol.low >>> 0, object.askVol.high >>> 0).toNumber();
            if (object.bidVol != null)
                if ($util.Long)
                    (message.bidVol = $util.Long.fromValue(object.bidVol)).unsigned = false;
                else if (typeof object.bidVol === "string")
                    message.bidVol = parseInt(object.bidVol, 10);
                else if (typeof object.bidVol === "number")
                    message.bidVol = object.bidVol;
                else if (typeof object.bidVol === "object")
                    message.bidVol = new $util.LongBits(object.bidVol.low >>> 0, object.bidVol.high >>> 0).toNumber();
            if (object.enableMargin != null)
                message.enableMargin = Boolean(object.enableMargin);
            if (object.mortgageRatio != null)
                message.mortgageRatio = Number(object.mortgageRatio);
            if (object.longMarginInitialRatio != null)
                message.longMarginInitialRatio = Number(object.longMarginInitialRatio);
            if (object.enableShortSell != null)
                message.enableShortSell = Boolean(object.enableShortSell);
            if (object.shortSellRate != null)
                message.shortSellRate = Number(object.shortSellRate);
            if (object.shortAvailableVolume != null)
                if ($util.Long)
                    (message.shortAvailableVolume = $util.Long.fromValue(object.shortAvailableVolume)).unsigned = false;
                else if (typeof object.shortAvailableVolume === "string")
                    message.shortAvailableVolume = parseInt(object.shortAvailableVolume, 10);
                else if (typeof object.shortAvailableVolume === "number")
                    message.shortAvailableVolume = object.shortAvailableVolume;
                else if (typeof object.shortAvailableVolume === "object")
                    message.shortAvailableVolume = new $util.LongBits(object.shortAvailableVolume.low >>> 0, object.shortAvailableVolume.high >>> 0).toNumber();
            if (object.shortMarginInitialRatio != null)
                message.shortMarginInitialRatio = Number(object.shortMarginInitialRatio);
            return message;
        };

        /**
         * Creates a plain object from a SnapshotBasicData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @static
         * @param {Qot_GetSecuritySnapshot.SnapshotBasicData} message SnapshotBasicData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SnapshotBasicData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.security = null;
                object.type = 0;
                object.isSuspend = false;
                object.listTime = "";
                object.lotSize = 0;
                object.priceSpread = 0;
                object.updateTime = "";
                object.highPrice = 0;
                object.openPrice = 0;
                object.lowPrice = 0;
                object.lastClosePrice = 0;
                object.curPrice = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.volume = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.volume = options.longs === String ? "0" : 0;
                object.turnover = 0;
                object.turnoverRate = 0;
                object.listTimestamp = 0;
                object.updateTimestamp = 0;
                object.askPrice = 0;
                object.bidPrice = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.askVol = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.askVol = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.bidVol = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.bidVol = options.longs === String ? "0" : 0;
                object.enableMargin = false;
                object.mortgageRatio = 0;
                object.longMarginInitialRatio = 0;
                object.enableShortSell = false;
                object.shortSellRate = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.shortAvailableVolume = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.shortAvailableVolume = options.longs === String ? "0" : 0;
                object.shortMarginInitialRatio = 0;
            }
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.isSuspend != null && message.hasOwnProperty("isSuspend"))
                object.isSuspend = message.isSuspend;
            if (message.listTime != null && message.hasOwnProperty("listTime"))
                object.listTime = message.listTime;
            if (message.lotSize != null && message.hasOwnProperty("lotSize"))
                object.lotSize = message.lotSize;
            if (message.priceSpread != null && message.hasOwnProperty("priceSpread"))
                object.priceSpread = options.json && !isFinite(message.priceSpread) ? String(message.priceSpread) : message.priceSpread;
            if (message.updateTime != null && message.hasOwnProperty("updateTime"))
                object.updateTime = message.updateTime;
            if (message.highPrice != null && message.hasOwnProperty("highPrice"))
                object.highPrice = options.json && !isFinite(message.highPrice) ? String(message.highPrice) : message.highPrice;
            if (message.openPrice != null && message.hasOwnProperty("openPrice"))
                object.openPrice = options.json && !isFinite(message.openPrice) ? String(message.openPrice) : message.openPrice;
            if (message.lowPrice != null && message.hasOwnProperty("lowPrice"))
                object.lowPrice = options.json && !isFinite(message.lowPrice) ? String(message.lowPrice) : message.lowPrice;
            if (message.lastClosePrice != null && message.hasOwnProperty("lastClosePrice"))
                object.lastClosePrice = options.json && !isFinite(message.lastClosePrice) ? String(message.lastClosePrice) : message.lastClosePrice;
            if (message.curPrice != null && message.hasOwnProperty("curPrice"))
                object.curPrice = options.json && !isFinite(message.curPrice) ? String(message.curPrice) : message.curPrice;
            if (message.volume != null && message.hasOwnProperty("volume"))
                if (typeof message.volume === "number")
                    object.volume = options.longs === String ? String(message.volume) : message.volume;
                else
                    object.volume = options.longs === String ? $util.Long.prototype.toString.call(message.volume) : options.longs === Number ? new $util.LongBits(message.volume.low >>> 0, message.volume.high >>> 0).toNumber() : message.volume;
            if (message.turnover != null && message.hasOwnProperty("turnover"))
                object.turnover = options.json && !isFinite(message.turnover) ? String(message.turnover) : message.turnover;
            if (message.turnoverRate != null && message.hasOwnProperty("turnoverRate"))
                object.turnoverRate = options.json && !isFinite(message.turnoverRate) ? String(message.turnoverRate) : message.turnoverRate;
            if (message.listTimestamp != null && message.hasOwnProperty("listTimestamp"))
                object.listTimestamp = options.json && !isFinite(message.listTimestamp) ? String(message.listTimestamp) : message.listTimestamp;
            if (message.updateTimestamp != null && message.hasOwnProperty("updateTimestamp"))
                object.updateTimestamp = options.json && !isFinite(message.updateTimestamp) ? String(message.updateTimestamp) : message.updateTimestamp;
            if (message.askPrice != null && message.hasOwnProperty("askPrice"))
                object.askPrice = options.json && !isFinite(message.askPrice) ? String(message.askPrice) : message.askPrice;
            if (message.bidPrice != null && message.hasOwnProperty("bidPrice"))
                object.bidPrice = options.json && !isFinite(message.bidPrice) ? String(message.bidPrice) : message.bidPrice;
            if (message.askVol != null && message.hasOwnProperty("askVol"))
                if (typeof message.askVol === "number")
                    object.askVol = options.longs === String ? String(message.askVol) : message.askVol;
                else
                    object.askVol = options.longs === String ? $util.Long.prototype.toString.call(message.askVol) : options.longs === Number ? new $util.LongBits(message.askVol.low >>> 0, message.askVol.high >>> 0).toNumber() : message.askVol;
            if (message.bidVol != null && message.hasOwnProperty("bidVol"))
                if (typeof message.bidVol === "number")
                    object.bidVol = options.longs === String ? String(message.bidVol) : message.bidVol;
                else
                    object.bidVol = options.longs === String ? $util.Long.prototype.toString.call(message.bidVol) : options.longs === Number ? new $util.LongBits(message.bidVol.low >>> 0, message.bidVol.high >>> 0).toNumber() : message.bidVol;
            if (message.enableMargin != null && message.hasOwnProperty("enableMargin"))
                object.enableMargin = message.enableMargin;
            if (message.mortgageRatio != null && message.hasOwnProperty("mortgageRatio"))
                object.mortgageRatio = options.json && !isFinite(message.mortgageRatio) ? String(message.mortgageRatio) : message.mortgageRatio;
            if (message.longMarginInitialRatio != null && message.hasOwnProperty("longMarginInitialRatio"))
                object.longMarginInitialRatio = options.json && !isFinite(message.longMarginInitialRatio) ? String(message.longMarginInitialRatio) : message.longMarginInitialRatio;
            if (message.enableShortSell != null && message.hasOwnProperty("enableShortSell"))
                object.enableShortSell = message.enableShortSell;
            if (message.shortSellRate != null && message.hasOwnProperty("shortSellRate"))
                object.shortSellRate = options.json && !isFinite(message.shortSellRate) ? String(message.shortSellRate) : message.shortSellRate;
            if (message.shortAvailableVolume != null && message.hasOwnProperty("shortAvailableVolume"))
                if (typeof message.shortAvailableVolume === "number")
                    object.shortAvailableVolume = options.longs === String ? String(message.shortAvailableVolume) : message.shortAvailableVolume;
                else
                    object.shortAvailableVolume = options.longs === String ? $util.Long.prototype.toString.call(message.shortAvailableVolume) : options.longs === Number ? new $util.LongBits(message.shortAvailableVolume.low >>> 0, message.shortAvailableVolume.high >>> 0).toNumber() : message.shortAvailableVolume;
            if (message.shortMarginInitialRatio != null && message.hasOwnProperty("shortMarginInitialRatio"))
                object.shortMarginInitialRatio = options.json && !isFinite(message.shortMarginInitialRatio) ? String(message.shortMarginInitialRatio) : message.shortMarginInitialRatio;
            return object;
        };

        /**
         * Converts this SnapshotBasicData to JSON.
         * @function toJSON
         * @memberof Qot_GetSecuritySnapshot.SnapshotBasicData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SnapshotBasicData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SnapshotBasicData;
    })();

    Qot_GetSecuritySnapshot.Snapshot = (function() {

        /**
         * Properties of a Snapshot.
         * @memberof Qot_GetSecuritySnapshot
         * @interface ISnapshot
         * @property {Qot_GetSecuritySnapshot.ISnapshotBasicData} basic Snapshot basic
         * @property {Qot_GetSecuritySnapshot.IEquitySnapshotExData|null} [equityExData] Snapshot equityExData
         * @property {Qot_GetSecuritySnapshot.IWarrantSnapshotExData|null} [warrantExData] Snapshot warrantExData
         * @property {Qot_GetSecuritySnapshot.IOptionSnapshotExData|null} [optionExData] Snapshot optionExData
         */

        /**
         * Constructs a new Snapshot.
         * @memberof Qot_GetSecuritySnapshot
         * @classdesc Represents a Snapshot.
         * @implements ISnapshot
         * @constructor
         * @param {Qot_GetSecuritySnapshot.ISnapshot=} [properties] Properties to set
         */
        function Snapshot(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Snapshot basic.
         * @member {Qot_GetSecuritySnapshot.ISnapshotBasicData} basic
         * @memberof Qot_GetSecuritySnapshot.Snapshot
         * @instance
         */
        Snapshot.prototype.basic = null;

        /**
         * Snapshot equityExData.
         * @member {Qot_GetSecuritySnapshot.IEquitySnapshotExData|null|undefined} equityExData
         * @memberof Qot_GetSecuritySnapshot.Snapshot
         * @instance
         */
        Snapshot.prototype.equityExData = null;

        /**
         * Snapshot warrantExData.
         * @member {Qot_GetSecuritySnapshot.IWarrantSnapshotExData|null|undefined} warrantExData
         * @memberof Qot_GetSecuritySnapshot.Snapshot
         * @instance
         */
        Snapshot.prototype.warrantExData = null;

        /**
         * Snapshot optionExData.
         * @member {Qot_GetSecuritySnapshot.IOptionSnapshotExData|null|undefined} optionExData
         * @memberof Qot_GetSecuritySnapshot.Snapshot
         * @instance
         */
        Snapshot.prototype.optionExData = null;

        /**
         * Creates a new Snapshot instance using the specified properties.
         * @function create
         * @memberof Qot_GetSecuritySnapshot.Snapshot
         * @static
         * @param {Qot_GetSecuritySnapshot.ISnapshot=} [properties] Properties to set
         * @returns {Qot_GetSecuritySnapshot.Snapshot} Snapshot instance
         */
        Snapshot.create = function create(properties) {
            return new Snapshot(properties);
        };

        /**
         * Encodes the specified Snapshot message. Does not implicitly {@link Qot_GetSecuritySnapshot.Snapshot.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetSecuritySnapshot.Snapshot
         * @static
         * @param {Qot_GetSecuritySnapshot.ISnapshot} message Snapshot message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Snapshot.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_GetSecuritySnapshot.SnapshotBasicData.encode(message.basic, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.equityExData != null && message.hasOwnProperty("equityExData"))
                $root.Qot_GetSecuritySnapshot.EquitySnapshotExData.encode(message.equityExData, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.warrantExData != null && message.hasOwnProperty("warrantExData"))
                $root.Qot_GetSecuritySnapshot.WarrantSnapshotExData.encode(message.warrantExData, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.optionExData != null && message.hasOwnProperty("optionExData"))
                $root.Qot_GetSecuritySnapshot.OptionSnapshotExData.encode(message.optionExData, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Snapshot message, length delimited. Does not implicitly {@link Qot_GetSecuritySnapshot.Snapshot.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetSecuritySnapshot.Snapshot
         * @static
         * @param {Qot_GetSecuritySnapshot.ISnapshot} message Snapshot message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Snapshot.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Snapshot message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetSecuritySnapshot.Snapshot
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetSecuritySnapshot.Snapshot} Snapshot
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Snapshot.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetSecuritySnapshot.Snapshot();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.basic = $root.Qot_GetSecuritySnapshot.SnapshotBasicData.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.equityExData = $root.Qot_GetSecuritySnapshot.EquitySnapshotExData.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.warrantExData = $root.Qot_GetSecuritySnapshot.WarrantSnapshotExData.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.optionExData = $root.Qot_GetSecuritySnapshot.OptionSnapshotExData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("basic"))
                throw $util.ProtocolError("missing required 'basic'", { instance: message });
            return message;
        };

        /**
         * Decodes a Snapshot message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetSecuritySnapshot.Snapshot
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetSecuritySnapshot.Snapshot} Snapshot
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Snapshot.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Snapshot message.
         * @function verify
         * @memberof Qot_GetSecuritySnapshot.Snapshot
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Snapshot.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_GetSecuritySnapshot.SnapshotBasicData.verify(message.basic);
                if (error)
                    return "basic." + error;
            }
            if (message.equityExData != null && message.hasOwnProperty("equityExData")) {
                var error = $root.Qot_GetSecuritySnapshot.EquitySnapshotExData.verify(message.equityExData);
                if (error)
                    return "equityExData." + error;
            }
            if (message.warrantExData != null && message.hasOwnProperty("warrantExData")) {
                var error = $root.Qot_GetSecuritySnapshot.WarrantSnapshotExData.verify(message.warrantExData);
                if (error)
                    return "warrantExData." + error;
            }
            if (message.optionExData != null && message.hasOwnProperty("optionExData")) {
                var error = $root.Qot_GetSecuritySnapshot.OptionSnapshotExData.verify(message.optionExData);
                if (error)
                    return "optionExData." + error;
            }
            return null;
        };

        /**
         * Creates a Snapshot message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetSecuritySnapshot.Snapshot
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetSecuritySnapshot.Snapshot} Snapshot
         */
        Snapshot.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetSecuritySnapshot.Snapshot)
                return object;
            var message = new $root.Qot_GetSecuritySnapshot.Snapshot();
            if (object.basic != null) {
                if (typeof object.basic !== "object")
                    throw TypeError(".Qot_GetSecuritySnapshot.Snapshot.basic: object expected");
                message.basic = $root.Qot_GetSecuritySnapshot.SnapshotBasicData.fromObject(object.basic);
            }
            if (object.equityExData != null) {
                if (typeof object.equityExData !== "object")
                    throw TypeError(".Qot_GetSecuritySnapshot.Snapshot.equityExData: object expected");
                message.equityExData = $root.Qot_GetSecuritySnapshot.EquitySnapshotExData.fromObject(object.equityExData);
            }
            if (object.warrantExData != null) {
                if (typeof object.warrantExData !== "object")
                    throw TypeError(".Qot_GetSecuritySnapshot.Snapshot.warrantExData: object expected");
                message.warrantExData = $root.Qot_GetSecuritySnapshot.WarrantSnapshotExData.fromObject(object.warrantExData);
            }
            if (object.optionExData != null) {
                if (typeof object.optionExData !== "object")
                    throw TypeError(".Qot_GetSecuritySnapshot.Snapshot.optionExData: object expected");
                message.optionExData = $root.Qot_GetSecuritySnapshot.OptionSnapshotExData.fromObject(object.optionExData);
            }
            return message;
        };

        /**
         * Creates a plain object from a Snapshot message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetSecuritySnapshot.Snapshot
         * @static
         * @param {Qot_GetSecuritySnapshot.Snapshot} message Snapshot
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Snapshot.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.basic = null;
                object.equityExData = null;
                object.warrantExData = null;
                object.optionExData = null;
            }
            if (message.basic != null && message.hasOwnProperty("basic"))
                object.basic = $root.Qot_GetSecuritySnapshot.SnapshotBasicData.toObject(message.basic, options);
            if (message.equityExData != null && message.hasOwnProperty("equityExData"))
                object.equityExData = $root.Qot_GetSecuritySnapshot.EquitySnapshotExData.toObject(message.equityExData, options);
            if (message.warrantExData != null && message.hasOwnProperty("warrantExData"))
                object.warrantExData = $root.Qot_GetSecuritySnapshot.WarrantSnapshotExData.toObject(message.warrantExData, options);
            if (message.optionExData != null && message.hasOwnProperty("optionExData"))
                object.optionExData = $root.Qot_GetSecuritySnapshot.OptionSnapshotExData.toObject(message.optionExData, options);
            return object;
        };

        /**
         * Converts this Snapshot to JSON.
         * @function toJSON
         * @memberof Qot_GetSecuritySnapshot.Snapshot
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Snapshot.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Snapshot;
    })();

    Qot_GetSecuritySnapshot.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_GetSecuritySnapshot
         * @interface IS2C
         * @property {Array.<Qot_GetSecuritySnapshot.ISnapshot>|null} [snapshotList] S2C snapshotList
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_GetSecuritySnapshot
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_GetSecuritySnapshot.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.snapshotList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C snapshotList.
         * @member {Array.<Qot_GetSecuritySnapshot.ISnapshot>} snapshotList
         * @memberof Qot_GetSecuritySnapshot.S2C
         * @instance
         */
        S2C.prototype.snapshotList = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_GetSecuritySnapshot.S2C
         * @static
         * @param {Qot_GetSecuritySnapshot.IS2C=} [properties] Properties to set
         * @returns {Qot_GetSecuritySnapshot.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_GetSecuritySnapshot.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetSecuritySnapshot.S2C
         * @static
         * @param {Qot_GetSecuritySnapshot.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.snapshotList != null && message.snapshotList.length)
                for (var i = 0; i < message.snapshotList.length; ++i)
                    $root.Qot_GetSecuritySnapshot.Snapshot.encode(message.snapshotList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_GetSecuritySnapshot.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetSecuritySnapshot.S2C
         * @static
         * @param {Qot_GetSecuritySnapshot.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetSecuritySnapshot.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetSecuritySnapshot.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetSecuritySnapshot.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.snapshotList && message.snapshotList.length))
                        message.snapshotList = [];
                    message.snapshotList.push($root.Qot_GetSecuritySnapshot.Snapshot.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetSecuritySnapshot.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetSecuritySnapshot.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_GetSecuritySnapshot.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.snapshotList != null && message.hasOwnProperty("snapshotList")) {
                if (!Array.isArray(message.snapshotList))
                    return "snapshotList: array expected";
                for (var i = 0; i < message.snapshotList.length; ++i) {
                    var error = $root.Qot_GetSecuritySnapshot.Snapshot.verify(message.snapshotList[i]);
                    if (error)
                        return "snapshotList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetSecuritySnapshot.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetSecuritySnapshot.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetSecuritySnapshot.S2C)
                return object;
            var message = new $root.Qot_GetSecuritySnapshot.S2C();
            if (object.snapshotList) {
                if (!Array.isArray(object.snapshotList))
                    throw TypeError(".Qot_GetSecuritySnapshot.S2C.snapshotList: array expected");
                message.snapshotList = [];
                for (var i = 0; i < object.snapshotList.length; ++i) {
                    if (typeof object.snapshotList[i] !== "object")
                        throw TypeError(".Qot_GetSecuritySnapshot.S2C.snapshotList: object expected");
                    message.snapshotList[i] = $root.Qot_GetSecuritySnapshot.Snapshot.fromObject(object.snapshotList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetSecuritySnapshot.S2C
         * @static
         * @param {Qot_GetSecuritySnapshot.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.snapshotList = [];
            if (message.snapshotList && message.snapshotList.length) {
                object.snapshotList = [];
                for (var j = 0; j < message.snapshotList.length; ++j)
                    object.snapshotList[j] = $root.Qot_GetSecuritySnapshot.Snapshot.toObject(message.snapshotList[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_GetSecuritySnapshot.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_GetSecuritySnapshot.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Qot_GetSecuritySnapshot
         * @interface IRequest
         * @property {Qot_GetSecuritySnapshot.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Qot_GetSecuritySnapshot
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Qot_GetSecuritySnapshot.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Qot_GetSecuritySnapshot.IC2S} c2s
         * @memberof Qot_GetSecuritySnapshot.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Qot_GetSecuritySnapshot.Request
         * @static
         * @param {Qot_GetSecuritySnapshot.IRequest=} [properties] Properties to set
         * @returns {Qot_GetSecuritySnapshot.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Qot_GetSecuritySnapshot.Request.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetSecuritySnapshot.Request
         * @static
         * @param {Qot_GetSecuritySnapshot.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_GetSecuritySnapshot.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Qot_GetSecuritySnapshot.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetSecuritySnapshot.Request
         * @static
         * @param {Qot_GetSecuritySnapshot.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetSecuritySnapshot.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetSecuritySnapshot.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetSecuritySnapshot.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Qot_GetSecuritySnapshot.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetSecuritySnapshot.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetSecuritySnapshot.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Qot_GetSecuritySnapshot.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_GetSecuritySnapshot.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetSecuritySnapshot.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetSecuritySnapshot.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetSecuritySnapshot.Request)
                return object;
            var message = new $root.Qot_GetSecuritySnapshot.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Qot_GetSecuritySnapshot.Request.c2s: object expected");
                message.c2s = $root.Qot_GetSecuritySnapshot.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetSecuritySnapshot.Request
         * @static
         * @param {Qot_GetSecuritySnapshot.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Qot_GetSecuritySnapshot.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Qot_GetSecuritySnapshot.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Qot_GetSecuritySnapshot.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_GetSecuritySnapshot
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_GetSecuritySnapshot.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_GetSecuritySnapshot
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_GetSecuritySnapshot.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_GetSecuritySnapshot.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_GetSecuritySnapshot.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_GetSecuritySnapshot.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_GetSecuritySnapshot.IS2C|null|undefined} s2c
         * @memberof Qot_GetSecuritySnapshot.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_GetSecuritySnapshot.Response
         * @static
         * @param {Qot_GetSecuritySnapshot.IResponse=} [properties] Properties to set
         * @returns {Qot_GetSecuritySnapshot.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_GetSecuritySnapshot.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetSecuritySnapshot.Response
         * @static
         * @param {Qot_GetSecuritySnapshot.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_GetSecuritySnapshot.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_GetSecuritySnapshot.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetSecuritySnapshot.Response
         * @static
         * @param {Qot_GetSecuritySnapshot.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetSecuritySnapshot.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetSecuritySnapshot.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetSecuritySnapshot.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_GetSecuritySnapshot.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetSecuritySnapshot.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetSecuritySnapshot.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_GetSecuritySnapshot.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_GetSecuritySnapshot.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetSecuritySnapshot.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetSecuritySnapshot.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetSecuritySnapshot.Response)
                return object;
            var message = new $root.Qot_GetSecuritySnapshot.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_GetSecuritySnapshot.Response.s2c: object expected");
                message.s2c = $root.Qot_GetSecuritySnapshot.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetSecuritySnapshot.Response
         * @static
         * @param {Qot_GetSecuritySnapshot.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_GetSecuritySnapshot.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_GetSecuritySnapshot.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_GetSecuritySnapshot;
})();

$root.Qot_GetStaticInfo = (function() {

    /**
     * Namespace Qot_GetStaticInfo.
     * @exports Qot_GetStaticInfo
     * @namespace
     */
    var Qot_GetStaticInfo = {};

    Qot_GetStaticInfo.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Qot_GetStaticInfo
         * @interface IC2S
         * @property {number|null} [market] C2S market
         * @property {number|null} [secType] C2S secType
         * @property {Array.<Qot_Common.ISecurity>|null} [securityList] C2S securityList
         */

        /**
         * Constructs a new C2S.
         * @memberof Qot_GetStaticInfo
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Qot_GetStaticInfo.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            this.securityList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S market.
         * @member {number} market
         * @memberof Qot_GetStaticInfo.C2S
         * @instance
         */
        C2S.prototype.market = 0;

        /**
         * C2S secType.
         * @member {number} secType
         * @memberof Qot_GetStaticInfo.C2S
         * @instance
         */
        C2S.prototype.secType = 0;

        /**
         * C2S securityList.
         * @member {Array.<Qot_Common.ISecurity>} securityList
         * @memberof Qot_GetStaticInfo.C2S
         * @instance
         */
        C2S.prototype.securityList = $util.emptyArray;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Qot_GetStaticInfo.C2S
         * @static
         * @param {Qot_GetStaticInfo.IC2S=} [properties] Properties to set
         * @returns {Qot_GetStaticInfo.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Qot_GetStaticInfo.C2S.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetStaticInfo.C2S
         * @static
         * @param {Qot_GetStaticInfo.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.market != null && message.hasOwnProperty("market"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.market);
            if (message.secType != null && message.hasOwnProperty("secType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.secType);
            if (message.securityList != null && message.securityList.length)
                for (var i = 0; i < message.securityList.length; ++i)
                    $root.Qot_Common.Security.encode(message.securityList[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Qot_GetStaticInfo.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetStaticInfo.C2S
         * @static
         * @param {Qot_GetStaticInfo.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetStaticInfo.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetStaticInfo.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetStaticInfo.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.market = reader.int32();
                    break;
                case 2:
                    message.secType = reader.int32();
                    break;
                case 3:
                    if (!(message.securityList && message.securityList.length))
                        message.securityList = [];
                    message.securityList.push($root.Qot_Common.Security.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetStaticInfo.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetStaticInfo.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Qot_GetStaticInfo.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.market != null && message.hasOwnProperty("market"))
                if (!$util.isInteger(message.market))
                    return "market: integer expected";
            if (message.secType != null && message.hasOwnProperty("secType"))
                if (!$util.isInteger(message.secType))
                    return "secType: integer expected";
            if (message.securityList != null && message.hasOwnProperty("securityList")) {
                if (!Array.isArray(message.securityList))
                    return "securityList: array expected";
                for (var i = 0; i < message.securityList.length; ++i) {
                    var error = $root.Qot_Common.Security.verify(message.securityList[i]);
                    if (error)
                        return "securityList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetStaticInfo.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetStaticInfo.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetStaticInfo.C2S)
                return object;
            var message = new $root.Qot_GetStaticInfo.C2S();
            if (object.market != null)
                message.market = object.market | 0;
            if (object.secType != null)
                message.secType = object.secType | 0;
            if (object.securityList) {
                if (!Array.isArray(object.securityList))
                    throw TypeError(".Qot_GetStaticInfo.C2S.securityList: array expected");
                message.securityList = [];
                for (var i = 0; i < object.securityList.length; ++i) {
                    if (typeof object.securityList[i] !== "object")
                        throw TypeError(".Qot_GetStaticInfo.C2S.securityList: object expected");
                    message.securityList[i] = $root.Qot_Common.Security.fromObject(object.securityList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetStaticInfo.C2S
         * @static
         * @param {Qot_GetStaticInfo.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.securityList = [];
            if (options.defaults) {
                object.market = 0;
                object.secType = 0;
            }
            if (message.market != null && message.hasOwnProperty("market"))
                object.market = message.market;
            if (message.secType != null && message.hasOwnProperty("secType"))
                object.secType = message.secType;
            if (message.securityList && message.securityList.length) {
                object.securityList = [];
                for (var j = 0; j < message.securityList.length; ++j)
                    object.securityList[j] = $root.Qot_Common.Security.toObject(message.securityList[j], options);
            }
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Qot_GetStaticInfo.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Qot_GetStaticInfo.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_GetStaticInfo
         * @interface IS2C
         * @property {Array.<Qot_Common.ISecurityStaticInfo>|null} [staticInfoList] S2C staticInfoList
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_GetStaticInfo
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_GetStaticInfo.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.staticInfoList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C staticInfoList.
         * @member {Array.<Qot_Common.ISecurityStaticInfo>} staticInfoList
         * @memberof Qot_GetStaticInfo.S2C
         * @instance
         */
        S2C.prototype.staticInfoList = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_GetStaticInfo.S2C
         * @static
         * @param {Qot_GetStaticInfo.IS2C=} [properties] Properties to set
         * @returns {Qot_GetStaticInfo.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_GetStaticInfo.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetStaticInfo.S2C
         * @static
         * @param {Qot_GetStaticInfo.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.staticInfoList != null && message.staticInfoList.length)
                for (var i = 0; i < message.staticInfoList.length; ++i)
                    $root.Qot_Common.SecurityStaticInfo.encode(message.staticInfoList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_GetStaticInfo.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetStaticInfo.S2C
         * @static
         * @param {Qot_GetStaticInfo.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetStaticInfo.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetStaticInfo.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetStaticInfo.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.staticInfoList && message.staticInfoList.length))
                        message.staticInfoList = [];
                    message.staticInfoList.push($root.Qot_Common.SecurityStaticInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetStaticInfo.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetStaticInfo.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_GetStaticInfo.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.staticInfoList != null && message.hasOwnProperty("staticInfoList")) {
                if (!Array.isArray(message.staticInfoList))
                    return "staticInfoList: array expected";
                for (var i = 0; i < message.staticInfoList.length; ++i) {
                    var error = $root.Qot_Common.SecurityStaticInfo.verify(message.staticInfoList[i]);
                    if (error)
                        return "staticInfoList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetStaticInfo.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetStaticInfo.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetStaticInfo.S2C)
                return object;
            var message = new $root.Qot_GetStaticInfo.S2C();
            if (object.staticInfoList) {
                if (!Array.isArray(object.staticInfoList))
                    throw TypeError(".Qot_GetStaticInfo.S2C.staticInfoList: array expected");
                message.staticInfoList = [];
                for (var i = 0; i < object.staticInfoList.length; ++i) {
                    if (typeof object.staticInfoList[i] !== "object")
                        throw TypeError(".Qot_GetStaticInfo.S2C.staticInfoList: object expected");
                    message.staticInfoList[i] = $root.Qot_Common.SecurityStaticInfo.fromObject(object.staticInfoList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetStaticInfo.S2C
         * @static
         * @param {Qot_GetStaticInfo.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.staticInfoList = [];
            if (message.staticInfoList && message.staticInfoList.length) {
                object.staticInfoList = [];
                for (var j = 0; j < message.staticInfoList.length; ++j)
                    object.staticInfoList[j] = $root.Qot_Common.SecurityStaticInfo.toObject(message.staticInfoList[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_GetStaticInfo.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_GetStaticInfo.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Qot_GetStaticInfo
         * @interface IRequest
         * @property {Qot_GetStaticInfo.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Qot_GetStaticInfo
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Qot_GetStaticInfo.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Qot_GetStaticInfo.IC2S} c2s
         * @memberof Qot_GetStaticInfo.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Qot_GetStaticInfo.Request
         * @static
         * @param {Qot_GetStaticInfo.IRequest=} [properties] Properties to set
         * @returns {Qot_GetStaticInfo.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Qot_GetStaticInfo.Request.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetStaticInfo.Request
         * @static
         * @param {Qot_GetStaticInfo.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_GetStaticInfo.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Qot_GetStaticInfo.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetStaticInfo.Request
         * @static
         * @param {Qot_GetStaticInfo.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetStaticInfo.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetStaticInfo.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetStaticInfo.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Qot_GetStaticInfo.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetStaticInfo.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetStaticInfo.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Qot_GetStaticInfo.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_GetStaticInfo.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetStaticInfo.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetStaticInfo.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetStaticInfo.Request)
                return object;
            var message = new $root.Qot_GetStaticInfo.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Qot_GetStaticInfo.Request.c2s: object expected");
                message.c2s = $root.Qot_GetStaticInfo.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetStaticInfo.Request
         * @static
         * @param {Qot_GetStaticInfo.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Qot_GetStaticInfo.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Qot_GetStaticInfo.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Qot_GetStaticInfo.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_GetStaticInfo
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_GetStaticInfo.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_GetStaticInfo
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_GetStaticInfo.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_GetStaticInfo.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_GetStaticInfo.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_GetStaticInfo.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_GetStaticInfo.IS2C|null|undefined} s2c
         * @memberof Qot_GetStaticInfo.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_GetStaticInfo.Response
         * @static
         * @param {Qot_GetStaticInfo.IResponse=} [properties] Properties to set
         * @returns {Qot_GetStaticInfo.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_GetStaticInfo.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetStaticInfo.Response
         * @static
         * @param {Qot_GetStaticInfo.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_GetStaticInfo.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_GetStaticInfo.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetStaticInfo.Response
         * @static
         * @param {Qot_GetStaticInfo.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetStaticInfo.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetStaticInfo.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetStaticInfo.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_GetStaticInfo.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetStaticInfo.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetStaticInfo.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_GetStaticInfo.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_GetStaticInfo.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetStaticInfo.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetStaticInfo.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetStaticInfo.Response)
                return object;
            var message = new $root.Qot_GetStaticInfo.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_GetStaticInfo.Response.s2c: object expected");
                message.s2c = $root.Qot_GetStaticInfo.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetStaticInfo.Response
         * @static
         * @param {Qot_GetStaticInfo.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_GetStaticInfo.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_GetStaticInfo.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_GetStaticInfo;
})();

$root.Qot_GetSubInfo = (function() {

    /**
     * Namespace Qot_GetSubInfo.
     * @exports Qot_GetSubInfo
     * @namespace
     */
    var Qot_GetSubInfo = {};

    Qot_GetSubInfo.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Qot_GetSubInfo
         * @interface IC2S
         * @property {boolean|null} [isReqAllConn] C2S isReqAllConn
         */

        /**
         * Constructs a new C2S.
         * @memberof Qot_GetSubInfo
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Qot_GetSubInfo.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S isReqAllConn.
         * @member {boolean} isReqAllConn
         * @memberof Qot_GetSubInfo.C2S
         * @instance
         */
        C2S.prototype.isReqAllConn = false;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Qot_GetSubInfo.C2S
         * @static
         * @param {Qot_GetSubInfo.IC2S=} [properties] Properties to set
         * @returns {Qot_GetSubInfo.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Qot_GetSubInfo.C2S.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetSubInfo.C2S
         * @static
         * @param {Qot_GetSubInfo.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.isReqAllConn != null && message.hasOwnProperty("isReqAllConn"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.isReqAllConn);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Qot_GetSubInfo.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetSubInfo.C2S
         * @static
         * @param {Qot_GetSubInfo.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetSubInfo.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetSubInfo.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetSubInfo.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.isReqAllConn = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetSubInfo.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetSubInfo.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Qot_GetSubInfo.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.isReqAllConn != null && message.hasOwnProperty("isReqAllConn"))
                if (typeof message.isReqAllConn !== "boolean")
                    return "isReqAllConn: boolean expected";
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetSubInfo.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetSubInfo.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetSubInfo.C2S)
                return object;
            var message = new $root.Qot_GetSubInfo.C2S();
            if (object.isReqAllConn != null)
                message.isReqAllConn = Boolean(object.isReqAllConn);
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetSubInfo.C2S
         * @static
         * @param {Qot_GetSubInfo.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.isReqAllConn = false;
            if (message.isReqAllConn != null && message.hasOwnProperty("isReqAllConn"))
                object.isReqAllConn = message.isReqAllConn;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Qot_GetSubInfo.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Qot_GetSubInfo.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_GetSubInfo
         * @interface IS2C
         * @property {Array.<Qot_Common.IConnSubInfo>|null} [connSubInfoList] S2C connSubInfoList
         * @property {number} totalUsedQuota S2C totalUsedQuota
         * @property {number} remainQuota S2C remainQuota
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_GetSubInfo
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_GetSubInfo.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.connSubInfoList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C connSubInfoList.
         * @member {Array.<Qot_Common.IConnSubInfo>} connSubInfoList
         * @memberof Qot_GetSubInfo.S2C
         * @instance
         */
        S2C.prototype.connSubInfoList = $util.emptyArray;

        /**
         * S2C totalUsedQuota.
         * @member {number} totalUsedQuota
         * @memberof Qot_GetSubInfo.S2C
         * @instance
         */
        S2C.prototype.totalUsedQuota = 0;

        /**
         * S2C remainQuota.
         * @member {number} remainQuota
         * @memberof Qot_GetSubInfo.S2C
         * @instance
         */
        S2C.prototype.remainQuota = 0;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_GetSubInfo.S2C
         * @static
         * @param {Qot_GetSubInfo.IS2C=} [properties] Properties to set
         * @returns {Qot_GetSubInfo.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_GetSubInfo.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetSubInfo.S2C
         * @static
         * @param {Qot_GetSubInfo.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.connSubInfoList != null && message.connSubInfoList.length)
                for (var i = 0; i < message.connSubInfoList.length; ++i)
                    $root.Qot_Common.ConnSubInfo.encode(message.connSubInfoList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.totalUsedQuota);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.remainQuota);
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_GetSubInfo.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetSubInfo.S2C
         * @static
         * @param {Qot_GetSubInfo.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetSubInfo.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetSubInfo.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetSubInfo.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.connSubInfoList && message.connSubInfoList.length))
                        message.connSubInfoList = [];
                    message.connSubInfoList.push($root.Qot_Common.ConnSubInfo.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.totalUsedQuota = reader.int32();
                    break;
                case 3:
                    message.remainQuota = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("totalUsedQuota"))
                throw $util.ProtocolError("missing required 'totalUsedQuota'", { instance: message });
            if (!message.hasOwnProperty("remainQuota"))
                throw $util.ProtocolError("missing required 'remainQuota'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetSubInfo.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetSubInfo.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_GetSubInfo.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.connSubInfoList != null && message.hasOwnProperty("connSubInfoList")) {
                if (!Array.isArray(message.connSubInfoList))
                    return "connSubInfoList: array expected";
                for (var i = 0; i < message.connSubInfoList.length; ++i) {
                    var error = $root.Qot_Common.ConnSubInfo.verify(message.connSubInfoList[i]);
                    if (error)
                        return "connSubInfoList." + error;
                }
            }
            if (!$util.isInteger(message.totalUsedQuota))
                return "totalUsedQuota: integer expected";
            if (!$util.isInteger(message.remainQuota))
                return "remainQuota: integer expected";
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetSubInfo.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetSubInfo.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetSubInfo.S2C)
                return object;
            var message = new $root.Qot_GetSubInfo.S2C();
            if (object.connSubInfoList) {
                if (!Array.isArray(object.connSubInfoList))
                    throw TypeError(".Qot_GetSubInfo.S2C.connSubInfoList: array expected");
                message.connSubInfoList = [];
                for (var i = 0; i < object.connSubInfoList.length; ++i) {
                    if (typeof object.connSubInfoList[i] !== "object")
                        throw TypeError(".Qot_GetSubInfo.S2C.connSubInfoList: object expected");
                    message.connSubInfoList[i] = $root.Qot_Common.ConnSubInfo.fromObject(object.connSubInfoList[i]);
                }
            }
            if (object.totalUsedQuota != null)
                message.totalUsedQuota = object.totalUsedQuota | 0;
            if (object.remainQuota != null)
                message.remainQuota = object.remainQuota | 0;
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetSubInfo.S2C
         * @static
         * @param {Qot_GetSubInfo.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.connSubInfoList = [];
            if (options.defaults) {
                object.totalUsedQuota = 0;
                object.remainQuota = 0;
            }
            if (message.connSubInfoList && message.connSubInfoList.length) {
                object.connSubInfoList = [];
                for (var j = 0; j < message.connSubInfoList.length; ++j)
                    object.connSubInfoList[j] = $root.Qot_Common.ConnSubInfo.toObject(message.connSubInfoList[j], options);
            }
            if (message.totalUsedQuota != null && message.hasOwnProperty("totalUsedQuota"))
                object.totalUsedQuota = message.totalUsedQuota;
            if (message.remainQuota != null && message.hasOwnProperty("remainQuota"))
                object.remainQuota = message.remainQuota;
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_GetSubInfo.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_GetSubInfo.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Qot_GetSubInfo
         * @interface IRequest
         * @property {Qot_GetSubInfo.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Qot_GetSubInfo
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Qot_GetSubInfo.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Qot_GetSubInfo.IC2S} c2s
         * @memberof Qot_GetSubInfo.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Qot_GetSubInfo.Request
         * @static
         * @param {Qot_GetSubInfo.IRequest=} [properties] Properties to set
         * @returns {Qot_GetSubInfo.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Qot_GetSubInfo.Request.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetSubInfo.Request
         * @static
         * @param {Qot_GetSubInfo.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_GetSubInfo.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Qot_GetSubInfo.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetSubInfo.Request
         * @static
         * @param {Qot_GetSubInfo.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetSubInfo.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetSubInfo.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetSubInfo.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Qot_GetSubInfo.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetSubInfo.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetSubInfo.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Qot_GetSubInfo.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_GetSubInfo.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetSubInfo.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetSubInfo.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetSubInfo.Request)
                return object;
            var message = new $root.Qot_GetSubInfo.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Qot_GetSubInfo.Request.c2s: object expected");
                message.c2s = $root.Qot_GetSubInfo.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetSubInfo.Request
         * @static
         * @param {Qot_GetSubInfo.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Qot_GetSubInfo.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Qot_GetSubInfo.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Qot_GetSubInfo.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_GetSubInfo
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_GetSubInfo.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_GetSubInfo
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_GetSubInfo.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_GetSubInfo.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_GetSubInfo.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_GetSubInfo.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_GetSubInfo.IS2C|null|undefined} s2c
         * @memberof Qot_GetSubInfo.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_GetSubInfo.Response
         * @static
         * @param {Qot_GetSubInfo.IResponse=} [properties] Properties to set
         * @returns {Qot_GetSubInfo.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_GetSubInfo.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetSubInfo.Response
         * @static
         * @param {Qot_GetSubInfo.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_GetSubInfo.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_GetSubInfo.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetSubInfo.Response
         * @static
         * @param {Qot_GetSubInfo.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetSubInfo.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetSubInfo.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetSubInfo.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_GetSubInfo.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetSubInfo.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetSubInfo.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_GetSubInfo.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_GetSubInfo.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetSubInfo.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetSubInfo.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetSubInfo.Response)
                return object;
            var message = new $root.Qot_GetSubInfo.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_GetSubInfo.Response.s2c: object expected");
                message.s2c = $root.Qot_GetSubInfo.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetSubInfo.Response
         * @static
         * @param {Qot_GetSubInfo.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_GetSubInfo.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_GetSubInfo.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_GetSubInfo;
})();

$root.Qot_GetSuspend = (function() {

    /**
     * Namespace Qot_GetSuspend.
     * @exports Qot_GetSuspend
     * @namespace
     */
    var Qot_GetSuspend = {};

    Qot_GetSuspend.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Qot_GetSuspend
         * @interface IC2S
         * @property {Array.<Qot_Common.ISecurity>|null} [securityList] C2S securityList
         * @property {string} beginTime C2S beginTime
         * @property {string} endTime C2S endTime
         */

        /**
         * Constructs a new C2S.
         * @memberof Qot_GetSuspend
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Qot_GetSuspend.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            this.securityList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S securityList.
         * @member {Array.<Qot_Common.ISecurity>} securityList
         * @memberof Qot_GetSuspend.C2S
         * @instance
         */
        C2S.prototype.securityList = $util.emptyArray;

        /**
         * C2S beginTime.
         * @member {string} beginTime
         * @memberof Qot_GetSuspend.C2S
         * @instance
         */
        C2S.prototype.beginTime = "";

        /**
         * C2S endTime.
         * @member {string} endTime
         * @memberof Qot_GetSuspend.C2S
         * @instance
         */
        C2S.prototype.endTime = "";

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Qot_GetSuspend.C2S
         * @static
         * @param {Qot_GetSuspend.IC2S=} [properties] Properties to set
         * @returns {Qot_GetSuspend.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Qot_GetSuspend.C2S.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetSuspend.C2S
         * @static
         * @param {Qot_GetSuspend.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.securityList != null && message.securityList.length)
                for (var i = 0; i < message.securityList.length; ++i)
                    $root.Qot_Common.Security.encode(message.securityList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.beginTime);
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.endTime);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Qot_GetSuspend.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetSuspend.C2S
         * @static
         * @param {Qot_GetSuspend.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetSuspend.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetSuspend.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetSuspend.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.securityList && message.securityList.length))
                        message.securityList = [];
                    message.securityList.push($root.Qot_Common.Security.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.beginTime = reader.string();
                    break;
                case 3:
                    message.endTime = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("beginTime"))
                throw $util.ProtocolError("missing required 'beginTime'", { instance: message });
            if (!message.hasOwnProperty("endTime"))
                throw $util.ProtocolError("missing required 'endTime'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetSuspend.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetSuspend.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Qot_GetSuspend.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.securityList != null && message.hasOwnProperty("securityList")) {
                if (!Array.isArray(message.securityList))
                    return "securityList: array expected";
                for (var i = 0; i < message.securityList.length; ++i) {
                    var error = $root.Qot_Common.Security.verify(message.securityList[i]);
                    if (error)
                        return "securityList." + error;
                }
            }
            if (!$util.isString(message.beginTime))
                return "beginTime: string expected";
            if (!$util.isString(message.endTime))
                return "endTime: string expected";
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetSuspend.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetSuspend.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetSuspend.C2S)
                return object;
            var message = new $root.Qot_GetSuspend.C2S();
            if (object.securityList) {
                if (!Array.isArray(object.securityList))
                    throw TypeError(".Qot_GetSuspend.C2S.securityList: array expected");
                message.securityList = [];
                for (var i = 0; i < object.securityList.length; ++i) {
                    if (typeof object.securityList[i] !== "object")
                        throw TypeError(".Qot_GetSuspend.C2S.securityList: object expected");
                    message.securityList[i] = $root.Qot_Common.Security.fromObject(object.securityList[i]);
                }
            }
            if (object.beginTime != null)
                message.beginTime = String(object.beginTime);
            if (object.endTime != null)
                message.endTime = String(object.endTime);
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetSuspend.C2S
         * @static
         * @param {Qot_GetSuspend.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.securityList = [];
            if (options.defaults) {
                object.beginTime = "";
                object.endTime = "";
            }
            if (message.securityList && message.securityList.length) {
                object.securityList = [];
                for (var j = 0; j < message.securityList.length; ++j)
                    object.securityList[j] = $root.Qot_Common.Security.toObject(message.securityList[j], options);
            }
            if (message.beginTime != null && message.hasOwnProperty("beginTime"))
                object.beginTime = message.beginTime;
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                object.endTime = message.endTime;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Qot_GetSuspend.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Qot_GetSuspend.Suspend = (function() {

        /**
         * Properties of a Suspend.
         * @memberof Qot_GetSuspend
         * @interface ISuspend
         * @property {string} time Suspend time
         * @property {number|null} [timestamp] Suspend timestamp
         */

        /**
         * Constructs a new Suspend.
         * @memberof Qot_GetSuspend
         * @classdesc Represents a Suspend.
         * @implements ISuspend
         * @constructor
         * @param {Qot_GetSuspend.ISuspend=} [properties] Properties to set
         */
        function Suspend(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Suspend time.
         * @member {string} time
         * @memberof Qot_GetSuspend.Suspend
         * @instance
         */
        Suspend.prototype.time = "";

        /**
         * Suspend timestamp.
         * @member {number} timestamp
         * @memberof Qot_GetSuspend.Suspend
         * @instance
         */
        Suspend.prototype.timestamp = 0;

        /**
         * Creates a new Suspend instance using the specified properties.
         * @function create
         * @memberof Qot_GetSuspend.Suspend
         * @static
         * @param {Qot_GetSuspend.ISuspend=} [properties] Properties to set
         * @returns {Qot_GetSuspend.Suspend} Suspend instance
         */
        Suspend.create = function create(properties) {
            return new Suspend(properties);
        };

        /**
         * Encodes the specified Suspend message. Does not implicitly {@link Qot_GetSuspend.Suspend.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetSuspend.Suspend
         * @static
         * @param {Qot_GetSuspend.ISuspend} message Suspend message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Suspend.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.time);
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                writer.uint32(/* id 2, wireType 1 =*/17).double(message.timestamp);
            return writer;
        };

        /**
         * Encodes the specified Suspend message, length delimited. Does not implicitly {@link Qot_GetSuspend.Suspend.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetSuspend.Suspend
         * @static
         * @param {Qot_GetSuspend.ISuspend} message Suspend message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Suspend.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Suspend message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetSuspend.Suspend
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetSuspend.Suspend} Suspend
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Suspend.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetSuspend.Suspend();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.time = reader.string();
                    break;
                case 2:
                    message.timestamp = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("time"))
                throw $util.ProtocolError("missing required 'time'", { instance: message });
            return message;
        };

        /**
         * Decodes a Suspend message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetSuspend.Suspend
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetSuspend.Suspend} Suspend
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Suspend.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Suspend message.
         * @function verify
         * @memberof Qot_GetSuspend.Suspend
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Suspend.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.time))
                return "time: string expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp !== "number")
                    return "timestamp: number expected";
            return null;
        };

        /**
         * Creates a Suspend message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetSuspend.Suspend
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetSuspend.Suspend} Suspend
         */
        Suspend.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetSuspend.Suspend)
                return object;
            var message = new $root.Qot_GetSuspend.Suspend();
            if (object.time != null)
                message.time = String(object.time);
            if (object.timestamp != null)
                message.timestamp = Number(object.timestamp);
            return message;
        };

        /**
         * Creates a plain object from a Suspend message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetSuspend.Suspend
         * @static
         * @param {Qot_GetSuspend.Suspend} message Suspend
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Suspend.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.time = "";
                object.timestamp = 0;
            }
            if (message.time != null && message.hasOwnProperty("time"))
                object.time = message.time;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                object.timestamp = options.json && !isFinite(message.timestamp) ? String(message.timestamp) : message.timestamp;
            return object;
        };

        /**
         * Converts this Suspend to JSON.
         * @function toJSON
         * @memberof Qot_GetSuspend.Suspend
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Suspend.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Suspend;
    })();

    Qot_GetSuspend.SecuritySuspend = (function() {

        /**
         * Properties of a SecuritySuspend.
         * @memberof Qot_GetSuspend
         * @interface ISecuritySuspend
         * @property {Qot_Common.ISecurity} security SecuritySuspend security
         * @property {Array.<Qot_GetSuspend.ISuspend>|null} [suspendList] SecuritySuspend suspendList
         */

        /**
         * Constructs a new SecuritySuspend.
         * @memberof Qot_GetSuspend
         * @classdesc Represents a SecuritySuspend.
         * @implements ISecuritySuspend
         * @constructor
         * @param {Qot_GetSuspend.ISecuritySuspend=} [properties] Properties to set
         */
        function SecuritySuspend(properties) {
            this.suspendList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SecuritySuspend security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_GetSuspend.SecuritySuspend
         * @instance
         */
        SecuritySuspend.prototype.security = null;

        /**
         * SecuritySuspend suspendList.
         * @member {Array.<Qot_GetSuspend.ISuspend>} suspendList
         * @memberof Qot_GetSuspend.SecuritySuspend
         * @instance
         */
        SecuritySuspend.prototype.suspendList = $util.emptyArray;

        /**
         * Creates a new SecuritySuspend instance using the specified properties.
         * @function create
         * @memberof Qot_GetSuspend.SecuritySuspend
         * @static
         * @param {Qot_GetSuspend.ISecuritySuspend=} [properties] Properties to set
         * @returns {Qot_GetSuspend.SecuritySuspend} SecuritySuspend instance
         */
        SecuritySuspend.create = function create(properties) {
            return new SecuritySuspend(properties);
        };

        /**
         * Encodes the specified SecuritySuspend message. Does not implicitly {@link Qot_GetSuspend.SecuritySuspend.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetSuspend.SecuritySuspend
         * @static
         * @param {Qot_GetSuspend.ISecuritySuspend} message SecuritySuspend message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SecuritySuspend.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.suspendList != null && message.suspendList.length)
                for (var i = 0; i < message.suspendList.length; ++i)
                    $root.Qot_GetSuspend.Suspend.encode(message.suspendList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SecuritySuspend message, length delimited. Does not implicitly {@link Qot_GetSuspend.SecuritySuspend.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetSuspend.SecuritySuspend
         * @static
         * @param {Qot_GetSuspend.ISecuritySuspend} message SecuritySuspend message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SecuritySuspend.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SecuritySuspend message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetSuspend.SecuritySuspend
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetSuspend.SecuritySuspend} SecuritySuspend
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SecuritySuspend.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetSuspend.SecuritySuspend();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.suspendList && message.suspendList.length))
                        message.suspendList = [];
                    message.suspendList.push($root.Qot_GetSuspend.Suspend.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            return message;
        };

        /**
         * Decodes a SecuritySuspend message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetSuspend.SecuritySuspend
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetSuspend.SecuritySuspend} SecuritySuspend
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SecuritySuspend.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SecuritySuspend message.
         * @function verify
         * @memberof Qot_GetSuspend.SecuritySuspend
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SecuritySuspend.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            if (message.suspendList != null && message.hasOwnProperty("suspendList")) {
                if (!Array.isArray(message.suspendList))
                    return "suspendList: array expected";
                for (var i = 0; i < message.suspendList.length; ++i) {
                    var error = $root.Qot_GetSuspend.Suspend.verify(message.suspendList[i]);
                    if (error)
                        return "suspendList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a SecuritySuspend message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetSuspend.SecuritySuspend
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetSuspend.SecuritySuspend} SecuritySuspend
         */
        SecuritySuspend.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetSuspend.SecuritySuspend)
                return object;
            var message = new $root.Qot_GetSuspend.SecuritySuspend();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_GetSuspend.SecuritySuspend.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            if (object.suspendList) {
                if (!Array.isArray(object.suspendList))
                    throw TypeError(".Qot_GetSuspend.SecuritySuspend.suspendList: array expected");
                message.suspendList = [];
                for (var i = 0; i < object.suspendList.length; ++i) {
                    if (typeof object.suspendList[i] !== "object")
                        throw TypeError(".Qot_GetSuspend.SecuritySuspend.suspendList: object expected");
                    message.suspendList[i] = $root.Qot_GetSuspend.Suspend.fromObject(object.suspendList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a SecuritySuspend message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetSuspend.SecuritySuspend
         * @static
         * @param {Qot_GetSuspend.SecuritySuspend} message SecuritySuspend
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SecuritySuspend.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.suspendList = [];
            if (options.defaults)
                object.security = null;
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            if (message.suspendList && message.suspendList.length) {
                object.suspendList = [];
                for (var j = 0; j < message.suspendList.length; ++j)
                    object.suspendList[j] = $root.Qot_GetSuspend.Suspend.toObject(message.suspendList[j], options);
            }
            return object;
        };

        /**
         * Converts this SecuritySuspend to JSON.
         * @function toJSON
         * @memberof Qot_GetSuspend.SecuritySuspend
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SecuritySuspend.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SecuritySuspend;
    })();

    Qot_GetSuspend.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_GetSuspend
         * @interface IS2C
         * @property {Array.<Qot_GetSuspend.ISecuritySuspend>|null} [SecuritySuspendList] S2C SecuritySuspendList
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_GetSuspend
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_GetSuspend.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.SecuritySuspendList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C SecuritySuspendList.
         * @member {Array.<Qot_GetSuspend.ISecuritySuspend>} SecuritySuspendList
         * @memberof Qot_GetSuspend.S2C
         * @instance
         */
        S2C.prototype.SecuritySuspendList = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_GetSuspend.S2C
         * @static
         * @param {Qot_GetSuspend.IS2C=} [properties] Properties to set
         * @returns {Qot_GetSuspend.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_GetSuspend.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetSuspend.S2C
         * @static
         * @param {Qot_GetSuspend.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.SecuritySuspendList != null && message.SecuritySuspendList.length)
                for (var i = 0; i < message.SecuritySuspendList.length; ++i)
                    $root.Qot_GetSuspend.SecuritySuspend.encode(message.SecuritySuspendList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_GetSuspend.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetSuspend.S2C
         * @static
         * @param {Qot_GetSuspend.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetSuspend.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetSuspend.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetSuspend.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.SecuritySuspendList && message.SecuritySuspendList.length))
                        message.SecuritySuspendList = [];
                    message.SecuritySuspendList.push($root.Qot_GetSuspend.SecuritySuspend.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetSuspend.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetSuspend.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_GetSuspend.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.SecuritySuspendList != null && message.hasOwnProperty("SecuritySuspendList")) {
                if (!Array.isArray(message.SecuritySuspendList))
                    return "SecuritySuspendList: array expected";
                for (var i = 0; i < message.SecuritySuspendList.length; ++i) {
                    var error = $root.Qot_GetSuspend.SecuritySuspend.verify(message.SecuritySuspendList[i]);
                    if (error)
                        return "SecuritySuspendList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetSuspend.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetSuspend.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetSuspend.S2C)
                return object;
            var message = new $root.Qot_GetSuspend.S2C();
            if (object.SecuritySuspendList) {
                if (!Array.isArray(object.SecuritySuspendList))
                    throw TypeError(".Qot_GetSuspend.S2C.SecuritySuspendList: array expected");
                message.SecuritySuspendList = [];
                for (var i = 0; i < object.SecuritySuspendList.length; ++i) {
                    if (typeof object.SecuritySuspendList[i] !== "object")
                        throw TypeError(".Qot_GetSuspend.S2C.SecuritySuspendList: object expected");
                    message.SecuritySuspendList[i] = $root.Qot_GetSuspend.SecuritySuspend.fromObject(object.SecuritySuspendList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetSuspend.S2C
         * @static
         * @param {Qot_GetSuspend.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.SecuritySuspendList = [];
            if (message.SecuritySuspendList && message.SecuritySuspendList.length) {
                object.SecuritySuspendList = [];
                for (var j = 0; j < message.SecuritySuspendList.length; ++j)
                    object.SecuritySuspendList[j] = $root.Qot_GetSuspend.SecuritySuspend.toObject(message.SecuritySuspendList[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_GetSuspend.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_GetSuspend.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Qot_GetSuspend
         * @interface IRequest
         * @property {Qot_GetSuspend.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Qot_GetSuspend
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Qot_GetSuspend.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Qot_GetSuspend.IC2S} c2s
         * @memberof Qot_GetSuspend.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Qot_GetSuspend.Request
         * @static
         * @param {Qot_GetSuspend.IRequest=} [properties] Properties to set
         * @returns {Qot_GetSuspend.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Qot_GetSuspend.Request.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetSuspend.Request
         * @static
         * @param {Qot_GetSuspend.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_GetSuspend.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Qot_GetSuspend.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetSuspend.Request
         * @static
         * @param {Qot_GetSuspend.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetSuspend.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetSuspend.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetSuspend.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Qot_GetSuspend.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetSuspend.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetSuspend.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Qot_GetSuspend.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_GetSuspend.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetSuspend.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetSuspend.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetSuspend.Request)
                return object;
            var message = new $root.Qot_GetSuspend.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Qot_GetSuspend.Request.c2s: object expected");
                message.c2s = $root.Qot_GetSuspend.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetSuspend.Request
         * @static
         * @param {Qot_GetSuspend.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Qot_GetSuspend.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Qot_GetSuspend.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Qot_GetSuspend.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_GetSuspend
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_GetSuspend.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_GetSuspend
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_GetSuspend.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_GetSuspend.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_GetSuspend.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_GetSuspend.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_GetSuspend.IS2C|null|undefined} s2c
         * @memberof Qot_GetSuspend.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_GetSuspend.Response
         * @static
         * @param {Qot_GetSuspend.IResponse=} [properties] Properties to set
         * @returns {Qot_GetSuspend.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_GetSuspend.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetSuspend.Response
         * @static
         * @param {Qot_GetSuspend.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_GetSuspend.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_GetSuspend.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetSuspend.Response
         * @static
         * @param {Qot_GetSuspend.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetSuspend.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetSuspend.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetSuspend.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_GetSuspend.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetSuspend.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetSuspend.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_GetSuspend.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_GetSuspend.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetSuspend.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetSuspend.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetSuspend.Response)
                return object;
            var message = new $root.Qot_GetSuspend.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_GetSuspend.Response.s2c: object expected");
                message.s2c = $root.Qot_GetSuspend.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetSuspend.Response
         * @static
         * @param {Qot_GetSuspend.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_GetSuspend.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_GetSuspend.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_GetSuspend;
})();

$root.Qot_GetTicker = (function() {

    /**
     * Namespace Qot_GetTicker.
     * @exports Qot_GetTicker
     * @namespace
     */
    var Qot_GetTicker = {};

    Qot_GetTicker.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Qot_GetTicker
         * @interface IC2S
         * @property {Qot_Common.ISecurity} security C2S security
         * @property {number} maxRetNum C2S maxRetNum
         */

        /**
         * Constructs a new C2S.
         * @memberof Qot_GetTicker
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Qot_GetTicker.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_GetTicker.C2S
         * @instance
         */
        C2S.prototype.security = null;

        /**
         * C2S maxRetNum.
         * @member {number} maxRetNum
         * @memberof Qot_GetTicker.C2S
         * @instance
         */
        C2S.prototype.maxRetNum = 0;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Qot_GetTicker.C2S
         * @static
         * @param {Qot_GetTicker.IC2S=} [properties] Properties to set
         * @returns {Qot_GetTicker.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Qot_GetTicker.C2S.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetTicker.C2S
         * @static
         * @param {Qot_GetTicker.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.maxRetNum);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Qot_GetTicker.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetTicker.C2S
         * @static
         * @param {Qot_GetTicker.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetTicker.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetTicker.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetTicker.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.maxRetNum = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            if (!message.hasOwnProperty("maxRetNum"))
                throw $util.ProtocolError("missing required 'maxRetNum'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetTicker.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetTicker.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Qot_GetTicker.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            if (!$util.isInteger(message.maxRetNum))
                return "maxRetNum: integer expected";
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetTicker.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetTicker.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetTicker.C2S)
                return object;
            var message = new $root.Qot_GetTicker.C2S();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_GetTicker.C2S.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            if (object.maxRetNum != null)
                message.maxRetNum = object.maxRetNum | 0;
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetTicker.C2S
         * @static
         * @param {Qot_GetTicker.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.security = null;
                object.maxRetNum = 0;
            }
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            if (message.maxRetNum != null && message.hasOwnProperty("maxRetNum"))
                object.maxRetNum = message.maxRetNum;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Qot_GetTicker.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Qot_GetTicker.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_GetTicker
         * @interface IS2C
         * @property {Qot_Common.ISecurity} security S2C security
         * @property {Array.<Qot_Common.ITicker>|null} [tickerList] S2C tickerList
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_GetTicker
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_GetTicker.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.tickerList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_GetTicker.S2C
         * @instance
         */
        S2C.prototype.security = null;

        /**
         * S2C tickerList.
         * @member {Array.<Qot_Common.ITicker>} tickerList
         * @memberof Qot_GetTicker.S2C
         * @instance
         */
        S2C.prototype.tickerList = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_GetTicker.S2C
         * @static
         * @param {Qot_GetTicker.IS2C=} [properties] Properties to set
         * @returns {Qot_GetTicker.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_GetTicker.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetTicker.S2C
         * @static
         * @param {Qot_GetTicker.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.tickerList != null && message.tickerList.length)
                for (var i = 0; i < message.tickerList.length; ++i)
                    $root.Qot_Common.Ticker.encode(message.tickerList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_GetTicker.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetTicker.S2C
         * @static
         * @param {Qot_GetTicker.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetTicker.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetTicker.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetTicker.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.tickerList && message.tickerList.length))
                        message.tickerList = [];
                    message.tickerList.push($root.Qot_Common.Ticker.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetTicker.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetTicker.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_GetTicker.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            if (message.tickerList != null && message.hasOwnProperty("tickerList")) {
                if (!Array.isArray(message.tickerList))
                    return "tickerList: array expected";
                for (var i = 0; i < message.tickerList.length; ++i) {
                    var error = $root.Qot_Common.Ticker.verify(message.tickerList[i]);
                    if (error)
                        return "tickerList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetTicker.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetTicker.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetTicker.S2C)
                return object;
            var message = new $root.Qot_GetTicker.S2C();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_GetTicker.S2C.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            if (object.tickerList) {
                if (!Array.isArray(object.tickerList))
                    throw TypeError(".Qot_GetTicker.S2C.tickerList: array expected");
                message.tickerList = [];
                for (var i = 0; i < object.tickerList.length; ++i) {
                    if (typeof object.tickerList[i] !== "object")
                        throw TypeError(".Qot_GetTicker.S2C.tickerList: object expected");
                    message.tickerList[i] = $root.Qot_Common.Ticker.fromObject(object.tickerList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetTicker.S2C
         * @static
         * @param {Qot_GetTicker.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.tickerList = [];
            if (options.defaults)
                object.security = null;
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            if (message.tickerList && message.tickerList.length) {
                object.tickerList = [];
                for (var j = 0; j < message.tickerList.length; ++j)
                    object.tickerList[j] = $root.Qot_Common.Ticker.toObject(message.tickerList[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_GetTicker.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_GetTicker.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Qot_GetTicker
         * @interface IRequest
         * @property {Qot_GetTicker.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Qot_GetTicker
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Qot_GetTicker.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Qot_GetTicker.IC2S} c2s
         * @memberof Qot_GetTicker.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Qot_GetTicker.Request
         * @static
         * @param {Qot_GetTicker.IRequest=} [properties] Properties to set
         * @returns {Qot_GetTicker.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Qot_GetTicker.Request.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetTicker.Request
         * @static
         * @param {Qot_GetTicker.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_GetTicker.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Qot_GetTicker.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetTicker.Request
         * @static
         * @param {Qot_GetTicker.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetTicker.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetTicker.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetTicker.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Qot_GetTicker.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetTicker.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetTicker.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Qot_GetTicker.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_GetTicker.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetTicker.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetTicker.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetTicker.Request)
                return object;
            var message = new $root.Qot_GetTicker.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Qot_GetTicker.Request.c2s: object expected");
                message.c2s = $root.Qot_GetTicker.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetTicker.Request
         * @static
         * @param {Qot_GetTicker.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Qot_GetTicker.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Qot_GetTicker.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Qot_GetTicker.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_GetTicker
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_GetTicker.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_GetTicker
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_GetTicker.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_GetTicker.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_GetTicker.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_GetTicker.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_GetTicker.IS2C|null|undefined} s2c
         * @memberof Qot_GetTicker.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_GetTicker.Response
         * @static
         * @param {Qot_GetTicker.IResponse=} [properties] Properties to set
         * @returns {Qot_GetTicker.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_GetTicker.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetTicker.Response
         * @static
         * @param {Qot_GetTicker.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_GetTicker.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_GetTicker.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetTicker.Response
         * @static
         * @param {Qot_GetTicker.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetTicker.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetTicker.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetTicker.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_GetTicker.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetTicker.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetTicker.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_GetTicker.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_GetTicker.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetTicker.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetTicker.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetTicker.Response)
                return object;
            var message = new $root.Qot_GetTicker.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_GetTicker.Response.s2c: object expected");
                message.s2c = $root.Qot_GetTicker.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetTicker.Response
         * @static
         * @param {Qot_GetTicker.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_GetTicker.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_GetTicker.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_GetTicker;
})();

$root.Qot_GetTradeDate = (function() {

    /**
     * Namespace Qot_GetTradeDate.
     * @exports Qot_GetTradeDate
     * @namespace
     */
    var Qot_GetTradeDate = {};

    Qot_GetTradeDate.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Qot_GetTradeDate
         * @interface IC2S
         * @property {number} market C2S market
         * @property {string} beginTime C2S beginTime
         * @property {string} endTime C2S endTime
         */

        /**
         * Constructs a new C2S.
         * @memberof Qot_GetTradeDate
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Qot_GetTradeDate.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S market.
         * @member {number} market
         * @memberof Qot_GetTradeDate.C2S
         * @instance
         */
        C2S.prototype.market = 0;

        /**
         * C2S beginTime.
         * @member {string} beginTime
         * @memberof Qot_GetTradeDate.C2S
         * @instance
         */
        C2S.prototype.beginTime = "";

        /**
         * C2S endTime.
         * @member {string} endTime
         * @memberof Qot_GetTradeDate.C2S
         * @instance
         */
        C2S.prototype.endTime = "";

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Qot_GetTradeDate.C2S
         * @static
         * @param {Qot_GetTradeDate.IC2S=} [properties] Properties to set
         * @returns {Qot_GetTradeDate.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Qot_GetTradeDate.C2S.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetTradeDate.C2S
         * @static
         * @param {Qot_GetTradeDate.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.market);
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.beginTime);
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.endTime);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Qot_GetTradeDate.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetTradeDate.C2S
         * @static
         * @param {Qot_GetTradeDate.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetTradeDate.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetTradeDate.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetTradeDate.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.market = reader.int32();
                    break;
                case 2:
                    message.beginTime = reader.string();
                    break;
                case 3:
                    message.endTime = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("market"))
                throw $util.ProtocolError("missing required 'market'", { instance: message });
            if (!message.hasOwnProperty("beginTime"))
                throw $util.ProtocolError("missing required 'beginTime'", { instance: message });
            if (!message.hasOwnProperty("endTime"))
                throw $util.ProtocolError("missing required 'endTime'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetTradeDate.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetTradeDate.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Qot_GetTradeDate.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.market))
                return "market: integer expected";
            if (!$util.isString(message.beginTime))
                return "beginTime: string expected";
            if (!$util.isString(message.endTime))
                return "endTime: string expected";
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetTradeDate.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetTradeDate.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetTradeDate.C2S)
                return object;
            var message = new $root.Qot_GetTradeDate.C2S();
            if (object.market != null)
                message.market = object.market | 0;
            if (object.beginTime != null)
                message.beginTime = String(object.beginTime);
            if (object.endTime != null)
                message.endTime = String(object.endTime);
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetTradeDate.C2S
         * @static
         * @param {Qot_GetTradeDate.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.market = 0;
                object.beginTime = "";
                object.endTime = "";
            }
            if (message.market != null && message.hasOwnProperty("market"))
                object.market = message.market;
            if (message.beginTime != null && message.hasOwnProperty("beginTime"))
                object.beginTime = message.beginTime;
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                object.endTime = message.endTime;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Qot_GetTradeDate.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Qot_GetTradeDate.TradeDate = (function() {

        /**
         * Properties of a TradeDate.
         * @memberof Qot_GetTradeDate
         * @interface ITradeDate
         * @property {string} time TradeDate time
         * @property {number|null} [timestamp] TradeDate timestamp
         * @property {number|null} [tradeDateType] TradeDate tradeDateType
         */

        /**
         * Constructs a new TradeDate.
         * @memberof Qot_GetTradeDate
         * @classdesc Represents a TradeDate.
         * @implements ITradeDate
         * @constructor
         * @param {Qot_GetTradeDate.ITradeDate=} [properties] Properties to set
         */
        function TradeDate(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TradeDate time.
         * @member {string} time
         * @memberof Qot_GetTradeDate.TradeDate
         * @instance
         */
        TradeDate.prototype.time = "";

        /**
         * TradeDate timestamp.
         * @member {number} timestamp
         * @memberof Qot_GetTradeDate.TradeDate
         * @instance
         */
        TradeDate.prototype.timestamp = 0;

        /**
         * TradeDate tradeDateType.
         * @member {number} tradeDateType
         * @memberof Qot_GetTradeDate.TradeDate
         * @instance
         */
        TradeDate.prototype.tradeDateType = 0;

        /**
         * Creates a new TradeDate instance using the specified properties.
         * @function create
         * @memberof Qot_GetTradeDate.TradeDate
         * @static
         * @param {Qot_GetTradeDate.ITradeDate=} [properties] Properties to set
         * @returns {Qot_GetTradeDate.TradeDate} TradeDate instance
         */
        TradeDate.create = function create(properties) {
            return new TradeDate(properties);
        };

        /**
         * Encodes the specified TradeDate message. Does not implicitly {@link Qot_GetTradeDate.TradeDate.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetTradeDate.TradeDate
         * @static
         * @param {Qot_GetTradeDate.ITradeDate} message TradeDate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TradeDate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.time);
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                writer.uint32(/* id 2, wireType 1 =*/17).double(message.timestamp);
            if (message.tradeDateType != null && message.hasOwnProperty("tradeDateType"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.tradeDateType);
            return writer;
        };

        /**
         * Encodes the specified TradeDate message, length delimited. Does not implicitly {@link Qot_GetTradeDate.TradeDate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetTradeDate.TradeDate
         * @static
         * @param {Qot_GetTradeDate.ITradeDate} message TradeDate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TradeDate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TradeDate message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetTradeDate.TradeDate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetTradeDate.TradeDate} TradeDate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TradeDate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetTradeDate.TradeDate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.time = reader.string();
                    break;
                case 2:
                    message.timestamp = reader.double();
                    break;
                case 3:
                    message.tradeDateType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("time"))
                throw $util.ProtocolError("missing required 'time'", { instance: message });
            return message;
        };

        /**
         * Decodes a TradeDate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetTradeDate.TradeDate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetTradeDate.TradeDate} TradeDate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TradeDate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TradeDate message.
         * @function verify
         * @memberof Qot_GetTradeDate.TradeDate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TradeDate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.time))
                return "time: string expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp !== "number")
                    return "timestamp: number expected";
            if (message.tradeDateType != null && message.hasOwnProperty("tradeDateType"))
                if (!$util.isInteger(message.tradeDateType))
                    return "tradeDateType: integer expected";
            return null;
        };

        /**
         * Creates a TradeDate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetTradeDate.TradeDate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetTradeDate.TradeDate} TradeDate
         */
        TradeDate.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetTradeDate.TradeDate)
                return object;
            var message = new $root.Qot_GetTradeDate.TradeDate();
            if (object.time != null)
                message.time = String(object.time);
            if (object.timestamp != null)
                message.timestamp = Number(object.timestamp);
            if (object.tradeDateType != null)
                message.tradeDateType = object.tradeDateType | 0;
            return message;
        };

        /**
         * Creates a plain object from a TradeDate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetTradeDate.TradeDate
         * @static
         * @param {Qot_GetTradeDate.TradeDate} message TradeDate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TradeDate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.time = "";
                object.timestamp = 0;
                object.tradeDateType = 0;
            }
            if (message.time != null && message.hasOwnProperty("time"))
                object.time = message.time;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                object.timestamp = options.json && !isFinite(message.timestamp) ? String(message.timestamp) : message.timestamp;
            if (message.tradeDateType != null && message.hasOwnProperty("tradeDateType"))
                object.tradeDateType = message.tradeDateType;
            return object;
        };

        /**
         * Converts this TradeDate to JSON.
         * @function toJSON
         * @memberof Qot_GetTradeDate.TradeDate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TradeDate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TradeDate;
    })();

    Qot_GetTradeDate.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_GetTradeDate
         * @interface IS2C
         * @property {Array.<Qot_GetTradeDate.ITradeDate>|null} [tradeDateList] S2C tradeDateList
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_GetTradeDate
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_GetTradeDate.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.tradeDateList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C tradeDateList.
         * @member {Array.<Qot_GetTradeDate.ITradeDate>} tradeDateList
         * @memberof Qot_GetTradeDate.S2C
         * @instance
         */
        S2C.prototype.tradeDateList = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_GetTradeDate.S2C
         * @static
         * @param {Qot_GetTradeDate.IS2C=} [properties] Properties to set
         * @returns {Qot_GetTradeDate.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_GetTradeDate.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetTradeDate.S2C
         * @static
         * @param {Qot_GetTradeDate.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tradeDateList != null && message.tradeDateList.length)
                for (var i = 0; i < message.tradeDateList.length; ++i)
                    $root.Qot_GetTradeDate.TradeDate.encode(message.tradeDateList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_GetTradeDate.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetTradeDate.S2C
         * @static
         * @param {Qot_GetTradeDate.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetTradeDate.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetTradeDate.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetTradeDate.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.tradeDateList && message.tradeDateList.length))
                        message.tradeDateList = [];
                    message.tradeDateList.push($root.Qot_GetTradeDate.TradeDate.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetTradeDate.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetTradeDate.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_GetTradeDate.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tradeDateList != null && message.hasOwnProperty("tradeDateList")) {
                if (!Array.isArray(message.tradeDateList))
                    return "tradeDateList: array expected";
                for (var i = 0; i < message.tradeDateList.length; ++i) {
                    var error = $root.Qot_GetTradeDate.TradeDate.verify(message.tradeDateList[i]);
                    if (error)
                        return "tradeDateList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetTradeDate.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetTradeDate.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetTradeDate.S2C)
                return object;
            var message = new $root.Qot_GetTradeDate.S2C();
            if (object.tradeDateList) {
                if (!Array.isArray(object.tradeDateList))
                    throw TypeError(".Qot_GetTradeDate.S2C.tradeDateList: array expected");
                message.tradeDateList = [];
                for (var i = 0; i < object.tradeDateList.length; ++i) {
                    if (typeof object.tradeDateList[i] !== "object")
                        throw TypeError(".Qot_GetTradeDate.S2C.tradeDateList: object expected");
                    message.tradeDateList[i] = $root.Qot_GetTradeDate.TradeDate.fromObject(object.tradeDateList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetTradeDate.S2C
         * @static
         * @param {Qot_GetTradeDate.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.tradeDateList = [];
            if (message.tradeDateList && message.tradeDateList.length) {
                object.tradeDateList = [];
                for (var j = 0; j < message.tradeDateList.length; ++j)
                    object.tradeDateList[j] = $root.Qot_GetTradeDate.TradeDate.toObject(message.tradeDateList[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_GetTradeDate.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_GetTradeDate.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Qot_GetTradeDate
         * @interface IRequest
         * @property {Qot_GetTradeDate.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Qot_GetTradeDate
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Qot_GetTradeDate.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Qot_GetTradeDate.IC2S} c2s
         * @memberof Qot_GetTradeDate.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Qot_GetTradeDate.Request
         * @static
         * @param {Qot_GetTradeDate.IRequest=} [properties] Properties to set
         * @returns {Qot_GetTradeDate.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Qot_GetTradeDate.Request.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetTradeDate.Request
         * @static
         * @param {Qot_GetTradeDate.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_GetTradeDate.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Qot_GetTradeDate.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetTradeDate.Request
         * @static
         * @param {Qot_GetTradeDate.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetTradeDate.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetTradeDate.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetTradeDate.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Qot_GetTradeDate.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetTradeDate.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetTradeDate.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Qot_GetTradeDate.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_GetTradeDate.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetTradeDate.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetTradeDate.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetTradeDate.Request)
                return object;
            var message = new $root.Qot_GetTradeDate.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Qot_GetTradeDate.Request.c2s: object expected");
                message.c2s = $root.Qot_GetTradeDate.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetTradeDate.Request
         * @static
         * @param {Qot_GetTradeDate.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Qot_GetTradeDate.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Qot_GetTradeDate.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Qot_GetTradeDate.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_GetTradeDate
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_GetTradeDate.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_GetTradeDate
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_GetTradeDate.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_GetTradeDate.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_GetTradeDate.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_GetTradeDate.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_GetTradeDate.IS2C|null|undefined} s2c
         * @memberof Qot_GetTradeDate.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_GetTradeDate.Response
         * @static
         * @param {Qot_GetTradeDate.IResponse=} [properties] Properties to set
         * @returns {Qot_GetTradeDate.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_GetTradeDate.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetTradeDate.Response
         * @static
         * @param {Qot_GetTradeDate.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_GetTradeDate.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_GetTradeDate.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetTradeDate.Response
         * @static
         * @param {Qot_GetTradeDate.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetTradeDate.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetTradeDate.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetTradeDate.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_GetTradeDate.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetTradeDate.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetTradeDate.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_GetTradeDate.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_GetTradeDate.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetTradeDate.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetTradeDate.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetTradeDate.Response)
                return object;
            var message = new $root.Qot_GetTradeDate.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_GetTradeDate.Response.s2c: object expected");
                message.s2c = $root.Qot_GetTradeDate.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetTradeDate.Response
         * @static
         * @param {Qot_GetTradeDate.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_GetTradeDate.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_GetTradeDate.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_GetTradeDate;
})();

$root.Qot_GetWarrant = (function() {

    /**
     * Namespace Qot_GetWarrant.
     * @exports Qot_GetWarrant
     * @namespace
     */
    var Qot_GetWarrant = {};

    Qot_GetWarrant.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Qot_GetWarrant
         * @interface IC2S
         * @property {number} begin C2S begin
         * @property {number} num C2S num
         * @property {number} sortField C2S sortField
         * @property {boolean} ascend C2S ascend
         * @property {Qot_Common.ISecurity|null} [owner] C2S owner
         * @property {Array.<number>|null} [typeList] C2S typeList
         * @property {Array.<number>|null} [issuerList] C2S issuerList
         * @property {string|null} [maturityTimeMin] C2S maturityTimeMin
         * @property {string|null} [maturityTimeMax] C2S maturityTimeMax
         * @property {number|null} [ipoPeriod] C2S ipoPeriod
         * @property {number|null} [priceType] C2S priceType
         * @property {number|null} [status] C2S status
         * @property {number|null} [curPriceMin] C2S curPriceMin
         * @property {number|null} [curPriceMax] C2S curPriceMax
         * @property {number|null} [strikePriceMin] C2S strikePriceMin
         * @property {number|null} [strikePriceMax] C2S strikePriceMax
         * @property {number|null} [streetMin] C2S streetMin
         * @property {number|null} [streetMax] C2S streetMax
         * @property {number|null} [conversionMin] C2S conversionMin
         * @property {number|null} [conversionMax] C2S conversionMax
         * @property {number|Long|null} [volMin] C2S volMin
         * @property {number|Long|null} [volMax] C2S volMax
         * @property {number|null} [premiumMin] C2S premiumMin
         * @property {number|null} [premiumMax] C2S premiumMax
         * @property {number|null} [leverageRatioMin] C2S leverageRatioMin
         * @property {number|null} [leverageRatioMax] C2S leverageRatioMax
         * @property {number|null} [deltaMin] C2S deltaMin
         * @property {number|null} [deltaMax] C2S deltaMax
         * @property {number|null} [impliedMin] C2S impliedMin
         * @property {number|null} [impliedMax] C2S impliedMax
         * @property {number|null} [recoveryPriceMin] C2S recoveryPriceMin
         * @property {number|null} [recoveryPriceMax] C2S recoveryPriceMax
         * @property {number|null} [priceRecoveryRatioMin] C2S priceRecoveryRatioMin
         * @property {number|null} [priceRecoveryRatioMax] C2S priceRecoveryRatioMax
         */

        /**
         * Constructs a new C2S.
         * @memberof Qot_GetWarrant
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Qot_GetWarrant.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            this.typeList = [];
            this.issuerList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S begin.
         * @member {number} begin
         * @memberof Qot_GetWarrant.C2S
         * @instance
         */
        C2S.prototype.begin = 0;

        /**
         * C2S num.
         * @member {number} num
         * @memberof Qot_GetWarrant.C2S
         * @instance
         */
        C2S.prototype.num = 0;

        /**
         * C2S sortField.
         * @member {number} sortField
         * @memberof Qot_GetWarrant.C2S
         * @instance
         */
        C2S.prototype.sortField = 0;

        /**
         * C2S ascend.
         * @member {boolean} ascend
         * @memberof Qot_GetWarrant.C2S
         * @instance
         */
        C2S.prototype.ascend = false;

        /**
         * C2S owner.
         * @member {Qot_Common.ISecurity|null|undefined} owner
         * @memberof Qot_GetWarrant.C2S
         * @instance
         */
        C2S.prototype.owner = null;

        /**
         * C2S typeList.
         * @member {Array.<number>} typeList
         * @memberof Qot_GetWarrant.C2S
         * @instance
         */
        C2S.prototype.typeList = $util.emptyArray;

        /**
         * C2S issuerList.
         * @member {Array.<number>} issuerList
         * @memberof Qot_GetWarrant.C2S
         * @instance
         */
        C2S.prototype.issuerList = $util.emptyArray;

        /**
         * C2S maturityTimeMin.
         * @member {string} maturityTimeMin
         * @memberof Qot_GetWarrant.C2S
         * @instance
         */
        C2S.prototype.maturityTimeMin = "";

        /**
         * C2S maturityTimeMax.
         * @member {string} maturityTimeMax
         * @memberof Qot_GetWarrant.C2S
         * @instance
         */
        C2S.prototype.maturityTimeMax = "";

        /**
         * C2S ipoPeriod.
         * @member {number} ipoPeriod
         * @memberof Qot_GetWarrant.C2S
         * @instance
         */
        C2S.prototype.ipoPeriod = 0;

        /**
         * C2S priceType.
         * @member {number} priceType
         * @memberof Qot_GetWarrant.C2S
         * @instance
         */
        C2S.prototype.priceType = 0;

        /**
         * C2S status.
         * @member {number} status
         * @memberof Qot_GetWarrant.C2S
         * @instance
         */
        C2S.prototype.status = 0;

        /**
         * C2S curPriceMin.
         * @member {number} curPriceMin
         * @memberof Qot_GetWarrant.C2S
         * @instance
         */
        C2S.prototype.curPriceMin = 0;

        /**
         * C2S curPriceMax.
         * @member {number} curPriceMax
         * @memberof Qot_GetWarrant.C2S
         * @instance
         */
        C2S.prototype.curPriceMax = 0;

        /**
         * C2S strikePriceMin.
         * @member {number} strikePriceMin
         * @memberof Qot_GetWarrant.C2S
         * @instance
         */
        C2S.prototype.strikePriceMin = 0;

        /**
         * C2S strikePriceMax.
         * @member {number} strikePriceMax
         * @memberof Qot_GetWarrant.C2S
         * @instance
         */
        C2S.prototype.strikePriceMax = 0;

        /**
         * C2S streetMin.
         * @member {number} streetMin
         * @memberof Qot_GetWarrant.C2S
         * @instance
         */
        C2S.prototype.streetMin = 0;

        /**
         * C2S streetMax.
         * @member {number} streetMax
         * @memberof Qot_GetWarrant.C2S
         * @instance
         */
        C2S.prototype.streetMax = 0;

        /**
         * C2S conversionMin.
         * @member {number} conversionMin
         * @memberof Qot_GetWarrant.C2S
         * @instance
         */
        C2S.prototype.conversionMin = 0;

        /**
         * C2S conversionMax.
         * @member {number} conversionMax
         * @memberof Qot_GetWarrant.C2S
         * @instance
         */
        C2S.prototype.conversionMax = 0;

        /**
         * C2S volMin.
         * @member {number|Long} volMin
         * @memberof Qot_GetWarrant.C2S
         * @instance
         */
        C2S.prototype.volMin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * C2S volMax.
         * @member {number|Long} volMax
         * @memberof Qot_GetWarrant.C2S
         * @instance
         */
        C2S.prototype.volMax = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * C2S premiumMin.
         * @member {number} premiumMin
         * @memberof Qot_GetWarrant.C2S
         * @instance
         */
        C2S.prototype.premiumMin = 0;

        /**
         * C2S premiumMax.
         * @member {number} premiumMax
         * @memberof Qot_GetWarrant.C2S
         * @instance
         */
        C2S.prototype.premiumMax = 0;

        /**
         * C2S leverageRatioMin.
         * @member {number} leverageRatioMin
         * @memberof Qot_GetWarrant.C2S
         * @instance
         */
        C2S.prototype.leverageRatioMin = 0;

        /**
         * C2S leverageRatioMax.
         * @member {number} leverageRatioMax
         * @memberof Qot_GetWarrant.C2S
         * @instance
         */
        C2S.prototype.leverageRatioMax = 0;

        /**
         * C2S deltaMin.
         * @member {number} deltaMin
         * @memberof Qot_GetWarrant.C2S
         * @instance
         */
        C2S.prototype.deltaMin = 0;

        /**
         * C2S deltaMax.
         * @member {number} deltaMax
         * @memberof Qot_GetWarrant.C2S
         * @instance
         */
        C2S.prototype.deltaMax = 0;

        /**
         * C2S impliedMin.
         * @member {number} impliedMin
         * @memberof Qot_GetWarrant.C2S
         * @instance
         */
        C2S.prototype.impliedMin = 0;

        /**
         * C2S impliedMax.
         * @member {number} impliedMax
         * @memberof Qot_GetWarrant.C2S
         * @instance
         */
        C2S.prototype.impliedMax = 0;

        /**
         * C2S recoveryPriceMin.
         * @member {number} recoveryPriceMin
         * @memberof Qot_GetWarrant.C2S
         * @instance
         */
        C2S.prototype.recoveryPriceMin = 0;

        /**
         * C2S recoveryPriceMax.
         * @member {number} recoveryPriceMax
         * @memberof Qot_GetWarrant.C2S
         * @instance
         */
        C2S.prototype.recoveryPriceMax = 0;

        /**
         * C2S priceRecoveryRatioMin.
         * @member {number} priceRecoveryRatioMin
         * @memberof Qot_GetWarrant.C2S
         * @instance
         */
        C2S.prototype.priceRecoveryRatioMin = 0;

        /**
         * C2S priceRecoveryRatioMax.
         * @member {number} priceRecoveryRatioMax
         * @memberof Qot_GetWarrant.C2S
         * @instance
         */
        C2S.prototype.priceRecoveryRatioMax = 0;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Qot_GetWarrant.C2S
         * @static
         * @param {Qot_GetWarrant.IC2S=} [properties] Properties to set
         * @returns {Qot_GetWarrant.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Qot_GetWarrant.C2S.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetWarrant.C2S
         * @static
         * @param {Qot_GetWarrant.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.begin);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.num);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.sortField);
            writer.uint32(/* id 4, wireType 0 =*/32).bool(message.ascend);
            if (message.owner != null && message.hasOwnProperty("owner"))
                $root.Qot_Common.Security.encode(message.owner, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.typeList != null && message.typeList.length)
                for (var i = 0; i < message.typeList.length; ++i)
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.typeList[i]);
            if (message.issuerList != null && message.issuerList.length)
                for (var i = 0; i < message.issuerList.length; ++i)
                    writer.uint32(/* id 7, wireType 0 =*/56).int32(message.issuerList[i]);
            if (message.maturityTimeMin != null && message.hasOwnProperty("maturityTimeMin"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.maturityTimeMin);
            if (message.maturityTimeMax != null && message.hasOwnProperty("maturityTimeMax"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.maturityTimeMax);
            if (message.ipoPeriod != null && message.hasOwnProperty("ipoPeriod"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.ipoPeriod);
            if (message.priceType != null && message.hasOwnProperty("priceType"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.priceType);
            if (message.status != null && message.hasOwnProperty("status"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.status);
            if (message.curPriceMin != null && message.hasOwnProperty("curPriceMin"))
                writer.uint32(/* id 13, wireType 1 =*/105).double(message.curPriceMin);
            if (message.curPriceMax != null && message.hasOwnProperty("curPriceMax"))
                writer.uint32(/* id 14, wireType 1 =*/113).double(message.curPriceMax);
            if (message.strikePriceMin != null && message.hasOwnProperty("strikePriceMin"))
                writer.uint32(/* id 15, wireType 1 =*/121).double(message.strikePriceMin);
            if (message.strikePriceMax != null && message.hasOwnProperty("strikePriceMax"))
                writer.uint32(/* id 16, wireType 1 =*/129).double(message.strikePriceMax);
            if (message.streetMin != null && message.hasOwnProperty("streetMin"))
                writer.uint32(/* id 17, wireType 1 =*/137).double(message.streetMin);
            if (message.streetMax != null && message.hasOwnProperty("streetMax"))
                writer.uint32(/* id 18, wireType 1 =*/145).double(message.streetMax);
            if (message.conversionMin != null && message.hasOwnProperty("conversionMin"))
                writer.uint32(/* id 19, wireType 1 =*/153).double(message.conversionMin);
            if (message.conversionMax != null && message.hasOwnProperty("conversionMax"))
                writer.uint32(/* id 20, wireType 1 =*/161).double(message.conversionMax);
            if (message.volMin != null && message.hasOwnProperty("volMin"))
                writer.uint32(/* id 21, wireType 0 =*/168).uint64(message.volMin);
            if (message.volMax != null && message.hasOwnProperty("volMax"))
                writer.uint32(/* id 22, wireType 0 =*/176).uint64(message.volMax);
            if (message.premiumMin != null && message.hasOwnProperty("premiumMin"))
                writer.uint32(/* id 23, wireType 1 =*/185).double(message.premiumMin);
            if (message.premiumMax != null && message.hasOwnProperty("premiumMax"))
                writer.uint32(/* id 24, wireType 1 =*/193).double(message.premiumMax);
            if (message.leverageRatioMin != null && message.hasOwnProperty("leverageRatioMin"))
                writer.uint32(/* id 25, wireType 1 =*/201).double(message.leverageRatioMin);
            if (message.leverageRatioMax != null && message.hasOwnProperty("leverageRatioMax"))
                writer.uint32(/* id 26, wireType 1 =*/209).double(message.leverageRatioMax);
            if (message.deltaMin != null && message.hasOwnProperty("deltaMin"))
                writer.uint32(/* id 27, wireType 1 =*/217).double(message.deltaMin);
            if (message.deltaMax != null && message.hasOwnProperty("deltaMax"))
                writer.uint32(/* id 28, wireType 1 =*/225).double(message.deltaMax);
            if (message.impliedMin != null && message.hasOwnProperty("impliedMin"))
                writer.uint32(/* id 29, wireType 1 =*/233).double(message.impliedMin);
            if (message.impliedMax != null && message.hasOwnProperty("impliedMax"))
                writer.uint32(/* id 30, wireType 1 =*/241).double(message.impliedMax);
            if (message.recoveryPriceMin != null && message.hasOwnProperty("recoveryPriceMin"))
                writer.uint32(/* id 31, wireType 1 =*/249).double(message.recoveryPriceMin);
            if (message.recoveryPriceMax != null && message.hasOwnProperty("recoveryPriceMax"))
                writer.uint32(/* id 32, wireType 1 =*/257).double(message.recoveryPriceMax);
            if (message.priceRecoveryRatioMin != null && message.hasOwnProperty("priceRecoveryRatioMin"))
                writer.uint32(/* id 33, wireType 1 =*/265).double(message.priceRecoveryRatioMin);
            if (message.priceRecoveryRatioMax != null && message.hasOwnProperty("priceRecoveryRatioMax"))
                writer.uint32(/* id 34, wireType 1 =*/273).double(message.priceRecoveryRatioMax);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Qot_GetWarrant.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetWarrant.C2S
         * @static
         * @param {Qot_GetWarrant.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetWarrant.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetWarrant.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetWarrant.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.begin = reader.int32();
                    break;
                case 2:
                    message.num = reader.int32();
                    break;
                case 3:
                    message.sortField = reader.int32();
                    break;
                case 4:
                    message.ascend = reader.bool();
                    break;
                case 5:
                    message.owner = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 6:
                    if (!(message.typeList && message.typeList.length))
                        message.typeList = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.typeList.push(reader.int32());
                    } else
                        message.typeList.push(reader.int32());
                    break;
                case 7:
                    if (!(message.issuerList && message.issuerList.length))
                        message.issuerList = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.issuerList.push(reader.int32());
                    } else
                        message.issuerList.push(reader.int32());
                    break;
                case 8:
                    message.maturityTimeMin = reader.string();
                    break;
                case 9:
                    message.maturityTimeMax = reader.string();
                    break;
                case 10:
                    message.ipoPeriod = reader.int32();
                    break;
                case 11:
                    message.priceType = reader.int32();
                    break;
                case 12:
                    message.status = reader.int32();
                    break;
                case 13:
                    message.curPriceMin = reader.double();
                    break;
                case 14:
                    message.curPriceMax = reader.double();
                    break;
                case 15:
                    message.strikePriceMin = reader.double();
                    break;
                case 16:
                    message.strikePriceMax = reader.double();
                    break;
                case 17:
                    message.streetMin = reader.double();
                    break;
                case 18:
                    message.streetMax = reader.double();
                    break;
                case 19:
                    message.conversionMin = reader.double();
                    break;
                case 20:
                    message.conversionMax = reader.double();
                    break;
                case 21:
                    message.volMin = reader.uint64();
                    break;
                case 22:
                    message.volMax = reader.uint64();
                    break;
                case 23:
                    message.premiumMin = reader.double();
                    break;
                case 24:
                    message.premiumMax = reader.double();
                    break;
                case 25:
                    message.leverageRatioMin = reader.double();
                    break;
                case 26:
                    message.leverageRatioMax = reader.double();
                    break;
                case 27:
                    message.deltaMin = reader.double();
                    break;
                case 28:
                    message.deltaMax = reader.double();
                    break;
                case 29:
                    message.impliedMin = reader.double();
                    break;
                case 30:
                    message.impliedMax = reader.double();
                    break;
                case 31:
                    message.recoveryPriceMin = reader.double();
                    break;
                case 32:
                    message.recoveryPriceMax = reader.double();
                    break;
                case 33:
                    message.priceRecoveryRatioMin = reader.double();
                    break;
                case 34:
                    message.priceRecoveryRatioMax = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("begin"))
                throw $util.ProtocolError("missing required 'begin'", { instance: message });
            if (!message.hasOwnProperty("num"))
                throw $util.ProtocolError("missing required 'num'", { instance: message });
            if (!message.hasOwnProperty("sortField"))
                throw $util.ProtocolError("missing required 'sortField'", { instance: message });
            if (!message.hasOwnProperty("ascend"))
                throw $util.ProtocolError("missing required 'ascend'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetWarrant.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetWarrant.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Qot_GetWarrant.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.begin))
                return "begin: integer expected";
            if (!$util.isInteger(message.num))
                return "num: integer expected";
            if (!$util.isInteger(message.sortField))
                return "sortField: integer expected";
            if (typeof message.ascend !== "boolean")
                return "ascend: boolean expected";
            if (message.owner != null && message.hasOwnProperty("owner")) {
                var error = $root.Qot_Common.Security.verify(message.owner);
                if (error)
                    return "owner." + error;
            }
            if (message.typeList != null && message.hasOwnProperty("typeList")) {
                if (!Array.isArray(message.typeList))
                    return "typeList: array expected";
                for (var i = 0; i < message.typeList.length; ++i)
                    if (!$util.isInteger(message.typeList[i]))
                        return "typeList: integer[] expected";
            }
            if (message.issuerList != null && message.hasOwnProperty("issuerList")) {
                if (!Array.isArray(message.issuerList))
                    return "issuerList: array expected";
                for (var i = 0; i < message.issuerList.length; ++i)
                    if (!$util.isInteger(message.issuerList[i]))
                        return "issuerList: integer[] expected";
            }
            if (message.maturityTimeMin != null && message.hasOwnProperty("maturityTimeMin"))
                if (!$util.isString(message.maturityTimeMin))
                    return "maturityTimeMin: string expected";
            if (message.maturityTimeMax != null && message.hasOwnProperty("maturityTimeMax"))
                if (!$util.isString(message.maturityTimeMax))
                    return "maturityTimeMax: string expected";
            if (message.ipoPeriod != null && message.hasOwnProperty("ipoPeriod"))
                if (!$util.isInteger(message.ipoPeriod))
                    return "ipoPeriod: integer expected";
            if (message.priceType != null && message.hasOwnProperty("priceType"))
                if (!$util.isInteger(message.priceType))
                    return "priceType: integer expected";
            if (message.status != null && message.hasOwnProperty("status"))
                if (!$util.isInteger(message.status))
                    return "status: integer expected";
            if (message.curPriceMin != null && message.hasOwnProperty("curPriceMin"))
                if (typeof message.curPriceMin !== "number")
                    return "curPriceMin: number expected";
            if (message.curPriceMax != null && message.hasOwnProperty("curPriceMax"))
                if (typeof message.curPriceMax !== "number")
                    return "curPriceMax: number expected";
            if (message.strikePriceMin != null && message.hasOwnProperty("strikePriceMin"))
                if (typeof message.strikePriceMin !== "number")
                    return "strikePriceMin: number expected";
            if (message.strikePriceMax != null && message.hasOwnProperty("strikePriceMax"))
                if (typeof message.strikePriceMax !== "number")
                    return "strikePriceMax: number expected";
            if (message.streetMin != null && message.hasOwnProperty("streetMin"))
                if (typeof message.streetMin !== "number")
                    return "streetMin: number expected";
            if (message.streetMax != null && message.hasOwnProperty("streetMax"))
                if (typeof message.streetMax !== "number")
                    return "streetMax: number expected";
            if (message.conversionMin != null && message.hasOwnProperty("conversionMin"))
                if (typeof message.conversionMin !== "number")
                    return "conversionMin: number expected";
            if (message.conversionMax != null && message.hasOwnProperty("conversionMax"))
                if (typeof message.conversionMax !== "number")
                    return "conversionMax: number expected";
            if (message.volMin != null && message.hasOwnProperty("volMin"))
                if (!$util.isInteger(message.volMin) && !(message.volMin && $util.isInteger(message.volMin.low) && $util.isInteger(message.volMin.high)))
                    return "volMin: integer|Long expected";
            if (message.volMax != null && message.hasOwnProperty("volMax"))
                if (!$util.isInteger(message.volMax) && !(message.volMax && $util.isInteger(message.volMax.low) && $util.isInteger(message.volMax.high)))
                    return "volMax: integer|Long expected";
            if (message.premiumMin != null && message.hasOwnProperty("premiumMin"))
                if (typeof message.premiumMin !== "number")
                    return "premiumMin: number expected";
            if (message.premiumMax != null && message.hasOwnProperty("premiumMax"))
                if (typeof message.premiumMax !== "number")
                    return "premiumMax: number expected";
            if (message.leverageRatioMin != null && message.hasOwnProperty("leverageRatioMin"))
                if (typeof message.leverageRatioMin !== "number")
                    return "leverageRatioMin: number expected";
            if (message.leverageRatioMax != null && message.hasOwnProperty("leverageRatioMax"))
                if (typeof message.leverageRatioMax !== "number")
                    return "leverageRatioMax: number expected";
            if (message.deltaMin != null && message.hasOwnProperty("deltaMin"))
                if (typeof message.deltaMin !== "number")
                    return "deltaMin: number expected";
            if (message.deltaMax != null && message.hasOwnProperty("deltaMax"))
                if (typeof message.deltaMax !== "number")
                    return "deltaMax: number expected";
            if (message.impliedMin != null && message.hasOwnProperty("impliedMin"))
                if (typeof message.impliedMin !== "number")
                    return "impliedMin: number expected";
            if (message.impliedMax != null && message.hasOwnProperty("impliedMax"))
                if (typeof message.impliedMax !== "number")
                    return "impliedMax: number expected";
            if (message.recoveryPriceMin != null && message.hasOwnProperty("recoveryPriceMin"))
                if (typeof message.recoveryPriceMin !== "number")
                    return "recoveryPriceMin: number expected";
            if (message.recoveryPriceMax != null && message.hasOwnProperty("recoveryPriceMax"))
                if (typeof message.recoveryPriceMax !== "number")
                    return "recoveryPriceMax: number expected";
            if (message.priceRecoveryRatioMin != null && message.hasOwnProperty("priceRecoveryRatioMin"))
                if (typeof message.priceRecoveryRatioMin !== "number")
                    return "priceRecoveryRatioMin: number expected";
            if (message.priceRecoveryRatioMax != null && message.hasOwnProperty("priceRecoveryRatioMax"))
                if (typeof message.priceRecoveryRatioMax !== "number")
                    return "priceRecoveryRatioMax: number expected";
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetWarrant.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetWarrant.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetWarrant.C2S)
                return object;
            var message = new $root.Qot_GetWarrant.C2S();
            if (object.begin != null)
                message.begin = object.begin | 0;
            if (object.num != null)
                message.num = object.num | 0;
            if (object.sortField != null)
                message.sortField = object.sortField | 0;
            if (object.ascend != null)
                message.ascend = Boolean(object.ascend);
            if (object.owner != null) {
                if (typeof object.owner !== "object")
                    throw TypeError(".Qot_GetWarrant.C2S.owner: object expected");
                message.owner = $root.Qot_Common.Security.fromObject(object.owner);
            }
            if (object.typeList) {
                if (!Array.isArray(object.typeList))
                    throw TypeError(".Qot_GetWarrant.C2S.typeList: array expected");
                message.typeList = [];
                for (var i = 0; i < object.typeList.length; ++i)
                    message.typeList[i] = object.typeList[i] | 0;
            }
            if (object.issuerList) {
                if (!Array.isArray(object.issuerList))
                    throw TypeError(".Qot_GetWarrant.C2S.issuerList: array expected");
                message.issuerList = [];
                for (var i = 0; i < object.issuerList.length; ++i)
                    message.issuerList[i] = object.issuerList[i] | 0;
            }
            if (object.maturityTimeMin != null)
                message.maturityTimeMin = String(object.maturityTimeMin);
            if (object.maturityTimeMax != null)
                message.maturityTimeMax = String(object.maturityTimeMax);
            if (object.ipoPeriod != null)
                message.ipoPeriod = object.ipoPeriod | 0;
            if (object.priceType != null)
                message.priceType = object.priceType | 0;
            if (object.status != null)
                message.status = object.status | 0;
            if (object.curPriceMin != null)
                message.curPriceMin = Number(object.curPriceMin);
            if (object.curPriceMax != null)
                message.curPriceMax = Number(object.curPriceMax);
            if (object.strikePriceMin != null)
                message.strikePriceMin = Number(object.strikePriceMin);
            if (object.strikePriceMax != null)
                message.strikePriceMax = Number(object.strikePriceMax);
            if (object.streetMin != null)
                message.streetMin = Number(object.streetMin);
            if (object.streetMax != null)
                message.streetMax = Number(object.streetMax);
            if (object.conversionMin != null)
                message.conversionMin = Number(object.conversionMin);
            if (object.conversionMax != null)
                message.conversionMax = Number(object.conversionMax);
            if (object.volMin != null)
                if ($util.Long)
                    (message.volMin = $util.Long.fromValue(object.volMin)).unsigned = true;
                else if (typeof object.volMin === "string")
                    message.volMin = parseInt(object.volMin, 10);
                else if (typeof object.volMin === "number")
                    message.volMin = object.volMin;
                else if (typeof object.volMin === "object")
                    message.volMin = new $util.LongBits(object.volMin.low >>> 0, object.volMin.high >>> 0).toNumber(true);
            if (object.volMax != null)
                if ($util.Long)
                    (message.volMax = $util.Long.fromValue(object.volMax)).unsigned = true;
                else if (typeof object.volMax === "string")
                    message.volMax = parseInt(object.volMax, 10);
                else if (typeof object.volMax === "number")
                    message.volMax = object.volMax;
                else if (typeof object.volMax === "object")
                    message.volMax = new $util.LongBits(object.volMax.low >>> 0, object.volMax.high >>> 0).toNumber(true);
            if (object.premiumMin != null)
                message.premiumMin = Number(object.premiumMin);
            if (object.premiumMax != null)
                message.premiumMax = Number(object.premiumMax);
            if (object.leverageRatioMin != null)
                message.leverageRatioMin = Number(object.leverageRatioMin);
            if (object.leverageRatioMax != null)
                message.leverageRatioMax = Number(object.leverageRatioMax);
            if (object.deltaMin != null)
                message.deltaMin = Number(object.deltaMin);
            if (object.deltaMax != null)
                message.deltaMax = Number(object.deltaMax);
            if (object.impliedMin != null)
                message.impliedMin = Number(object.impliedMin);
            if (object.impliedMax != null)
                message.impliedMax = Number(object.impliedMax);
            if (object.recoveryPriceMin != null)
                message.recoveryPriceMin = Number(object.recoveryPriceMin);
            if (object.recoveryPriceMax != null)
                message.recoveryPriceMax = Number(object.recoveryPriceMax);
            if (object.priceRecoveryRatioMin != null)
                message.priceRecoveryRatioMin = Number(object.priceRecoveryRatioMin);
            if (object.priceRecoveryRatioMax != null)
                message.priceRecoveryRatioMax = Number(object.priceRecoveryRatioMax);
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetWarrant.C2S
         * @static
         * @param {Qot_GetWarrant.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.typeList = [];
                object.issuerList = [];
            }
            if (options.defaults) {
                object.begin = 0;
                object.num = 0;
                object.sortField = 0;
                object.ascend = false;
                object.owner = null;
                object.maturityTimeMin = "";
                object.maturityTimeMax = "";
                object.ipoPeriod = 0;
                object.priceType = 0;
                object.status = 0;
                object.curPriceMin = 0;
                object.curPriceMax = 0;
                object.strikePriceMin = 0;
                object.strikePriceMax = 0;
                object.streetMin = 0;
                object.streetMax = 0;
                object.conversionMin = 0;
                object.conversionMax = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.volMin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.volMin = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.volMax = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.volMax = options.longs === String ? "0" : 0;
                object.premiumMin = 0;
                object.premiumMax = 0;
                object.leverageRatioMin = 0;
                object.leverageRatioMax = 0;
                object.deltaMin = 0;
                object.deltaMax = 0;
                object.impliedMin = 0;
                object.impliedMax = 0;
                object.recoveryPriceMin = 0;
                object.recoveryPriceMax = 0;
                object.priceRecoveryRatioMin = 0;
                object.priceRecoveryRatioMax = 0;
            }
            if (message.begin != null && message.hasOwnProperty("begin"))
                object.begin = message.begin;
            if (message.num != null && message.hasOwnProperty("num"))
                object.num = message.num;
            if (message.sortField != null && message.hasOwnProperty("sortField"))
                object.sortField = message.sortField;
            if (message.ascend != null && message.hasOwnProperty("ascend"))
                object.ascend = message.ascend;
            if (message.owner != null && message.hasOwnProperty("owner"))
                object.owner = $root.Qot_Common.Security.toObject(message.owner, options);
            if (message.typeList && message.typeList.length) {
                object.typeList = [];
                for (var j = 0; j < message.typeList.length; ++j)
                    object.typeList[j] = message.typeList[j];
            }
            if (message.issuerList && message.issuerList.length) {
                object.issuerList = [];
                for (var j = 0; j < message.issuerList.length; ++j)
                    object.issuerList[j] = message.issuerList[j];
            }
            if (message.maturityTimeMin != null && message.hasOwnProperty("maturityTimeMin"))
                object.maturityTimeMin = message.maturityTimeMin;
            if (message.maturityTimeMax != null && message.hasOwnProperty("maturityTimeMax"))
                object.maturityTimeMax = message.maturityTimeMax;
            if (message.ipoPeriod != null && message.hasOwnProperty("ipoPeriod"))
                object.ipoPeriod = message.ipoPeriod;
            if (message.priceType != null && message.hasOwnProperty("priceType"))
                object.priceType = message.priceType;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = message.status;
            if (message.curPriceMin != null && message.hasOwnProperty("curPriceMin"))
                object.curPriceMin = options.json && !isFinite(message.curPriceMin) ? String(message.curPriceMin) : message.curPriceMin;
            if (message.curPriceMax != null && message.hasOwnProperty("curPriceMax"))
                object.curPriceMax = options.json && !isFinite(message.curPriceMax) ? String(message.curPriceMax) : message.curPriceMax;
            if (message.strikePriceMin != null && message.hasOwnProperty("strikePriceMin"))
                object.strikePriceMin = options.json && !isFinite(message.strikePriceMin) ? String(message.strikePriceMin) : message.strikePriceMin;
            if (message.strikePriceMax != null && message.hasOwnProperty("strikePriceMax"))
                object.strikePriceMax = options.json && !isFinite(message.strikePriceMax) ? String(message.strikePriceMax) : message.strikePriceMax;
            if (message.streetMin != null && message.hasOwnProperty("streetMin"))
                object.streetMin = options.json && !isFinite(message.streetMin) ? String(message.streetMin) : message.streetMin;
            if (message.streetMax != null && message.hasOwnProperty("streetMax"))
                object.streetMax = options.json && !isFinite(message.streetMax) ? String(message.streetMax) : message.streetMax;
            if (message.conversionMin != null && message.hasOwnProperty("conversionMin"))
                object.conversionMin = options.json && !isFinite(message.conversionMin) ? String(message.conversionMin) : message.conversionMin;
            if (message.conversionMax != null && message.hasOwnProperty("conversionMax"))
                object.conversionMax = options.json && !isFinite(message.conversionMax) ? String(message.conversionMax) : message.conversionMax;
            if (message.volMin != null && message.hasOwnProperty("volMin"))
                if (typeof message.volMin === "number")
                    object.volMin = options.longs === String ? String(message.volMin) : message.volMin;
                else
                    object.volMin = options.longs === String ? $util.Long.prototype.toString.call(message.volMin) : options.longs === Number ? new $util.LongBits(message.volMin.low >>> 0, message.volMin.high >>> 0).toNumber(true) : message.volMin;
            if (message.volMax != null && message.hasOwnProperty("volMax"))
                if (typeof message.volMax === "number")
                    object.volMax = options.longs === String ? String(message.volMax) : message.volMax;
                else
                    object.volMax = options.longs === String ? $util.Long.prototype.toString.call(message.volMax) : options.longs === Number ? new $util.LongBits(message.volMax.low >>> 0, message.volMax.high >>> 0).toNumber(true) : message.volMax;
            if (message.premiumMin != null && message.hasOwnProperty("premiumMin"))
                object.premiumMin = options.json && !isFinite(message.premiumMin) ? String(message.premiumMin) : message.premiumMin;
            if (message.premiumMax != null && message.hasOwnProperty("premiumMax"))
                object.premiumMax = options.json && !isFinite(message.premiumMax) ? String(message.premiumMax) : message.premiumMax;
            if (message.leverageRatioMin != null && message.hasOwnProperty("leverageRatioMin"))
                object.leverageRatioMin = options.json && !isFinite(message.leverageRatioMin) ? String(message.leverageRatioMin) : message.leverageRatioMin;
            if (message.leverageRatioMax != null && message.hasOwnProperty("leverageRatioMax"))
                object.leverageRatioMax = options.json && !isFinite(message.leverageRatioMax) ? String(message.leverageRatioMax) : message.leverageRatioMax;
            if (message.deltaMin != null && message.hasOwnProperty("deltaMin"))
                object.deltaMin = options.json && !isFinite(message.deltaMin) ? String(message.deltaMin) : message.deltaMin;
            if (message.deltaMax != null && message.hasOwnProperty("deltaMax"))
                object.deltaMax = options.json && !isFinite(message.deltaMax) ? String(message.deltaMax) : message.deltaMax;
            if (message.impliedMin != null && message.hasOwnProperty("impliedMin"))
                object.impliedMin = options.json && !isFinite(message.impliedMin) ? String(message.impliedMin) : message.impliedMin;
            if (message.impliedMax != null && message.hasOwnProperty("impliedMax"))
                object.impliedMax = options.json && !isFinite(message.impliedMax) ? String(message.impliedMax) : message.impliedMax;
            if (message.recoveryPriceMin != null && message.hasOwnProperty("recoveryPriceMin"))
                object.recoveryPriceMin = options.json && !isFinite(message.recoveryPriceMin) ? String(message.recoveryPriceMin) : message.recoveryPriceMin;
            if (message.recoveryPriceMax != null && message.hasOwnProperty("recoveryPriceMax"))
                object.recoveryPriceMax = options.json && !isFinite(message.recoveryPriceMax) ? String(message.recoveryPriceMax) : message.recoveryPriceMax;
            if (message.priceRecoveryRatioMin != null && message.hasOwnProperty("priceRecoveryRatioMin"))
                object.priceRecoveryRatioMin = options.json && !isFinite(message.priceRecoveryRatioMin) ? String(message.priceRecoveryRatioMin) : message.priceRecoveryRatioMin;
            if (message.priceRecoveryRatioMax != null && message.hasOwnProperty("priceRecoveryRatioMax"))
                object.priceRecoveryRatioMax = options.json && !isFinite(message.priceRecoveryRatioMax) ? String(message.priceRecoveryRatioMax) : message.priceRecoveryRatioMax;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Qot_GetWarrant.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Qot_GetWarrant.WarrantData = (function() {

        /**
         * Properties of a WarrantData.
         * @memberof Qot_GetWarrant
         * @interface IWarrantData
         * @property {Qot_Common.ISecurity} stock WarrantData stock
         * @property {Qot_Common.ISecurity} owner WarrantData owner
         * @property {number} type WarrantData type
         * @property {number} issuer WarrantData issuer
         * @property {string} maturityTime WarrantData maturityTime
         * @property {number|null} [maturityTimestamp] WarrantData maturityTimestamp
         * @property {string} listTime WarrantData listTime
         * @property {number|null} [listTimestamp] WarrantData listTimestamp
         * @property {string} lastTradeTime WarrantData lastTradeTime
         * @property {number|null} [lastTradeTimestamp] WarrantData lastTradeTimestamp
         * @property {number|null} [recoveryPrice] WarrantData recoveryPrice
         * @property {number} conversionRatio WarrantData conversionRatio
         * @property {number} lotSize WarrantData lotSize
         * @property {number} strikePrice WarrantData strikePrice
         * @property {number} lastClosePrice WarrantData lastClosePrice
         * @property {string} name WarrantData name
         * @property {number} curPrice WarrantData curPrice
         * @property {number} priceChangeVal WarrantData priceChangeVal
         * @property {number} changeRate WarrantData changeRate
         * @property {number} status WarrantData status
         * @property {number} bidPrice WarrantData bidPrice
         * @property {number} askPrice WarrantData askPrice
         * @property {number|Long} bidVol WarrantData bidVol
         * @property {number|Long} askVol WarrantData askVol
         * @property {number|Long} volume WarrantData volume
         * @property {number} turnover WarrantData turnover
         * @property {number} score WarrantData score
         * @property {number} premium WarrantData premium
         * @property {number} breakEvenPoint WarrantData breakEvenPoint
         * @property {number} leverage WarrantData leverage
         * @property {number} ipop WarrantData ipop
         * @property {number|null} [priceRecoveryRatio] WarrantData priceRecoveryRatio
         * @property {number} conversionPrice WarrantData conversionPrice
         * @property {number} streetRate WarrantData streetRate
         * @property {number|Long} streetVol WarrantData streetVol
         * @property {number} amplitude WarrantData amplitude
         * @property {number|Long} issueSize WarrantData issueSize
         * @property {number} highPrice WarrantData highPrice
         * @property {number} lowPrice WarrantData lowPrice
         * @property {number|null} [impliedVolatility] WarrantData impliedVolatility
         * @property {number|null} [delta] WarrantData delta
         * @property {number} effectiveLeverage WarrantData effectiveLeverage
         */

        /**
         * Constructs a new WarrantData.
         * @memberof Qot_GetWarrant
         * @classdesc Represents a WarrantData.
         * @implements IWarrantData
         * @constructor
         * @param {Qot_GetWarrant.IWarrantData=} [properties] Properties to set
         */
        function WarrantData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WarrantData stock.
         * @member {Qot_Common.ISecurity} stock
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.stock = null;

        /**
         * WarrantData owner.
         * @member {Qot_Common.ISecurity} owner
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.owner = null;

        /**
         * WarrantData type.
         * @member {number} type
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.type = 0;

        /**
         * WarrantData issuer.
         * @member {number} issuer
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.issuer = 0;

        /**
         * WarrantData maturityTime.
         * @member {string} maturityTime
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.maturityTime = "";

        /**
         * WarrantData maturityTimestamp.
         * @member {number} maturityTimestamp
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.maturityTimestamp = 0;

        /**
         * WarrantData listTime.
         * @member {string} listTime
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.listTime = "";

        /**
         * WarrantData listTimestamp.
         * @member {number} listTimestamp
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.listTimestamp = 0;

        /**
         * WarrantData lastTradeTime.
         * @member {string} lastTradeTime
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.lastTradeTime = "";

        /**
         * WarrantData lastTradeTimestamp.
         * @member {number} lastTradeTimestamp
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.lastTradeTimestamp = 0;

        /**
         * WarrantData recoveryPrice.
         * @member {number} recoveryPrice
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.recoveryPrice = 0;

        /**
         * WarrantData conversionRatio.
         * @member {number} conversionRatio
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.conversionRatio = 0;

        /**
         * WarrantData lotSize.
         * @member {number} lotSize
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.lotSize = 0;

        /**
         * WarrantData strikePrice.
         * @member {number} strikePrice
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.strikePrice = 0;

        /**
         * WarrantData lastClosePrice.
         * @member {number} lastClosePrice
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.lastClosePrice = 0;

        /**
         * WarrantData name.
         * @member {string} name
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.name = "";

        /**
         * WarrantData curPrice.
         * @member {number} curPrice
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.curPrice = 0;

        /**
         * WarrantData priceChangeVal.
         * @member {number} priceChangeVal
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.priceChangeVal = 0;

        /**
         * WarrantData changeRate.
         * @member {number} changeRate
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.changeRate = 0;

        /**
         * WarrantData status.
         * @member {number} status
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.status = 0;

        /**
         * WarrantData bidPrice.
         * @member {number} bidPrice
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.bidPrice = 0;

        /**
         * WarrantData askPrice.
         * @member {number} askPrice
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.askPrice = 0;

        /**
         * WarrantData bidVol.
         * @member {number|Long} bidVol
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.bidVol = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * WarrantData askVol.
         * @member {number|Long} askVol
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.askVol = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * WarrantData volume.
         * @member {number|Long} volume
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.volume = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * WarrantData turnover.
         * @member {number} turnover
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.turnover = 0;

        /**
         * WarrantData score.
         * @member {number} score
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.score = 0;

        /**
         * WarrantData premium.
         * @member {number} premium
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.premium = 0;

        /**
         * WarrantData breakEvenPoint.
         * @member {number} breakEvenPoint
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.breakEvenPoint = 0;

        /**
         * WarrantData leverage.
         * @member {number} leverage
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.leverage = 0;

        /**
         * WarrantData ipop.
         * @member {number} ipop
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.ipop = 0;

        /**
         * WarrantData priceRecoveryRatio.
         * @member {number} priceRecoveryRatio
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.priceRecoveryRatio = 0;

        /**
         * WarrantData conversionPrice.
         * @member {number} conversionPrice
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.conversionPrice = 0;

        /**
         * WarrantData streetRate.
         * @member {number} streetRate
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.streetRate = 0;

        /**
         * WarrantData streetVol.
         * @member {number|Long} streetVol
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.streetVol = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * WarrantData amplitude.
         * @member {number} amplitude
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.amplitude = 0;

        /**
         * WarrantData issueSize.
         * @member {number|Long} issueSize
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.issueSize = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * WarrantData highPrice.
         * @member {number} highPrice
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.highPrice = 0;

        /**
         * WarrantData lowPrice.
         * @member {number} lowPrice
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.lowPrice = 0;

        /**
         * WarrantData impliedVolatility.
         * @member {number} impliedVolatility
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.impliedVolatility = 0;

        /**
         * WarrantData delta.
         * @member {number} delta
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.delta = 0;

        /**
         * WarrantData effectiveLeverage.
         * @member {number} effectiveLeverage
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         */
        WarrantData.prototype.effectiveLeverage = 0;

        /**
         * Creates a new WarrantData instance using the specified properties.
         * @function create
         * @memberof Qot_GetWarrant.WarrantData
         * @static
         * @param {Qot_GetWarrant.IWarrantData=} [properties] Properties to set
         * @returns {Qot_GetWarrant.WarrantData} WarrantData instance
         */
        WarrantData.create = function create(properties) {
            return new WarrantData(properties);
        };

        /**
         * Encodes the specified WarrantData message. Does not implicitly {@link Qot_GetWarrant.WarrantData.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetWarrant.WarrantData
         * @static
         * @param {Qot_GetWarrant.IWarrantData} message WarrantData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WarrantData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.stock, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            $root.Qot_Common.Security.encode(message.owner, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.type);
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.issuer);
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.maturityTime);
            if (message.maturityTimestamp != null && message.hasOwnProperty("maturityTimestamp"))
                writer.uint32(/* id 6, wireType 1 =*/49).double(message.maturityTimestamp);
            writer.uint32(/* id 7, wireType 2 =*/58).string(message.listTime);
            if (message.listTimestamp != null && message.hasOwnProperty("listTimestamp"))
                writer.uint32(/* id 8, wireType 1 =*/65).double(message.listTimestamp);
            writer.uint32(/* id 9, wireType 2 =*/74).string(message.lastTradeTime);
            if (message.lastTradeTimestamp != null && message.hasOwnProperty("lastTradeTimestamp"))
                writer.uint32(/* id 10, wireType 1 =*/81).double(message.lastTradeTimestamp);
            if (message.recoveryPrice != null && message.hasOwnProperty("recoveryPrice"))
                writer.uint32(/* id 11, wireType 1 =*/89).double(message.recoveryPrice);
            writer.uint32(/* id 12, wireType 1 =*/97).double(message.conversionRatio);
            writer.uint32(/* id 13, wireType 0 =*/104).int32(message.lotSize);
            writer.uint32(/* id 14, wireType 1 =*/113).double(message.strikePrice);
            writer.uint32(/* id 15, wireType 1 =*/121).double(message.lastClosePrice);
            writer.uint32(/* id 16, wireType 2 =*/130).string(message.name);
            writer.uint32(/* id 17, wireType 1 =*/137).double(message.curPrice);
            writer.uint32(/* id 18, wireType 1 =*/145).double(message.priceChangeVal);
            writer.uint32(/* id 19, wireType 1 =*/153).double(message.changeRate);
            writer.uint32(/* id 20, wireType 0 =*/160).int32(message.status);
            writer.uint32(/* id 21, wireType 1 =*/169).double(message.bidPrice);
            writer.uint32(/* id 22, wireType 1 =*/177).double(message.askPrice);
            writer.uint32(/* id 23, wireType 0 =*/184).int64(message.bidVol);
            writer.uint32(/* id 24, wireType 0 =*/192).int64(message.askVol);
            writer.uint32(/* id 25, wireType 0 =*/200).int64(message.volume);
            writer.uint32(/* id 26, wireType 1 =*/209).double(message.turnover);
            writer.uint32(/* id 27, wireType 1 =*/217).double(message.score);
            writer.uint32(/* id 28, wireType 1 =*/225).double(message.premium);
            writer.uint32(/* id 29, wireType 1 =*/233).double(message.breakEvenPoint);
            writer.uint32(/* id 30, wireType 1 =*/241).double(message.leverage);
            writer.uint32(/* id 31, wireType 1 =*/249).double(message.ipop);
            if (message.priceRecoveryRatio != null && message.hasOwnProperty("priceRecoveryRatio"))
                writer.uint32(/* id 32, wireType 1 =*/257).double(message.priceRecoveryRatio);
            writer.uint32(/* id 33, wireType 1 =*/265).double(message.conversionPrice);
            writer.uint32(/* id 34, wireType 1 =*/273).double(message.streetRate);
            writer.uint32(/* id 35, wireType 0 =*/280).int64(message.streetVol);
            writer.uint32(/* id 36, wireType 1 =*/289).double(message.amplitude);
            writer.uint32(/* id 37, wireType 0 =*/296).int64(message.issueSize);
            writer.uint32(/* id 39, wireType 1 =*/313).double(message.highPrice);
            writer.uint32(/* id 40, wireType 1 =*/321).double(message.lowPrice);
            if (message.impliedVolatility != null && message.hasOwnProperty("impliedVolatility"))
                writer.uint32(/* id 41, wireType 1 =*/329).double(message.impliedVolatility);
            if (message.delta != null && message.hasOwnProperty("delta"))
                writer.uint32(/* id 42, wireType 1 =*/337).double(message.delta);
            writer.uint32(/* id 43, wireType 1 =*/345).double(message.effectiveLeverage);
            return writer;
        };

        /**
         * Encodes the specified WarrantData message, length delimited. Does not implicitly {@link Qot_GetWarrant.WarrantData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetWarrant.WarrantData
         * @static
         * @param {Qot_GetWarrant.IWarrantData} message WarrantData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WarrantData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WarrantData message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetWarrant.WarrantData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetWarrant.WarrantData} WarrantData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WarrantData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetWarrant.WarrantData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.stock = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.owner = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.type = reader.int32();
                    break;
                case 4:
                    message.issuer = reader.int32();
                    break;
                case 5:
                    message.maturityTime = reader.string();
                    break;
                case 6:
                    message.maturityTimestamp = reader.double();
                    break;
                case 7:
                    message.listTime = reader.string();
                    break;
                case 8:
                    message.listTimestamp = reader.double();
                    break;
                case 9:
                    message.lastTradeTime = reader.string();
                    break;
                case 10:
                    message.lastTradeTimestamp = reader.double();
                    break;
                case 11:
                    message.recoveryPrice = reader.double();
                    break;
                case 12:
                    message.conversionRatio = reader.double();
                    break;
                case 13:
                    message.lotSize = reader.int32();
                    break;
                case 14:
                    message.strikePrice = reader.double();
                    break;
                case 15:
                    message.lastClosePrice = reader.double();
                    break;
                case 16:
                    message.name = reader.string();
                    break;
                case 17:
                    message.curPrice = reader.double();
                    break;
                case 18:
                    message.priceChangeVal = reader.double();
                    break;
                case 19:
                    message.changeRate = reader.double();
                    break;
                case 20:
                    message.status = reader.int32();
                    break;
                case 21:
                    message.bidPrice = reader.double();
                    break;
                case 22:
                    message.askPrice = reader.double();
                    break;
                case 23:
                    message.bidVol = reader.int64();
                    break;
                case 24:
                    message.askVol = reader.int64();
                    break;
                case 25:
                    message.volume = reader.int64();
                    break;
                case 26:
                    message.turnover = reader.double();
                    break;
                case 27:
                    message.score = reader.double();
                    break;
                case 28:
                    message.premium = reader.double();
                    break;
                case 29:
                    message.breakEvenPoint = reader.double();
                    break;
                case 30:
                    message.leverage = reader.double();
                    break;
                case 31:
                    message.ipop = reader.double();
                    break;
                case 32:
                    message.priceRecoveryRatio = reader.double();
                    break;
                case 33:
                    message.conversionPrice = reader.double();
                    break;
                case 34:
                    message.streetRate = reader.double();
                    break;
                case 35:
                    message.streetVol = reader.int64();
                    break;
                case 36:
                    message.amplitude = reader.double();
                    break;
                case 37:
                    message.issueSize = reader.int64();
                    break;
                case 39:
                    message.highPrice = reader.double();
                    break;
                case 40:
                    message.lowPrice = reader.double();
                    break;
                case 41:
                    message.impliedVolatility = reader.double();
                    break;
                case 42:
                    message.delta = reader.double();
                    break;
                case 43:
                    message.effectiveLeverage = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("stock"))
                throw $util.ProtocolError("missing required 'stock'", { instance: message });
            if (!message.hasOwnProperty("owner"))
                throw $util.ProtocolError("missing required 'owner'", { instance: message });
            if (!message.hasOwnProperty("type"))
                throw $util.ProtocolError("missing required 'type'", { instance: message });
            if (!message.hasOwnProperty("issuer"))
                throw $util.ProtocolError("missing required 'issuer'", { instance: message });
            if (!message.hasOwnProperty("maturityTime"))
                throw $util.ProtocolError("missing required 'maturityTime'", { instance: message });
            if (!message.hasOwnProperty("listTime"))
                throw $util.ProtocolError("missing required 'listTime'", { instance: message });
            if (!message.hasOwnProperty("lastTradeTime"))
                throw $util.ProtocolError("missing required 'lastTradeTime'", { instance: message });
            if (!message.hasOwnProperty("conversionRatio"))
                throw $util.ProtocolError("missing required 'conversionRatio'", { instance: message });
            if (!message.hasOwnProperty("lotSize"))
                throw $util.ProtocolError("missing required 'lotSize'", { instance: message });
            if (!message.hasOwnProperty("strikePrice"))
                throw $util.ProtocolError("missing required 'strikePrice'", { instance: message });
            if (!message.hasOwnProperty("lastClosePrice"))
                throw $util.ProtocolError("missing required 'lastClosePrice'", { instance: message });
            if (!message.hasOwnProperty("name"))
                throw $util.ProtocolError("missing required 'name'", { instance: message });
            if (!message.hasOwnProperty("curPrice"))
                throw $util.ProtocolError("missing required 'curPrice'", { instance: message });
            if (!message.hasOwnProperty("priceChangeVal"))
                throw $util.ProtocolError("missing required 'priceChangeVal'", { instance: message });
            if (!message.hasOwnProperty("changeRate"))
                throw $util.ProtocolError("missing required 'changeRate'", { instance: message });
            if (!message.hasOwnProperty("status"))
                throw $util.ProtocolError("missing required 'status'", { instance: message });
            if (!message.hasOwnProperty("bidPrice"))
                throw $util.ProtocolError("missing required 'bidPrice'", { instance: message });
            if (!message.hasOwnProperty("askPrice"))
                throw $util.ProtocolError("missing required 'askPrice'", { instance: message });
            if (!message.hasOwnProperty("bidVol"))
                throw $util.ProtocolError("missing required 'bidVol'", { instance: message });
            if (!message.hasOwnProperty("askVol"))
                throw $util.ProtocolError("missing required 'askVol'", { instance: message });
            if (!message.hasOwnProperty("volume"))
                throw $util.ProtocolError("missing required 'volume'", { instance: message });
            if (!message.hasOwnProperty("turnover"))
                throw $util.ProtocolError("missing required 'turnover'", { instance: message });
            if (!message.hasOwnProperty("score"))
                throw $util.ProtocolError("missing required 'score'", { instance: message });
            if (!message.hasOwnProperty("premium"))
                throw $util.ProtocolError("missing required 'premium'", { instance: message });
            if (!message.hasOwnProperty("breakEvenPoint"))
                throw $util.ProtocolError("missing required 'breakEvenPoint'", { instance: message });
            if (!message.hasOwnProperty("leverage"))
                throw $util.ProtocolError("missing required 'leverage'", { instance: message });
            if (!message.hasOwnProperty("ipop"))
                throw $util.ProtocolError("missing required 'ipop'", { instance: message });
            if (!message.hasOwnProperty("conversionPrice"))
                throw $util.ProtocolError("missing required 'conversionPrice'", { instance: message });
            if (!message.hasOwnProperty("streetRate"))
                throw $util.ProtocolError("missing required 'streetRate'", { instance: message });
            if (!message.hasOwnProperty("streetVol"))
                throw $util.ProtocolError("missing required 'streetVol'", { instance: message });
            if (!message.hasOwnProperty("amplitude"))
                throw $util.ProtocolError("missing required 'amplitude'", { instance: message });
            if (!message.hasOwnProperty("issueSize"))
                throw $util.ProtocolError("missing required 'issueSize'", { instance: message });
            if (!message.hasOwnProperty("highPrice"))
                throw $util.ProtocolError("missing required 'highPrice'", { instance: message });
            if (!message.hasOwnProperty("lowPrice"))
                throw $util.ProtocolError("missing required 'lowPrice'", { instance: message });
            if (!message.hasOwnProperty("effectiveLeverage"))
                throw $util.ProtocolError("missing required 'effectiveLeverage'", { instance: message });
            return message;
        };

        /**
         * Decodes a WarrantData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetWarrant.WarrantData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetWarrant.WarrantData} WarrantData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WarrantData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WarrantData message.
         * @function verify
         * @memberof Qot_GetWarrant.WarrantData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WarrantData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.stock);
                if (error)
                    return "stock." + error;
            }
            {
                var error = $root.Qot_Common.Security.verify(message.owner);
                if (error)
                    return "owner." + error;
            }
            if (!$util.isInteger(message.type))
                return "type: integer expected";
            if (!$util.isInteger(message.issuer))
                return "issuer: integer expected";
            if (!$util.isString(message.maturityTime))
                return "maturityTime: string expected";
            if (message.maturityTimestamp != null && message.hasOwnProperty("maturityTimestamp"))
                if (typeof message.maturityTimestamp !== "number")
                    return "maturityTimestamp: number expected";
            if (!$util.isString(message.listTime))
                return "listTime: string expected";
            if (message.listTimestamp != null && message.hasOwnProperty("listTimestamp"))
                if (typeof message.listTimestamp !== "number")
                    return "listTimestamp: number expected";
            if (!$util.isString(message.lastTradeTime))
                return "lastTradeTime: string expected";
            if (message.lastTradeTimestamp != null && message.hasOwnProperty("lastTradeTimestamp"))
                if (typeof message.lastTradeTimestamp !== "number")
                    return "lastTradeTimestamp: number expected";
            if (message.recoveryPrice != null && message.hasOwnProperty("recoveryPrice"))
                if (typeof message.recoveryPrice !== "number")
                    return "recoveryPrice: number expected";
            if (typeof message.conversionRatio !== "number")
                return "conversionRatio: number expected";
            if (!$util.isInteger(message.lotSize))
                return "lotSize: integer expected";
            if (typeof message.strikePrice !== "number")
                return "strikePrice: number expected";
            if (typeof message.lastClosePrice !== "number")
                return "lastClosePrice: number expected";
            if (!$util.isString(message.name))
                return "name: string expected";
            if (typeof message.curPrice !== "number")
                return "curPrice: number expected";
            if (typeof message.priceChangeVal !== "number")
                return "priceChangeVal: number expected";
            if (typeof message.changeRate !== "number")
                return "changeRate: number expected";
            if (!$util.isInteger(message.status))
                return "status: integer expected";
            if (typeof message.bidPrice !== "number")
                return "bidPrice: number expected";
            if (typeof message.askPrice !== "number")
                return "askPrice: number expected";
            if (!$util.isInteger(message.bidVol) && !(message.bidVol && $util.isInteger(message.bidVol.low) && $util.isInteger(message.bidVol.high)))
                return "bidVol: integer|Long expected";
            if (!$util.isInteger(message.askVol) && !(message.askVol && $util.isInteger(message.askVol.low) && $util.isInteger(message.askVol.high)))
                return "askVol: integer|Long expected";
            if (!$util.isInteger(message.volume) && !(message.volume && $util.isInteger(message.volume.low) && $util.isInteger(message.volume.high)))
                return "volume: integer|Long expected";
            if (typeof message.turnover !== "number")
                return "turnover: number expected";
            if (typeof message.score !== "number")
                return "score: number expected";
            if (typeof message.premium !== "number")
                return "premium: number expected";
            if (typeof message.breakEvenPoint !== "number")
                return "breakEvenPoint: number expected";
            if (typeof message.leverage !== "number")
                return "leverage: number expected";
            if (typeof message.ipop !== "number")
                return "ipop: number expected";
            if (message.priceRecoveryRatio != null && message.hasOwnProperty("priceRecoveryRatio"))
                if (typeof message.priceRecoveryRatio !== "number")
                    return "priceRecoveryRatio: number expected";
            if (typeof message.conversionPrice !== "number")
                return "conversionPrice: number expected";
            if (typeof message.streetRate !== "number")
                return "streetRate: number expected";
            if (!$util.isInteger(message.streetVol) && !(message.streetVol && $util.isInteger(message.streetVol.low) && $util.isInteger(message.streetVol.high)))
                return "streetVol: integer|Long expected";
            if (typeof message.amplitude !== "number")
                return "amplitude: number expected";
            if (!$util.isInteger(message.issueSize) && !(message.issueSize && $util.isInteger(message.issueSize.low) && $util.isInteger(message.issueSize.high)))
                return "issueSize: integer|Long expected";
            if (typeof message.highPrice !== "number")
                return "highPrice: number expected";
            if (typeof message.lowPrice !== "number")
                return "lowPrice: number expected";
            if (message.impliedVolatility != null && message.hasOwnProperty("impliedVolatility"))
                if (typeof message.impliedVolatility !== "number")
                    return "impliedVolatility: number expected";
            if (message.delta != null && message.hasOwnProperty("delta"))
                if (typeof message.delta !== "number")
                    return "delta: number expected";
            if (typeof message.effectiveLeverage !== "number")
                return "effectiveLeverage: number expected";
            return null;
        };

        /**
         * Creates a WarrantData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetWarrant.WarrantData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetWarrant.WarrantData} WarrantData
         */
        WarrantData.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetWarrant.WarrantData)
                return object;
            var message = new $root.Qot_GetWarrant.WarrantData();
            if (object.stock != null) {
                if (typeof object.stock !== "object")
                    throw TypeError(".Qot_GetWarrant.WarrantData.stock: object expected");
                message.stock = $root.Qot_Common.Security.fromObject(object.stock);
            }
            if (object.owner != null) {
                if (typeof object.owner !== "object")
                    throw TypeError(".Qot_GetWarrant.WarrantData.owner: object expected");
                message.owner = $root.Qot_Common.Security.fromObject(object.owner);
            }
            if (object.type != null)
                message.type = object.type | 0;
            if (object.issuer != null)
                message.issuer = object.issuer | 0;
            if (object.maturityTime != null)
                message.maturityTime = String(object.maturityTime);
            if (object.maturityTimestamp != null)
                message.maturityTimestamp = Number(object.maturityTimestamp);
            if (object.listTime != null)
                message.listTime = String(object.listTime);
            if (object.listTimestamp != null)
                message.listTimestamp = Number(object.listTimestamp);
            if (object.lastTradeTime != null)
                message.lastTradeTime = String(object.lastTradeTime);
            if (object.lastTradeTimestamp != null)
                message.lastTradeTimestamp = Number(object.lastTradeTimestamp);
            if (object.recoveryPrice != null)
                message.recoveryPrice = Number(object.recoveryPrice);
            if (object.conversionRatio != null)
                message.conversionRatio = Number(object.conversionRatio);
            if (object.lotSize != null)
                message.lotSize = object.lotSize | 0;
            if (object.strikePrice != null)
                message.strikePrice = Number(object.strikePrice);
            if (object.lastClosePrice != null)
                message.lastClosePrice = Number(object.lastClosePrice);
            if (object.name != null)
                message.name = String(object.name);
            if (object.curPrice != null)
                message.curPrice = Number(object.curPrice);
            if (object.priceChangeVal != null)
                message.priceChangeVal = Number(object.priceChangeVal);
            if (object.changeRate != null)
                message.changeRate = Number(object.changeRate);
            if (object.status != null)
                message.status = object.status | 0;
            if (object.bidPrice != null)
                message.bidPrice = Number(object.bidPrice);
            if (object.askPrice != null)
                message.askPrice = Number(object.askPrice);
            if (object.bidVol != null)
                if ($util.Long)
                    (message.bidVol = $util.Long.fromValue(object.bidVol)).unsigned = false;
                else if (typeof object.bidVol === "string")
                    message.bidVol = parseInt(object.bidVol, 10);
                else if (typeof object.bidVol === "number")
                    message.bidVol = object.bidVol;
                else if (typeof object.bidVol === "object")
                    message.bidVol = new $util.LongBits(object.bidVol.low >>> 0, object.bidVol.high >>> 0).toNumber();
            if (object.askVol != null)
                if ($util.Long)
                    (message.askVol = $util.Long.fromValue(object.askVol)).unsigned = false;
                else if (typeof object.askVol === "string")
                    message.askVol = parseInt(object.askVol, 10);
                else if (typeof object.askVol === "number")
                    message.askVol = object.askVol;
                else if (typeof object.askVol === "object")
                    message.askVol = new $util.LongBits(object.askVol.low >>> 0, object.askVol.high >>> 0).toNumber();
            if (object.volume != null)
                if ($util.Long)
                    (message.volume = $util.Long.fromValue(object.volume)).unsigned = false;
                else if (typeof object.volume === "string")
                    message.volume = parseInt(object.volume, 10);
                else if (typeof object.volume === "number")
                    message.volume = object.volume;
                else if (typeof object.volume === "object")
                    message.volume = new $util.LongBits(object.volume.low >>> 0, object.volume.high >>> 0).toNumber();
            if (object.turnover != null)
                message.turnover = Number(object.turnover);
            if (object.score != null)
                message.score = Number(object.score);
            if (object.premium != null)
                message.premium = Number(object.premium);
            if (object.breakEvenPoint != null)
                message.breakEvenPoint = Number(object.breakEvenPoint);
            if (object.leverage != null)
                message.leverage = Number(object.leverage);
            if (object.ipop != null)
                message.ipop = Number(object.ipop);
            if (object.priceRecoveryRatio != null)
                message.priceRecoveryRatio = Number(object.priceRecoveryRatio);
            if (object.conversionPrice != null)
                message.conversionPrice = Number(object.conversionPrice);
            if (object.streetRate != null)
                message.streetRate = Number(object.streetRate);
            if (object.streetVol != null)
                if ($util.Long)
                    (message.streetVol = $util.Long.fromValue(object.streetVol)).unsigned = false;
                else if (typeof object.streetVol === "string")
                    message.streetVol = parseInt(object.streetVol, 10);
                else if (typeof object.streetVol === "number")
                    message.streetVol = object.streetVol;
                else if (typeof object.streetVol === "object")
                    message.streetVol = new $util.LongBits(object.streetVol.low >>> 0, object.streetVol.high >>> 0).toNumber();
            if (object.amplitude != null)
                message.amplitude = Number(object.amplitude);
            if (object.issueSize != null)
                if ($util.Long)
                    (message.issueSize = $util.Long.fromValue(object.issueSize)).unsigned = false;
                else if (typeof object.issueSize === "string")
                    message.issueSize = parseInt(object.issueSize, 10);
                else if (typeof object.issueSize === "number")
                    message.issueSize = object.issueSize;
                else if (typeof object.issueSize === "object")
                    message.issueSize = new $util.LongBits(object.issueSize.low >>> 0, object.issueSize.high >>> 0).toNumber();
            if (object.highPrice != null)
                message.highPrice = Number(object.highPrice);
            if (object.lowPrice != null)
                message.lowPrice = Number(object.lowPrice);
            if (object.impliedVolatility != null)
                message.impliedVolatility = Number(object.impliedVolatility);
            if (object.delta != null)
                message.delta = Number(object.delta);
            if (object.effectiveLeverage != null)
                message.effectiveLeverage = Number(object.effectiveLeverage);
            return message;
        };

        /**
         * Creates a plain object from a WarrantData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetWarrant.WarrantData
         * @static
         * @param {Qot_GetWarrant.WarrantData} message WarrantData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WarrantData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.stock = null;
                object.owner = null;
                object.type = 0;
                object.issuer = 0;
                object.maturityTime = "";
                object.maturityTimestamp = 0;
                object.listTime = "";
                object.listTimestamp = 0;
                object.lastTradeTime = "";
                object.lastTradeTimestamp = 0;
                object.recoveryPrice = 0;
                object.conversionRatio = 0;
                object.lotSize = 0;
                object.strikePrice = 0;
                object.lastClosePrice = 0;
                object.name = "";
                object.curPrice = 0;
                object.priceChangeVal = 0;
                object.changeRate = 0;
                object.status = 0;
                object.bidPrice = 0;
                object.askPrice = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.bidVol = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.bidVol = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.askVol = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.askVol = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.volume = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.volume = options.longs === String ? "0" : 0;
                object.turnover = 0;
                object.score = 0;
                object.premium = 0;
                object.breakEvenPoint = 0;
                object.leverage = 0;
                object.ipop = 0;
                object.priceRecoveryRatio = 0;
                object.conversionPrice = 0;
                object.streetRate = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.streetVol = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.streetVol = options.longs === String ? "0" : 0;
                object.amplitude = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.issueSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.issueSize = options.longs === String ? "0" : 0;
                object.highPrice = 0;
                object.lowPrice = 0;
                object.impliedVolatility = 0;
                object.delta = 0;
                object.effectiveLeverage = 0;
            }
            if (message.stock != null && message.hasOwnProperty("stock"))
                object.stock = $root.Qot_Common.Security.toObject(message.stock, options);
            if (message.owner != null && message.hasOwnProperty("owner"))
                object.owner = $root.Qot_Common.Security.toObject(message.owner, options);
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.issuer != null && message.hasOwnProperty("issuer"))
                object.issuer = message.issuer;
            if (message.maturityTime != null && message.hasOwnProperty("maturityTime"))
                object.maturityTime = message.maturityTime;
            if (message.maturityTimestamp != null && message.hasOwnProperty("maturityTimestamp"))
                object.maturityTimestamp = options.json && !isFinite(message.maturityTimestamp) ? String(message.maturityTimestamp) : message.maturityTimestamp;
            if (message.listTime != null && message.hasOwnProperty("listTime"))
                object.listTime = message.listTime;
            if (message.listTimestamp != null && message.hasOwnProperty("listTimestamp"))
                object.listTimestamp = options.json && !isFinite(message.listTimestamp) ? String(message.listTimestamp) : message.listTimestamp;
            if (message.lastTradeTime != null && message.hasOwnProperty("lastTradeTime"))
                object.lastTradeTime = message.lastTradeTime;
            if (message.lastTradeTimestamp != null && message.hasOwnProperty("lastTradeTimestamp"))
                object.lastTradeTimestamp = options.json && !isFinite(message.lastTradeTimestamp) ? String(message.lastTradeTimestamp) : message.lastTradeTimestamp;
            if (message.recoveryPrice != null && message.hasOwnProperty("recoveryPrice"))
                object.recoveryPrice = options.json && !isFinite(message.recoveryPrice) ? String(message.recoveryPrice) : message.recoveryPrice;
            if (message.conversionRatio != null && message.hasOwnProperty("conversionRatio"))
                object.conversionRatio = options.json && !isFinite(message.conversionRatio) ? String(message.conversionRatio) : message.conversionRatio;
            if (message.lotSize != null && message.hasOwnProperty("lotSize"))
                object.lotSize = message.lotSize;
            if (message.strikePrice != null && message.hasOwnProperty("strikePrice"))
                object.strikePrice = options.json && !isFinite(message.strikePrice) ? String(message.strikePrice) : message.strikePrice;
            if (message.lastClosePrice != null && message.hasOwnProperty("lastClosePrice"))
                object.lastClosePrice = options.json && !isFinite(message.lastClosePrice) ? String(message.lastClosePrice) : message.lastClosePrice;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.curPrice != null && message.hasOwnProperty("curPrice"))
                object.curPrice = options.json && !isFinite(message.curPrice) ? String(message.curPrice) : message.curPrice;
            if (message.priceChangeVal != null && message.hasOwnProperty("priceChangeVal"))
                object.priceChangeVal = options.json && !isFinite(message.priceChangeVal) ? String(message.priceChangeVal) : message.priceChangeVal;
            if (message.changeRate != null && message.hasOwnProperty("changeRate"))
                object.changeRate = options.json && !isFinite(message.changeRate) ? String(message.changeRate) : message.changeRate;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = message.status;
            if (message.bidPrice != null && message.hasOwnProperty("bidPrice"))
                object.bidPrice = options.json && !isFinite(message.bidPrice) ? String(message.bidPrice) : message.bidPrice;
            if (message.askPrice != null && message.hasOwnProperty("askPrice"))
                object.askPrice = options.json && !isFinite(message.askPrice) ? String(message.askPrice) : message.askPrice;
            if (message.bidVol != null && message.hasOwnProperty("bidVol"))
                if (typeof message.bidVol === "number")
                    object.bidVol = options.longs === String ? String(message.bidVol) : message.bidVol;
                else
                    object.bidVol = options.longs === String ? $util.Long.prototype.toString.call(message.bidVol) : options.longs === Number ? new $util.LongBits(message.bidVol.low >>> 0, message.bidVol.high >>> 0).toNumber() : message.bidVol;
            if (message.askVol != null && message.hasOwnProperty("askVol"))
                if (typeof message.askVol === "number")
                    object.askVol = options.longs === String ? String(message.askVol) : message.askVol;
                else
                    object.askVol = options.longs === String ? $util.Long.prototype.toString.call(message.askVol) : options.longs === Number ? new $util.LongBits(message.askVol.low >>> 0, message.askVol.high >>> 0).toNumber() : message.askVol;
            if (message.volume != null && message.hasOwnProperty("volume"))
                if (typeof message.volume === "number")
                    object.volume = options.longs === String ? String(message.volume) : message.volume;
                else
                    object.volume = options.longs === String ? $util.Long.prototype.toString.call(message.volume) : options.longs === Number ? new $util.LongBits(message.volume.low >>> 0, message.volume.high >>> 0).toNumber() : message.volume;
            if (message.turnover != null && message.hasOwnProperty("turnover"))
                object.turnover = options.json && !isFinite(message.turnover) ? String(message.turnover) : message.turnover;
            if (message.score != null && message.hasOwnProperty("score"))
                object.score = options.json && !isFinite(message.score) ? String(message.score) : message.score;
            if (message.premium != null && message.hasOwnProperty("premium"))
                object.premium = options.json && !isFinite(message.premium) ? String(message.premium) : message.premium;
            if (message.breakEvenPoint != null && message.hasOwnProperty("breakEvenPoint"))
                object.breakEvenPoint = options.json && !isFinite(message.breakEvenPoint) ? String(message.breakEvenPoint) : message.breakEvenPoint;
            if (message.leverage != null && message.hasOwnProperty("leverage"))
                object.leverage = options.json && !isFinite(message.leverage) ? String(message.leverage) : message.leverage;
            if (message.ipop != null && message.hasOwnProperty("ipop"))
                object.ipop = options.json && !isFinite(message.ipop) ? String(message.ipop) : message.ipop;
            if (message.priceRecoveryRatio != null && message.hasOwnProperty("priceRecoveryRatio"))
                object.priceRecoveryRatio = options.json && !isFinite(message.priceRecoveryRatio) ? String(message.priceRecoveryRatio) : message.priceRecoveryRatio;
            if (message.conversionPrice != null && message.hasOwnProperty("conversionPrice"))
                object.conversionPrice = options.json && !isFinite(message.conversionPrice) ? String(message.conversionPrice) : message.conversionPrice;
            if (message.streetRate != null && message.hasOwnProperty("streetRate"))
                object.streetRate = options.json && !isFinite(message.streetRate) ? String(message.streetRate) : message.streetRate;
            if (message.streetVol != null && message.hasOwnProperty("streetVol"))
                if (typeof message.streetVol === "number")
                    object.streetVol = options.longs === String ? String(message.streetVol) : message.streetVol;
                else
                    object.streetVol = options.longs === String ? $util.Long.prototype.toString.call(message.streetVol) : options.longs === Number ? new $util.LongBits(message.streetVol.low >>> 0, message.streetVol.high >>> 0).toNumber() : message.streetVol;
            if (message.amplitude != null && message.hasOwnProperty("amplitude"))
                object.amplitude = options.json && !isFinite(message.amplitude) ? String(message.amplitude) : message.amplitude;
            if (message.issueSize != null && message.hasOwnProperty("issueSize"))
                if (typeof message.issueSize === "number")
                    object.issueSize = options.longs === String ? String(message.issueSize) : message.issueSize;
                else
                    object.issueSize = options.longs === String ? $util.Long.prototype.toString.call(message.issueSize) : options.longs === Number ? new $util.LongBits(message.issueSize.low >>> 0, message.issueSize.high >>> 0).toNumber() : message.issueSize;
            if (message.highPrice != null && message.hasOwnProperty("highPrice"))
                object.highPrice = options.json && !isFinite(message.highPrice) ? String(message.highPrice) : message.highPrice;
            if (message.lowPrice != null && message.hasOwnProperty("lowPrice"))
                object.lowPrice = options.json && !isFinite(message.lowPrice) ? String(message.lowPrice) : message.lowPrice;
            if (message.impliedVolatility != null && message.hasOwnProperty("impliedVolatility"))
                object.impliedVolatility = options.json && !isFinite(message.impliedVolatility) ? String(message.impliedVolatility) : message.impliedVolatility;
            if (message.delta != null && message.hasOwnProperty("delta"))
                object.delta = options.json && !isFinite(message.delta) ? String(message.delta) : message.delta;
            if (message.effectiveLeverage != null && message.hasOwnProperty("effectiveLeverage"))
                object.effectiveLeverage = options.json && !isFinite(message.effectiveLeverage) ? String(message.effectiveLeverage) : message.effectiveLeverage;
            return object;
        };

        /**
         * Converts this WarrantData to JSON.
         * @function toJSON
         * @memberof Qot_GetWarrant.WarrantData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WarrantData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return WarrantData;
    })();

    Qot_GetWarrant.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_GetWarrant
         * @interface IS2C
         * @property {boolean} lastPage S2C lastPage
         * @property {number} allCount S2C allCount
         * @property {Array.<Qot_GetWarrant.IWarrantData>|null} [warrantDataList] S2C warrantDataList
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_GetWarrant
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_GetWarrant.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.warrantDataList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C lastPage.
         * @member {boolean} lastPage
         * @memberof Qot_GetWarrant.S2C
         * @instance
         */
        S2C.prototype.lastPage = false;

        /**
         * S2C allCount.
         * @member {number} allCount
         * @memberof Qot_GetWarrant.S2C
         * @instance
         */
        S2C.prototype.allCount = 0;

        /**
         * S2C warrantDataList.
         * @member {Array.<Qot_GetWarrant.IWarrantData>} warrantDataList
         * @memberof Qot_GetWarrant.S2C
         * @instance
         */
        S2C.prototype.warrantDataList = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_GetWarrant.S2C
         * @static
         * @param {Qot_GetWarrant.IS2C=} [properties] Properties to set
         * @returns {Qot_GetWarrant.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_GetWarrant.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetWarrant.S2C
         * @static
         * @param {Qot_GetWarrant.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).bool(message.lastPage);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.allCount);
            if (message.warrantDataList != null && message.warrantDataList.length)
                for (var i = 0; i < message.warrantDataList.length; ++i)
                    $root.Qot_GetWarrant.WarrantData.encode(message.warrantDataList[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_GetWarrant.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetWarrant.S2C
         * @static
         * @param {Qot_GetWarrant.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetWarrant.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetWarrant.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetWarrant.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.lastPage = reader.bool();
                    break;
                case 2:
                    message.allCount = reader.int32();
                    break;
                case 3:
                    if (!(message.warrantDataList && message.warrantDataList.length))
                        message.warrantDataList = [];
                    message.warrantDataList.push($root.Qot_GetWarrant.WarrantData.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("lastPage"))
                throw $util.ProtocolError("missing required 'lastPage'", { instance: message });
            if (!message.hasOwnProperty("allCount"))
                throw $util.ProtocolError("missing required 'allCount'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetWarrant.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetWarrant.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_GetWarrant.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (typeof message.lastPage !== "boolean")
                return "lastPage: boolean expected";
            if (!$util.isInteger(message.allCount))
                return "allCount: integer expected";
            if (message.warrantDataList != null && message.hasOwnProperty("warrantDataList")) {
                if (!Array.isArray(message.warrantDataList))
                    return "warrantDataList: array expected";
                for (var i = 0; i < message.warrantDataList.length; ++i) {
                    var error = $root.Qot_GetWarrant.WarrantData.verify(message.warrantDataList[i]);
                    if (error)
                        return "warrantDataList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetWarrant.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetWarrant.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetWarrant.S2C)
                return object;
            var message = new $root.Qot_GetWarrant.S2C();
            if (object.lastPage != null)
                message.lastPage = Boolean(object.lastPage);
            if (object.allCount != null)
                message.allCount = object.allCount | 0;
            if (object.warrantDataList) {
                if (!Array.isArray(object.warrantDataList))
                    throw TypeError(".Qot_GetWarrant.S2C.warrantDataList: array expected");
                message.warrantDataList = [];
                for (var i = 0; i < object.warrantDataList.length; ++i) {
                    if (typeof object.warrantDataList[i] !== "object")
                        throw TypeError(".Qot_GetWarrant.S2C.warrantDataList: object expected");
                    message.warrantDataList[i] = $root.Qot_GetWarrant.WarrantData.fromObject(object.warrantDataList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetWarrant.S2C
         * @static
         * @param {Qot_GetWarrant.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.warrantDataList = [];
            if (options.defaults) {
                object.lastPage = false;
                object.allCount = 0;
            }
            if (message.lastPage != null && message.hasOwnProperty("lastPage"))
                object.lastPage = message.lastPage;
            if (message.allCount != null && message.hasOwnProperty("allCount"))
                object.allCount = message.allCount;
            if (message.warrantDataList && message.warrantDataList.length) {
                object.warrantDataList = [];
                for (var j = 0; j < message.warrantDataList.length; ++j)
                    object.warrantDataList[j] = $root.Qot_GetWarrant.WarrantData.toObject(message.warrantDataList[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_GetWarrant.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_GetWarrant.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Qot_GetWarrant
         * @interface IRequest
         * @property {Qot_GetWarrant.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Qot_GetWarrant
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Qot_GetWarrant.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Qot_GetWarrant.IC2S} c2s
         * @memberof Qot_GetWarrant.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Qot_GetWarrant.Request
         * @static
         * @param {Qot_GetWarrant.IRequest=} [properties] Properties to set
         * @returns {Qot_GetWarrant.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Qot_GetWarrant.Request.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetWarrant.Request
         * @static
         * @param {Qot_GetWarrant.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_GetWarrant.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Qot_GetWarrant.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetWarrant.Request
         * @static
         * @param {Qot_GetWarrant.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetWarrant.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetWarrant.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetWarrant.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Qot_GetWarrant.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetWarrant.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetWarrant.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Qot_GetWarrant.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_GetWarrant.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetWarrant.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetWarrant.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetWarrant.Request)
                return object;
            var message = new $root.Qot_GetWarrant.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Qot_GetWarrant.Request.c2s: object expected");
                message.c2s = $root.Qot_GetWarrant.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetWarrant.Request
         * @static
         * @param {Qot_GetWarrant.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Qot_GetWarrant.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Qot_GetWarrant.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Qot_GetWarrant.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_GetWarrant
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_GetWarrant.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_GetWarrant
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_GetWarrant.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_GetWarrant.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_GetWarrant.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_GetWarrant.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_GetWarrant.IS2C|null|undefined} s2c
         * @memberof Qot_GetWarrant.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_GetWarrant.Response
         * @static
         * @param {Qot_GetWarrant.IResponse=} [properties] Properties to set
         * @returns {Qot_GetWarrant.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_GetWarrant.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_GetWarrant.Response
         * @static
         * @param {Qot_GetWarrant.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_GetWarrant.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_GetWarrant.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_GetWarrant.Response
         * @static
         * @param {Qot_GetWarrant.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_GetWarrant.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_GetWarrant.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_GetWarrant.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_GetWarrant.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_GetWarrant.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_GetWarrant.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_GetWarrant.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_GetWarrant.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_GetWarrant.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_GetWarrant.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_GetWarrant.Response)
                return object;
            var message = new $root.Qot_GetWarrant.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_GetWarrant.Response.s2c: object expected");
                message.s2c = $root.Qot_GetWarrant.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_GetWarrant.Response
         * @static
         * @param {Qot_GetWarrant.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_GetWarrant.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_GetWarrant.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_GetWarrant;
})();

$root.Qot_RegQotPush = (function() {

    /**
     * Namespace Qot_RegQotPush.
     * @exports Qot_RegQotPush
     * @namespace
     */
    var Qot_RegQotPush = {};

    Qot_RegQotPush.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Qot_RegQotPush
         * @interface IC2S
         * @property {Array.<Qot_Common.ISecurity>|null} [securityList] C2S securityList
         * @property {Array.<number>|null} [subTypeList] C2S subTypeList
         * @property {Array.<number>|null} [rehabTypeList] C2S rehabTypeList
         * @property {boolean} isRegOrUnReg C2S isRegOrUnReg
         * @property {boolean|null} [isFirstPush] C2S isFirstPush
         */

        /**
         * Constructs a new C2S.
         * @memberof Qot_RegQotPush
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Qot_RegQotPush.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            this.securityList = [];
            this.subTypeList = [];
            this.rehabTypeList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S securityList.
         * @member {Array.<Qot_Common.ISecurity>} securityList
         * @memberof Qot_RegQotPush.C2S
         * @instance
         */
        C2S.prototype.securityList = $util.emptyArray;

        /**
         * C2S subTypeList.
         * @member {Array.<number>} subTypeList
         * @memberof Qot_RegQotPush.C2S
         * @instance
         */
        C2S.prototype.subTypeList = $util.emptyArray;

        /**
         * C2S rehabTypeList.
         * @member {Array.<number>} rehabTypeList
         * @memberof Qot_RegQotPush.C2S
         * @instance
         */
        C2S.prototype.rehabTypeList = $util.emptyArray;

        /**
         * C2S isRegOrUnReg.
         * @member {boolean} isRegOrUnReg
         * @memberof Qot_RegQotPush.C2S
         * @instance
         */
        C2S.prototype.isRegOrUnReg = false;

        /**
         * C2S isFirstPush.
         * @member {boolean} isFirstPush
         * @memberof Qot_RegQotPush.C2S
         * @instance
         */
        C2S.prototype.isFirstPush = false;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Qot_RegQotPush.C2S
         * @static
         * @param {Qot_RegQotPush.IC2S=} [properties] Properties to set
         * @returns {Qot_RegQotPush.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Qot_RegQotPush.C2S.verify|verify} messages.
         * @function encode
         * @memberof Qot_RegQotPush.C2S
         * @static
         * @param {Qot_RegQotPush.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.securityList != null && message.securityList.length)
                for (var i = 0; i < message.securityList.length; ++i)
                    $root.Qot_Common.Security.encode(message.securityList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.subTypeList != null && message.subTypeList.length)
                for (var i = 0; i < message.subTypeList.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.subTypeList[i]);
            if (message.rehabTypeList != null && message.rehabTypeList.length)
                for (var i = 0; i < message.rehabTypeList.length; ++i)
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.rehabTypeList[i]);
            writer.uint32(/* id 4, wireType 0 =*/32).bool(message.isRegOrUnReg);
            if (message.isFirstPush != null && message.hasOwnProperty("isFirstPush"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.isFirstPush);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Qot_RegQotPush.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_RegQotPush.C2S
         * @static
         * @param {Qot_RegQotPush.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_RegQotPush.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_RegQotPush.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_RegQotPush.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.securityList && message.securityList.length))
                        message.securityList = [];
                    message.securityList.push($root.Qot_Common.Security.decode(reader, reader.uint32()));
                    break;
                case 2:
                    if (!(message.subTypeList && message.subTypeList.length))
                        message.subTypeList = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.subTypeList.push(reader.int32());
                    } else
                        message.subTypeList.push(reader.int32());
                    break;
                case 3:
                    if (!(message.rehabTypeList && message.rehabTypeList.length))
                        message.rehabTypeList = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.rehabTypeList.push(reader.int32());
                    } else
                        message.rehabTypeList.push(reader.int32());
                    break;
                case 4:
                    message.isRegOrUnReg = reader.bool();
                    break;
                case 5:
                    message.isFirstPush = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("isRegOrUnReg"))
                throw $util.ProtocolError("missing required 'isRegOrUnReg'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_RegQotPush.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_RegQotPush.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Qot_RegQotPush.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.securityList != null && message.hasOwnProperty("securityList")) {
                if (!Array.isArray(message.securityList))
                    return "securityList: array expected";
                for (var i = 0; i < message.securityList.length; ++i) {
                    var error = $root.Qot_Common.Security.verify(message.securityList[i]);
                    if (error)
                        return "securityList." + error;
                }
            }
            if (message.subTypeList != null && message.hasOwnProperty("subTypeList")) {
                if (!Array.isArray(message.subTypeList))
                    return "subTypeList: array expected";
                for (var i = 0; i < message.subTypeList.length; ++i)
                    if (!$util.isInteger(message.subTypeList[i]))
                        return "subTypeList: integer[] expected";
            }
            if (message.rehabTypeList != null && message.hasOwnProperty("rehabTypeList")) {
                if (!Array.isArray(message.rehabTypeList))
                    return "rehabTypeList: array expected";
                for (var i = 0; i < message.rehabTypeList.length; ++i)
                    if (!$util.isInteger(message.rehabTypeList[i]))
                        return "rehabTypeList: integer[] expected";
            }
            if (typeof message.isRegOrUnReg !== "boolean")
                return "isRegOrUnReg: boolean expected";
            if (message.isFirstPush != null && message.hasOwnProperty("isFirstPush"))
                if (typeof message.isFirstPush !== "boolean")
                    return "isFirstPush: boolean expected";
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_RegQotPush.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_RegQotPush.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_RegQotPush.C2S)
                return object;
            var message = new $root.Qot_RegQotPush.C2S();
            if (object.securityList) {
                if (!Array.isArray(object.securityList))
                    throw TypeError(".Qot_RegQotPush.C2S.securityList: array expected");
                message.securityList = [];
                for (var i = 0; i < object.securityList.length; ++i) {
                    if (typeof object.securityList[i] !== "object")
                        throw TypeError(".Qot_RegQotPush.C2S.securityList: object expected");
                    message.securityList[i] = $root.Qot_Common.Security.fromObject(object.securityList[i]);
                }
            }
            if (object.subTypeList) {
                if (!Array.isArray(object.subTypeList))
                    throw TypeError(".Qot_RegQotPush.C2S.subTypeList: array expected");
                message.subTypeList = [];
                for (var i = 0; i < object.subTypeList.length; ++i)
                    message.subTypeList[i] = object.subTypeList[i] | 0;
            }
            if (object.rehabTypeList) {
                if (!Array.isArray(object.rehabTypeList))
                    throw TypeError(".Qot_RegQotPush.C2S.rehabTypeList: array expected");
                message.rehabTypeList = [];
                for (var i = 0; i < object.rehabTypeList.length; ++i)
                    message.rehabTypeList[i] = object.rehabTypeList[i] | 0;
            }
            if (object.isRegOrUnReg != null)
                message.isRegOrUnReg = Boolean(object.isRegOrUnReg);
            if (object.isFirstPush != null)
                message.isFirstPush = Boolean(object.isFirstPush);
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_RegQotPush.C2S
         * @static
         * @param {Qot_RegQotPush.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.securityList = [];
                object.subTypeList = [];
                object.rehabTypeList = [];
            }
            if (options.defaults) {
                object.isRegOrUnReg = false;
                object.isFirstPush = false;
            }
            if (message.securityList && message.securityList.length) {
                object.securityList = [];
                for (var j = 0; j < message.securityList.length; ++j)
                    object.securityList[j] = $root.Qot_Common.Security.toObject(message.securityList[j], options);
            }
            if (message.subTypeList && message.subTypeList.length) {
                object.subTypeList = [];
                for (var j = 0; j < message.subTypeList.length; ++j)
                    object.subTypeList[j] = message.subTypeList[j];
            }
            if (message.rehabTypeList && message.rehabTypeList.length) {
                object.rehabTypeList = [];
                for (var j = 0; j < message.rehabTypeList.length; ++j)
                    object.rehabTypeList[j] = message.rehabTypeList[j];
            }
            if (message.isRegOrUnReg != null && message.hasOwnProperty("isRegOrUnReg"))
                object.isRegOrUnReg = message.isRegOrUnReg;
            if (message.isFirstPush != null && message.hasOwnProperty("isFirstPush"))
                object.isFirstPush = message.isFirstPush;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Qot_RegQotPush.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Qot_RegQotPush.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_RegQotPush
         * @interface IS2C
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_RegQotPush
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_RegQotPush.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_RegQotPush.S2C
         * @static
         * @param {Qot_RegQotPush.IS2C=} [properties] Properties to set
         * @returns {Qot_RegQotPush.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_RegQotPush.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_RegQotPush.S2C
         * @static
         * @param {Qot_RegQotPush.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_RegQotPush.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_RegQotPush.S2C
         * @static
         * @param {Qot_RegQotPush.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_RegQotPush.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_RegQotPush.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_RegQotPush.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_RegQotPush.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_RegQotPush.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_RegQotPush.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_RegQotPush.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_RegQotPush.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_RegQotPush.S2C)
                return object;
            return new $root.Qot_RegQotPush.S2C();
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_RegQotPush.S2C
         * @static
         * @param {Qot_RegQotPush.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_RegQotPush.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_RegQotPush.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Qot_RegQotPush
         * @interface IRequest
         * @property {Qot_RegQotPush.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Qot_RegQotPush
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Qot_RegQotPush.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Qot_RegQotPush.IC2S} c2s
         * @memberof Qot_RegQotPush.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Qot_RegQotPush.Request
         * @static
         * @param {Qot_RegQotPush.IRequest=} [properties] Properties to set
         * @returns {Qot_RegQotPush.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Qot_RegQotPush.Request.verify|verify} messages.
         * @function encode
         * @memberof Qot_RegQotPush.Request
         * @static
         * @param {Qot_RegQotPush.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_RegQotPush.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Qot_RegQotPush.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_RegQotPush.Request
         * @static
         * @param {Qot_RegQotPush.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_RegQotPush.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_RegQotPush.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_RegQotPush.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Qot_RegQotPush.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_RegQotPush.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_RegQotPush.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Qot_RegQotPush.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_RegQotPush.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_RegQotPush.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_RegQotPush.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_RegQotPush.Request)
                return object;
            var message = new $root.Qot_RegQotPush.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Qot_RegQotPush.Request.c2s: object expected");
                message.c2s = $root.Qot_RegQotPush.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_RegQotPush.Request
         * @static
         * @param {Qot_RegQotPush.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Qot_RegQotPush.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Qot_RegQotPush.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Qot_RegQotPush.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_RegQotPush
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_RegQotPush.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_RegQotPush
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_RegQotPush.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_RegQotPush.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_RegQotPush.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_RegQotPush.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_RegQotPush.IS2C|null|undefined} s2c
         * @memberof Qot_RegQotPush.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_RegQotPush.Response
         * @static
         * @param {Qot_RegQotPush.IResponse=} [properties] Properties to set
         * @returns {Qot_RegQotPush.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_RegQotPush.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_RegQotPush.Response
         * @static
         * @param {Qot_RegQotPush.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_RegQotPush.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_RegQotPush.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_RegQotPush.Response
         * @static
         * @param {Qot_RegQotPush.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_RegQotPush.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_RegQotPush.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_RegQotPush.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_RegQotPush.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_RegQotPush.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_RegQotPush.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_RegQotPush.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_RegQotPush.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_RegQotPush.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_RegQotPush.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_RegQotPush.Response)
                return object;
            var message = new $root.Qot_RegQotPush.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_RegQotPush.Response.s2c: object expected");
                message.s2c = $root.Qot_RegQotPush.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_RegQotPush.Response
         * @static
         * @param {Qot_RegQotPush.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_RegQotPush.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_RegQotPush.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_RegQotPush;
})();

$root.Qot_RequestHistoryKL = (function() {

    /**
     * Namespace Qot_RequestHistoryKL.
     * @exports Qot_RequestHistoryKL
     * @namespace
     */
    var Qot_RequestHistoryKL = {};

    Qot_RequestHistoryKL.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Qot_RequestHistoryKL
         * @interface IC2S
         * @property {number} rehabType C2S rehabType
         * @property {number} klType C2S klType
         * @property {Qot_Common.ISecurity} security C2S security
         * @property {string} beginTime C2S beginTime
         * @property {string} endTime C2S endTime
         * @property {number|null} [maxAckKLNum] C2S maxAckKLNum
         * @property {number|Long|null} [needKLFieldsFlag] C2S needKLFieldsFlag
         * @property {Uint8Array|null} [nextReqKey] C2S nextReqKey
         */

        /**
         * Constructs a new C2S.
         * @memberof Qot_RequestHistoryKL
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Qot_RequestHistoryKL.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S rehabType.
         * @member {number} rehabType
         * @memberof Qot_RequestHistoryKL.C2S
         * @instance
         */
        C2S.prototype.rehabType = 0;

        /**
         * C2S klType.
         * @member {number} klType
         * @memberof Qot_RequestHistoryKL.C2S
         * @instance
         */
        C2S.prototype.klType = 0;

        /**
         * C2S security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_RequestHistoryKL.C2S
         * @instance
         */
        C2S.prototype.security = null;

        /**
         * C2S beginTime.
         * @member {string} beginTime
         * @memberof Qot_RequestHistoryKL.C2S
         * @instance
         */
        C2S.prototype.beginTime = "";

        /**
         * C2S endTime.
         * @member {string} endTime
         * @memberof Qot_RequestHistoryKL.C2S
         * @instance
         */
        C2S.prototype.endTime = "";

        /**
         * C2S maxAckKLNum.
         * @member {number} maxAckKLNum
         * @memberof Qot_RequestHistoryKL.C2S
         * @instance
         */
        C2S.prototype.maxAckKLNum = 0;

        /**
         * C2S needKLFieldsFlag.
         * @member {number|Long} needKLFieldsFlag
         * @memberof Qot_RequestHistoryKL.C2S
         * @instance
         */
        C2S.prototype.needKLFieldsFlag = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * C2S nextReqKey.
         * @member {Uint8Array} nextReqKey
         * @memberof Qot_RequestHistoryKL.C2S
         * @instance
         */
        C2S.prototype.nextReqKey = $util.newBuffer([]);

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Qot_RequestHistoryKL.C2S
         * @static
         * @param {Qot_RequestHistoryKL.IC2S=} [properties] Properties to set
         * @returns {Qot_RequestHistoryKL.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Qot_RequestHistoryKL.C2S.verify|verify} messages.
         * @function encode
         * @memberof Qot_RequestHistoryKL.C2S
         * @static
         * @param {Qot_RequestHistoryKL.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.rehabType);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.klType);
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.beginTime);
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.endTime);
            if (message.maxAckKLNum != null && message.hasOwnProperty("maxAckKLNum"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.maxAckKLNum);
            if (message.needKLFieldsFlag != null && message.hasOwnProperty("needKLFieldsFlag"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.needKLFieldsFlag);
            if (message.nextReqKey != null && message.hasOwnProperty("nextReqKey"))
                writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.nextReqKey);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Qot_RequestHistoryKL.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_RequestHistoryKL.C2S
         * @static
         * @param {Qot_RequestHistoryKL.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_RequestHistoryKL.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_RequestHistoryKL.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_RequestHistoryKL.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rehabType = reader.int32();
                    break;
                case 2:
                    message.klType = reader.int32();
                    break;
                case 3:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.beginTime = reader.string();
                    break;
                case 5:
                    message.endTime = reader.string();
                    break;
                case 6:
                    message.maxAckKLNum = reader.int32();
                    break;
                case 7:
                    message.needKLFieldsFlag = reader.int64();
                    break;
                case 8:
                    message.nextReqKey = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("rehabType"))
                throw $util.ProtocolError("missing required 'rehabType'", { instance: message });
            if (!message.hasOwnProperty("klType"))
                throw $util.ProtocolError("missing required 'klType'", { instance: message });
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            if (!message.hasOwnProperty("beginTime"))
                throw $util.ProtocolError("missing required 'beginTime'", { instance: message });
            if (!message.hasOwnProperty("endTime"))
                throw $util.ProtocolError("missing required 'endTime'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_RequestHistoryKL.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_RequestHistoryKL.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Qot_RequestHistoryKL.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.rehabType))
                return "rehabType: integer expected";
            if (!$util.isInteger(message.klType))
                return "klType: integer expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            if (!$util.isString(message.beginTime))
                return "beginTime: string expected";
            if (!$util.isString(message.endTime))
                return "endTime: string expected";
            if (message.maxAckKLNum != null && message.hasOwnProperty("maxAckKLNum"))
                if (!$util.isInteger(message.maxAckKLNum))
                    return "maxAckKLNum: integer expected";
            if (message.needKLFieldsFlag != null && message.hasOwnProperty("needKLFieldsFlag"))
                if (!$util.isInteger(message.needKLFieldsFlag) && !(message.needKLFieldsFlag && $util.isInteger(message.needKLFieldsFlag.low) && $util.isInteger(message.needKLFieldsFlag.high)))
                    return "needKLFieldsFlag: integer|Long expected";
            if (message.nextReqKey != null && message.hasOwnProperty("nextReqKey"))
                if (!(message.nextReqKey && typeof message.nextReqKey.length === "number" || $util.isString(message.nextReqKey)))
                    return "nextReqKey: buffer expected";
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_RequestHistoryKL.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_RequestHistoryKL.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_RequestHistoryKL.C2S)
                return object;
            var message = new $root.Qot_RequestHistoryKL.C2S();
            if (object.rehabType != null)
                message.rehabType = object.rehabType | 0;
            if (object.klType != null)
                message.klType = object.klType | 0;
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_RequestHistoryKL.C2S.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            if (object.beginTime != null)
                message.beginTime = String(object.beginTime);
            if (object.endTime != null)
                message.endTime = String(object.endTime);
            if (object.maxAckKLNum != null)
                message.maxAckKLNum = object.maxAckKLNum | 0;
            if (object.needKLFieldsFlag != null)
                if ($util.Long)
                    (message.needKLFieldsFlag = $util.Long.fromValue(object.needKLFieldsFlag)).unsigned = false;
                else if (typeof object.needKLFieldsFlag === "string")
                    message.needKLFieldsFlag = parseInt(object.needKLFieldsFlag, 10);
                else if (typeof object.needKLFieldsFlag === "number")
                    message.needKLFieldsFlag = object.needKLFieldsFlag;
                else if (typeof object.needKLFieldsFlag === "object")
                    message.needKLFieldsFlag = new $util.LongBits(object.needKLFieldsFlag.low >>> 0, object.needKLFieldsFlag.high >>> 0).toNumber();
            if (object.nextReqKey != null)
                if (typeof object.nextReqKey === "string")
                    $util.base64.decode(object.nextReqKey, message.nextReqKey = $util.newBuffer($util.base64.length(object.nextReqKey)), 0);
                else if (object.nextReqKey.length)
                    message.nextReqKey = object.nextReqKey;
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_RequestHistoryKL.C2S
         * @static
         * @param {Qot_RequestHistoryKL.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.rehabType = 0;
                object.klType = 0;
                object.security = null;
                object.beginTime = "";
                object.endTime = "";
                object.maxAckKLNum = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.needKLFieldsFlag = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.needKLFieldsFlag = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.nextReqKey = "";
                else {
                    object.nextReqKey = [];
                    if (options.bytes !== Array)
                        object.nextReqKey = $util.newBuffer(object.nextReqKey);
                }
            }
            if (message.rehabType != null && message.hasOwnProperty("rehabType"))
                object.rehabType = message.rehabType;
            if (message.klType != null && message.hasOwnProperty("klType"))
                object.klType = message.klType;
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            if (message.beginTime != null && message.hasOwnProperty("beginTime"))
                object.beginTime = message.beginTime;
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                object.endTime = message.endTime;
            if (message.maxAckKLNum != null && message.hasOwnProperty("maxAckKLNum"))
                object.maxAckKLNum = message.maxAckKLNum;
            if (message.needKLFieldsFlag != null && message.hasOwnProperty("needKLFieldsFlag"))
                if (typeof message.needKLFieldsFlag === "number")
                    object.needKLFieldsFlag = options.longs === String ? String(message.needKLFieldsFlag) : message.needKLFieldsFlag;
                else
                    object.needKLFieldsFlag = options.longs === String ? $util.Long.prototype.toString.call(message.needKLFieldsFlag) : options.longs === Number ? new $util.LongBits(message.needKLFieldsFlag.low >>> 0, message.needKLFieldsFlag.high >>> 0).toNumber() : message.needKLFieldsFlag;
            if (message.nextReqKey != null && message.hasOwnProperty("nextReqKey"))
                object.nextReqKey = options.bytes === String ? $util.base64.encode(message.nextReqKey, 0, message.nextReqKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.nextReqKey) : message.nextReqKey;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Qot_RequestHistoryKL.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Qot_RequestHistoryKL.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_RequestHistoryKL
         * @interface IS2C
         * @property {Qot_Common.ISecurity} security S2C security
         * @property {Array.<Qot_Common.IKLine>|null} [klList] S2C klList
         * @property {Uint8Array|null} [nextReqKey] S2C nextReqKey
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_RequestHistoryKL
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_RequestHistoryKL.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.klList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_RequestHistoryKL.S2C
         * @instance
         */
        S2C.prototype.security = null;

        /**
         * S2C klList.
         * @member {Array.<Qot_Common.IKLine>} klList
         * @memberof Qot_RequestHistoryKL.S2C
         * @instance
         */
        S2C.prototype.klList = $util.emptyArray;

        /**
         * S2C nextReqKey.
         * @member {Uint8Array} nextReqKey
         * @memberof Qot_RequestHistoryKL.S2C
         * @instance
         */
        S2C.prototype.nextReqKey = $util.newBuffer([]);

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_RequestHistoryKL.S2C
         * @static
         * @param {Qot_RequestHistoryKL.IS2C=} [properties] Properties to set
         * @returns {Qot_RequestHistoryKL.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_RequestHistoryKL.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_RequestHistoryKL.S2C
         * @static
         * @param {Qot_RequestHistoryKL.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.klList != null && message.klList.length)
                for (var i = 0; i < message.klList.length; ++i)
                    $root.Qot_Common.KLine.encode(message.klList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.nextReqKey != null && message.hasOwnProperty("nextReqKey"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.nextReqKey);
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_RequestHistoryKL.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_RequestHistoryKL.S2C
         * @static
         * @param {Qot_RequestHistoryKL.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_RequestHistoryKL.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_RequestHistoryKL.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_RequestHistoryKL.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.klList && message.klList.length))
                        message.klList = [];
                    message.klList.push($root.Qot_Common.KLine.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.nextReqKey = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_RequestHistoryKL.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_RequestHistoryKL.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_RequestHistoryKL.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            if (message.klList != null && message.hasOwnProperty("klList")) {
                if (!Array.isArray(message.klList))
                    return "klList: array expected";
                for (var i = 0; i < message.klList.length; ++i) {
                    var error = $root.Qot_Common.KLine.verify(message.klList[i]);
                    if (error)
                        return "klList." + error;
                }
            }
            if (message.nextReqKey != null && message.hasOwnProperty("nextReqKey"))
                if (!(message.nextReqKey && typeof message.nextReqKey.length === "number" || $util.isString(message.nextReqKey)))
                    return "nextReqKey: buffer expected";
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_RequestHistoryKL.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_RequestHistoryKL.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_RequestHistoryKL.S2C)
                return object;
            var message = new $root.Qot_RequestHistoryKL.S2C();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_RequestHistoryKL.S2C.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            if (object.klList) {
                if (!Array.isArray(object.klList))
                    throw TypeError(".Qot_RequestHistoryKL.S2C.klList: array expected");
                message.klList = [];
                for (var i = 0; i < object.klList.length; ++i) {
                    if (typeof object.klList[i] !== "object")
                        throw TypeError(".Qot_RequestHistoryKL.S2C.klList: object expected");
                    message.klList[i] = $root.Qot_Common.KLine.fromObject(object.klList[i]);
                }
            }
            if (object.nextReqKey != null)
                if (typeof object.nextReqKey === "string")
                    $util.base64.decode(object.nextReqKey, message.nextReqKey = $util.newBuffer($util.base64.length(object.nextReqKey)), 0);
                else if (object.nextReqKey.length)
                    message.nextReqKey = object.nextReqKey;
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_RequestHistoryKL.S2C
         * @static
         * @param {Qot_RequestHistoryKL.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.klList = [];
            if (options.defaults) {
                object.security = null;
                if (options.bytes === String)
                    object.nextReqKey = "";
                else {
                    object.nextReqKey = [];
                    if (options.bytes !== Array)
                        object.nextReqKey = $util.newBuffer(object.nextReqKey);
                }
            }
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            if (message.klList && message.klList.length) {
                object.klList = [];
                for (var j = 0; j < message.klList.length; ++j)
                    object.klList[j] = $root.Qot_Common.KLine.toObject(message.klList[j], options);
            }
            if (message.nextReqKey != null && message.hasOwnProperty("nextReqKey"))
                object.nextReqKey = options.bytes === String ? $util.base64.encode(message.nextReqKey, 0, message.nextReqKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.nextReqKey) : message.nextReqKey;
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_RequestHistoryKL.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_RequestHistoryKL.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Qot_RequestHistoryKL
         * @interface IRequest
         * @property {Qot_RequestHistoryKL.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Qot_RequestHistoryKL
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Qot_RequestHistoryKL.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Qot_RequestHistoryKL.IC2S} c2s
         * @memberof Qot_RequestHistoryKL.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Qot_RequestHistoryKL.Request
         * @static
         * @param {Qot_RequestHistoryKL.IRequest=} [properties] Properties to set
         * @returns {Qot_RequestHistoryKL.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Qot_RequestHistoryKL.Request.verify|verify} messages.
         * @function encode
         * @memberof Qot_RequestHistoryKL.Request
         * @static
         * @param {Qot_RequestHistoryKL.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_RequestHistoryKL.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Qot_RequestHistoryKL.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_RequestHistoryKL.Request
         * @static
         * @param {Qot_RequestHistoryKL.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_RequestHistoryKL.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_RequestHistoryKL.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_RequestHistoryKL.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Qot_RequestHistoryKL.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_RequestHistoryKL.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_RequestHistoryKL.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Qot_RequestHistoryKL.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_RequestHistoryKL.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_RequestHistoryKL.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_RequestHistoryKL.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_RequestHistoryKL.Request)
                return object;
            var message = new $root.Qot_RequestHistoryKL.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Qot_RequestHistoryKL.Request.c2s: object expected");
                message.c2s = $root.Qot_RequestHistoryKL.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_RequestHistoryKL.Request
         * @static
         * @param {Qot_RequestHistoryKL.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Qot_RequestHistoryKL.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Qot_RequestHistoryKL.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Qot_RequestHistoryKL.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_RequestHistoryKL
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_RequestHistoryKL.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_RequestHistoryKL
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_RequestHistoryKL.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_RequestHistoryKL.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_RequestHistoryKL.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_RequestHistoryKL.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_RequestHistoryKL.IS2C|null|undefined} s2c
         * @memberof Qot_RequestHistoryKL.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_RequestHistoryKL.Response
         * @static
         * @param {Qot_RequestHistoryKL.IResponse=} [properties] Properties to set
         * @returns {Qot_RequestHistoryKL.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_RequestHistoryKL.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_RequestHistoryKL.Response
         * @static
         * @param {Qot_RequestHistoryKL.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_RequestHistoryKL.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_RequestHistoryKL.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_RequestHistoryKL.Response
         * @static
         * @param {Qot_RequestHistoryKL.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_RequestHistoryKL.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_RequestHistoryKL.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_RequestHistoryKL.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_RequestHistoryKL.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_RequestHistoryKL.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_RequestHistoryKL.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_RequestHistoryKL.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_RequestHistoryKL.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_RequestHistoryKL.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_RequestHistoryKL.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_RequestHistoryKL.Response)
                return object;
            var message = new $root.Qot_RequestHistoryKL.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_RequestHistoryKL.Response.s2c: object expected");
                message.s2c = $root.Qot_RequestHistoryKL.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_RequestHistoryKL.Response
         * @static
         * @param {Qot_RequestHistoryKL.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_RequestHistoryKL.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_RequestHistoryKL.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_RequestHistoryKL;
})();

$root.Qot_RequestHistoryKLQuota = (function() {

    /**
     * Namespace Qot_RequestHistoryKLQuota.
     * @exports Qot_RequestHistoryKLQuota
     * @namespace
     */
    var Qot_RequestHistoryKLQuota = {};

    Qot_RequestHistoryKLQuota.DetailItem = (function() {

        /**
         * Properties of a DetailItem.
         * @memberof Qot_RequestHistoryKLQuota
         * @interface IDetailItem
         * @property {Qot_Common.ISecurity} security DetailItem security
         * @property {string} requestTime DetailItem requestTime
         * @property {number|Long|null} [requestTimeStamp] DetailItem requestTimeStamp
         */

        /**
         * Constructs a new DetailItem.
         * @memberof Qot_RequestHistoryKLQuota
         * @classdesc Represents a DetailItem.
         * @implements IDetailItem
         * @constructor
         * @param {Qot_RequestHistoryKLQuota.IDetailItem=} [properties] Properties to set
         */
        function DetailItem(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DetailItem security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_RequestHistoryKLQuota.DetailItem
         * @instance
         */
        DetailItem.prototype.security = null;

        /**
         * DetailItem requestTime.
         * @member {string} requestTime
         * @memberof Qot_RequestHistoryKLQuota.DetailItem
         * @instance
         */
        DetailItem.prototype.requestTime = "";

        /**
         * DetailItem requestTimeStamp.
         * @member {number|Long} requestTimeStamp
         * @memberof Qot_RequestHistoryKLQuota.DetailItem
         * @instance
         */
        DetailItem.prototype.requestTimeStamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new DetailItem instance using the specified properties.
         * @function create
         * @memberof Qot_RequestHistoryKLQuota.DetailItem
         * @static
         * @param {Qot_RequestHistoryKLQuota.IDetailItem=} [properties] Properties to set
         * @returns {Qot_RequestHistoryKLQuota.DetailItem} DetailItem instance
         */
        DetailItem.create = function create(properties) {
            return new DetailItem(properties);
        };

        /**
         * Encodes the specified DetailItem message. Does not implicitly {@link Qot_RequestHistoryKLQuota.DetailItem.verify|verify} messages.
         * @function encode
         * @memberof Qot_RequestHistoryKLQuota.DetailItem
         * @static
         * @param {Qot_RequestHistoryKLQuota.IDetailItem} message DetailItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DetailItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.requestTime);
            if (message.requestTimeStamp != null && message.hasOwnProperty("requestTimeStamp"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.requestTimeStamp);
            return writer;
        };

        /**
         * Encodes the specified DetailItem message, length delimited. Does not implicitly {@link Qot_RequestHistoryKLQuota.DetailItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_RequestHistoryKLQuota.DetailItem
         * @static
         * @param {Qot_RequestHistoryKLQuota.IDetailItem} message DetailItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DetailItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DetailItem message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_RequestHistoryKLQuota.DetailItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_RequestHistoryKLQuota.DetailItem} DetailItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DetailItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_RequestHistoryKLQuota.DetailItem();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.requestTime = reader.string();
                    break;
                case 3:
                    message.requestTimeStamp = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            if (!message.hasOwnProperty("requestTime"))
                throw $util.ProtocolError("missing required 'requestTime'", { instance: message });
            return message;
        };

        /**
         * Decodes a DetailItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_RequestHistoryKLQuota.DetailItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_RequestHistoryKLQuota.DetailItem} DetailItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DetailItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DetailItem message.
         * @function verify
         * @memberof Qot_RequestHistoryKLQuota.DetailItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DetailItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            if (!$util.isString(message.requestTime))
                return "requestTime: string expected";
            if (message.requestTimeStamp != null && message.hasOwnProperty("requestTimeStamp"))
                if (!$util.isInteger(message.requestTimeStamp) && !(message.requestTimeStamp && $util.isInteger(message.requestTimeStamp.low) && $util.isInteger(message.requestTimeStamp.high)))
                    return "requestTimeStamp: integer|Long expected";
            return null;
        };

        /**
         * Creates a DetailItem message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_RequestHistoryKLQuota.DetailItem
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_RequestHistoryKLQuota.DetailItem} DetailItem
         */
        DetailItem.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_RequestHistoryKLQuota.DetailItem)
                return object;
            var message = new $root.Qot_RequestHistoryKLQuota.DetailItem();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_RequestHistoryKLQuota.DetailItem.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            if (object.requestTime != null)
                message.requestTime = String(object.requestTime);
            if (object.requestTimeStamp != null)
                if ($util.Long)
                    (message.requestTimeStamp = $util.Long.fromValue(object.requestTimeStamp)).unsigned = false;
                else if (typeof object.requestTimeStamp === "string")
                    message.requestTimeStamp = parseInt(object.requestTimeStamp, 10);
                else if (typeof object.requestTimeStamp === "number")
                    message.requestTimeStamp = object.requestTimeStamp;
                else if (typeof object.requestTimeStamp === "object")
                    message.requestTimeStamp = new $util.LongBits(object.requestTimeStamp.low >>> 0, object.requestTimeStamp.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a DetailItem message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_RequestHistoryKLQuota.DetailItem
         * @static
         * @param {Qot_RequestHistoryKLQuota.DetailItem} message DetailItem
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DetailItem.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.security = null;
                object.requestTime = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.requestTimeStamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.requestTimeStamp = options.longs === String ? "0" : 0;
            }
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            if (message.requestTime != null && message.hasOwnProperty("requestTime"))
                object.requestTime = message.requestTime;
            if (message.requestTimeStamp != null && message.hasOwnProperty("requestTimeStamp"))
                if (typeof message.requestTimeStamp === "number")
                    object.requestTimeStamp = options.longs === String ? String(message.requestTimeStamp) : message.requestTimeStamp;
                else
                    object.requestTimeStamp = options.longs === String ? $util.Long.prototype.toString.call(message.requestTimeStamp) : options.longs === Number ? new $util.LongBits(message.requestTimeStamp.low >>> 0, message.requestTimeStamp.high >>> 0).toNumber() : message.requestTimeStamp;
            return object;
        };

        /**
         * Converts this DetailItem to JSON.
         * @function toJSON
         * @memberof Qot_RequestHistoryKLQuota.DetailItem
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DetailItem.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DetailItem;
    })();

    Qot_RequestHistoryKLQuota.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Qot_RequestHistoryKLQuota
         * @interface IC2S
         * @property {boolean|null} [bGetDetail] C2S bGetDetail
         */

        /**
         * Constructs a new C2S.
         * @memberof Qot_RequestHistoryKLQuota
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Qot_RequestHistoryKLQuota.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S bGetDetail.
         * @member {boolean} bGetDetail
         * @memberof Qot_RequestHistoryKLQuota.C2S
         * @instance
         */
        C2S.prototype.bGetDetail = false;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Qot_RequestHistoryKLQuota.C2S
         * @static
         * @param {Qot_RequestHistoryKLQuota.IC2S=} [properties] Properties to set
         * @returns {Qot_RequestHistoryKLQuota.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Qot_RequestHistoryKLQuota.C2S.verify|verify} messages.
         * @function encode
         * @memberof Qot_RequestHistoryKLQuota.C2S
         * @static
         * @param {Qot_RequestHistoryKLQuota.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.bGetDetail != null && message.hasOwnProperty("bGetDetail"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.bGetDetail);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Qot_RequestHistoryKLQuota.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_RequestHistoryKLQuota.C2S
         * @static
         * @param {Qot_RequestHistoryKLQuota.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_RequestHistoryKLQuota.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_RequestHistoryKLQuota.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_RequestHistoryKLQuota.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 2:
                    message.bGetDetail = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_RequestHistoryKLQuota.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_RequestHistoryKLQuota.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Qot_RequestHistoryKLQuota.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.bGetDetail != null && message.hasOwnProperty("bGetDetail"))
                if (typeof message.bGetDetail !== "boolean")
                    return "bGetDetail: boolean expected";
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_RequestHistoryKLQuota.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_RequestHistoryKLQuota.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_RequestHistoryKLQuota.C2S)
                return object;
            var message = new $root.Qot_RequestHistoryKLQuota.C2S();
            if (object.bGetDetail != null)
                message.bGetDetail = Boolean(object.bGetDetail);
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_RequestHistoryKLQuota.C2S
         * @static
         * @param {Qot_RequestHistoryKLQuota.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.bGetDetail = false;
            if (message.bGetDetail != null && message.hasOwnProperty("bGetDetail"))
                object.bGetDetail = message.bGetDetail;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Qot_RequestHistoryKLQuota.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Qot_RequestHistoryKLQuota.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_RequestHistoryKLQuota
         * @interface IS2C
         * @property {number} usedQuota S2C usedQuota
         * @property {number} remainQuota S2C remainQuota
         * @property {Array.<Qot_RequestHistoryKLQuota.IDetailItem>|null} [detailList] S2C detailList
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_RequestHistoryKLQuota
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_RequestHistoryKLQuota.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.detailList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C usedQuota.
         * @member {number} usedQuota
         * @memberof Qot_RequestHistoryKLQuota.S2C
         * @instance
         */
        S2C.prototype.usedQuota = 0;

        /**
         * S2C remainQuota.
         * @member {number} remainQuota
         * @memberof Qot_RequestHistoryKLQuota.S2C
         * @instance
         */
        S2C.prototype.remainQuota = 0;

        /**
         * S2C detailList.
         * @member {Array.<Qot_RequestHistoryKLQuota.IDetailItem>} detailList
         * @memberof Qot_RequestHistoryKLQuota.S2C
         * @instance
         */
        S2C.prototype.detailList = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_RequestHistoryKLQuota.S2C
         * @static
         * @param {Qot_RequestHistoryKLQuota.IS2C=} [properties] Properties to set
         * @returns {Qot_RequestHistoryKLQuota.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_RequestHistoryKLQuota.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_RequestHistoryKLQuota.S2C
         * @static
         * @param {Qot_RequestHistoryKLQuota.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.usedQuota);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.remainQuota);
            if (message.detailList != null && message.detailList.length)
                for (var i = 0; i < message.detailList.length; ++i)
                    $root.Qot_RequestHistoryKLQuota.DetailItem.encode(message.detailList[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_RequestHistoryKLQuota.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_RequestHistoryKLQuota.S2C
         * @static
         * @param {Qot_RequestHistoryKLQuota.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_RequestHistoryKLQuota.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_RequestHistoryKLQuota.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_RequestHistoryKLQuota.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.usedQuota = reader.int32();
                    break;
                case 2:
                    message.remainQuota = reader.int32();
                    break;
                case 3:
                    if (!(message.detailList && message.detailList.length))
                        message.detailList = [];
                    message.detailList.push($root.Qot_RequestHistoryKLQuota.DetailItem.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("usedQuota"))
                throw $util.ProtocolError("missing required 'usedQuota'", { instance: message });
            if (!message.hasOwnProperty("remainQuota"))
                throw $util.ProtocolError("missing required 'remainQuota'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_RequestHistoryKLQuota.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_RequestHistoryKLQuota.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_RequestHistoryKLQuota.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.usedQuota))
                return "usedQuota: integer expected";
            if (!$util.isInteger(message.remainQuota))
                return "remainQuota: integer expected";
            if (message.detailList != null && message.hasOwnProperty("detailList")) {
                if (!Array.isArray(message.detailList))
                    return "detailList: array expected";
                for (var i = 0; i < message.detailList.length; ++i) {
                    var error = $root.Qot_RequestHistoryKLQuota.DetailItem.verify(message.detailList[i]);
                    if (error)
                        return "detailList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_RequestHistoryKLQuota.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_RequestHistoryKLQuota.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_RequestHistoryKLQuota.S2C)
                return object;
            var message = new $root.Qot_RequestHistoryKLQuota.S2C();
            if (object.usedQuota != null)
                message.usedQuota = object.usedQuota | 0;
            if (object.remainQuota != null)
                message.remainQuota = object.remainQuota | 0;
            if (object.detailList) {
                if (!Array.isArray(object.detailList))
                    throw TypeError(".Qot_RequestHistoryKLQuota.S2C.detailList: array expected");
                message.detailList = [];
                for (var i = 0; i < object.detailList.length; ++i) {
                    if (typeof object.detailList[i] !== "object")
                        throw TypeError(".Qot_RequestHistoryKLQuota.S2C.detailList: object expected");
                    message.detailList[i] = $root.Qot_RequestHistoryKLQuota.DetailItem.fromObject(object.detailList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_RequestHistoryKLQuota.S2C
         * @static
         * @param {Qot_RequestHistoryKLQuota.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.detailList = [];
            if (options.defaults) {
                object.usedQuota = 0;
                object.remainQuota = 0;
            }
            if (message.usedQuota != null && message.hasOwnProperty("usedQuota"))
                object.usedQuota = message.usedQuota;
            if (message.remainQuota != null && message.hasOwnProperty("remainQuota"))
                object.remainQuota = message.remainQuota;
            if (message.detailList && message.detailList.length) {
                object.detailList = [];
                for (var j = 0; j < message.detailList.length; ++j)
                    object.detailList[j] = $root.Qot_RequestHistoryKLQuota.DetailItem.toObject(message.detailList[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_RequestHistoryKLQuota.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_RequestHistoryKLQuota.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Qot_RequestHistoryKLQuota
         * @interface IRequest
         * @property {Qot_RequestHistoryKLQuota.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Qot_RequestHistoryKLQuota
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Qot_RequestHistoryKLQuota.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Qot_RequestHistoryKLQuota.IC2S} c2s
         * @memberof Qot_RequestHistoryKLQuota.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Qot_RequestHistoryKLQuota.Request
         * @static
         * @param {Qot_RequestHistoryKLQuota.IRequest=} [properties] Properties to set
         * @returns {Qot_RequestHistoryKLQuota.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Qot_RequestHistoryKLQuota.Request.verify|verify} messages.
         * @function encode
         * @memberof Qot_RequestHistoryKLQuota.Request
         * @static
         * @param {Qot_RequestHistoryKLQuota.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_RequestHistoryKLQuota.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Qot_RequestHistoryKLQuota.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_RequestHistoryKLQuota.Request
         * @static
         * @param {Qot_RequestHistoryKLQuota.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_RequestHistoryKLQuota.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_RequestHistoryKLQuota.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_RequestHistoryKLQuota.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Qot_RequestHistoryKLQuota.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_RequestHistoryKLQuota.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_RequestHistoryKLQuota.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Qot_RequestHistoryKLQuota.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_RequestHistoryKLQuota.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_RequestHistoryKLQuota.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_RequestHistoryKLQuota.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_RequestHistoryKLQuota.Request)
                return object;
            var message = new $root.Qot_RequestHistoryKLQuota.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Qot_RequestHistoryKLQuota.Request.c2s: object expected");
                message.c2s = $root.Qot_RequestHistoryKLQuota.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_RequestHistoryKLQuota.Request
         * @static
         * @param {Qot_RequestHistoryKLQuota.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Qot_RequestHistoryKLQuota.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Qot_RequestHistoryKLQuota.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Qot_RequestHistoryKLQuota.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_RequestHistoryKLQuota
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_RequestHistoryKLQuota.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_RequestHistoryKLQuota
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_RequestHistoryKLQuota.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_RequestHistoryKLQuota.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_RequestHistoryKLQuota.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_RequestHistoryKLQuota.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_RequestHistoryKLQuota.IS2C|null|undefined} s2c
         * @memberof Qot_RequestHistoryKLQuota.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_RequestHistoryKLQuota.Response
         * @static
         * @param {Qot_RequestHistoryKLQuota.IResponse=} [properties] Properties to set
         * @returns {Qot_RequestHistoryKLQuota.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_RequestHistoryKLQuota.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_RequestHistoryKLQuota.Response
         * @static
         * @param {Qot_RequestHistoryKLQuota.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_RequestHistoryKLQuota.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_RequestHistoryKLQuota.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_RequestHistoryKLQuota.Response
         * @static
         * @param {Qot_RequestHistoryKLQuota.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_RequestHistoryKLQuota.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_RequestHistoryKLQuota.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_RequestHistoryKLQuota.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_RequestHistoryKLQuota.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_RequestHistoryKLQuota.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_RequestHistoryKLQuota.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_RequestHistoryKLQuota.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_RequestHistoryKLQuota.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_RequestHistoryKLQuota.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_RequestHistoryKLQuota.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_RequestHistoryKLQuota.Response)
                return object;
            var message = new $root.Qot_RequestHistoryKLQuota.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_RequestHistoryKLQuota.Response.s2c: object expected");
                message.s2c = $root.Qot_RequestHistoryKLQuota.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_RequestHistoryKLQuota.Response
         * @static
         * @param {Qot_RequestHistoryKLQuota.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_RequestHistoryKLQuota.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_RequestHistoryKLQuota.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_RequestHistoryKLQuota;
})();

$root.Qot_RequestRehab = (function() {

    /**
     * Namespace Qot_RequestRehab.
     * @exports Qot_RequestRehab
     * @namespace
     */
    var Qot_RequestRehab = {};

    Qot_RequestRehab.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Qot_RequestRehab
         * @interface IC2S
         * @property {Qot_Common.ISecurity} security C2S security
         */

        /**
         * Constructs a new C2S.
         * @memberof Qot_RequestRehab
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Qot_RequestRehab.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_RequestRehab.C2S
         * @instance
         */
        C2S.prototype.security = null;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Qot_RequestRehab.C2S
         * @static
         * @param {Qot_RequestRehab.IC2S=} [properties] Properties to set
         * @returns {Qot_RequestRehab.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Qot_RequestRehab.C2S.verify|verify} messages.
         * @function encode
         * @memberof Qot_RequestRehab.C2S
         * @static
         * @param {Qot_RequestRehab.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Qot_RequestRehab.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_RequestRehab.C2S
         * @static
         * @param {Qot_RequestRehab.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_RequestRehab.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_RequestRehab.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_RequestRehab.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_RequestRehab.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_RequestRehab.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Qot_RequestRehab.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_RequestRehab.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_RequestRehab.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_RequestRehab.C2S)
                return object;
            var message = new $root.Qot_RequestRehab.C2S();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_RequestRehab.C2S.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_RequestRehab.C2S
         * @static
         * @param {Qot_RequestRehab.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.security = null;
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Qot_RequestRehab.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Qot_RequestRehab.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_RequestRehab
         * @interface IS2C
         * @property {Array.<Qot_Common.IRehab>|null} [rehabList] S2C rehabList
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_RequestRehab
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_RequestRehab.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.rehabList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C rehabList.
         * @member {Array.<Qot_Common.IRehab>} rehabList
         * @memberof Qot_RequestRehab.S2C
         * @instance
         */
        S2C.prototype.rehabList = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_RequestRehab.S2C
         * @static
         * @param {Qot_RequestRehab.IS2C=} [properties] Properties to set
         * @returns {Qot_RequestRehab.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_RequestRehab.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_RequestRehab.S2C
         * @static
         * @param {Qot_RequestRehab.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rehabList != null && message.rehabList.length)
                for (var i = 0; i < message.rehabList.length; ++i)
                    $root.Qot_Common.Rehab.encode(message.rehabList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_RequestRehab.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_RequestRehab.S2C
         * @static
         * @param {Qot_RequestRehab.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_RequestRehab.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_RequestRehab.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_RequestRehab.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.rehabList && message.rehabList.length))
                        message.rehabList = [];
                    message.rehabList.push($root.Qot_Common.Rehab.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_RequestRehab.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_RequestRehab.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_RequestRehab.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.rehabList != null && message.hasOwnProperty("rehabList")) {
                if (!Array.isArray(message.rehabList))
                    return "rehabList: array expected";
                for (var i = 0; i < message.rehabList.length; ++i) {
                    var error = $root.Qot_Common.Rehab.verify(message.rehabList[i]);
                    if (error)
                        return "rehabList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_RequestRehab.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_RequestRehab.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_RequestRehab.S2C)
                return object;
            var message = new $root.Qot_RequestRehab.S2C();
            if (object.rehabList) {
                if (!Array.isArray(object.rehabList))
                    throw TypeError(".Qot_RequestRehab.S2C.rehabList: array expected");
                message.rehabList = [];
                for (var i = 0; i < object.rehabList.length; ++i) {
                    if (typeof object.rehabList[i] !== "object")
                        throw TypeError(".Qot_RequestRehab.S2C.rehabList: object expected");
                    message.rehabList[i] = $root.Qot_Common.Rehab.fromObject(object.rehabList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_RequestRehab.S2C
         * @static
         * @param {Qot_RequestRehab.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.rehabList = [];
            if (message.rehabList && message.rehabList.length) {
                object.rehabList = [];
                for (var j = 0; j < message.rehabList.length; ++j)
                    object.rehabList[j] = $root.Qot_Common.Rehab.toObject(message.rehabList[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_RequestRehab.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_RequestRehab.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Qot_RequestRehab
         * @interface IRequest
         * @property {Qot_RequestRehab.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Qot_RequestRehab
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Qot_RequestRehab.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Qot_RequestRehab.IC2S} c2s
         * @memberof Qot_RequestRehab.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Qot_RequestRehab.Request
         * @static
         * @param {Qot_RequestRehab.IRequest=} [properties] Properties to set
         * @returns {Qot_RequestRehab.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Qot_RequestRehab.Request.verify|verify} messages.
         * @function encode
         * @memberof Qot_RequestRehab.Request
         * @static
         * @param {Qot_RequestRehab.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_RequestRehab.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Qot_RequestRehab.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_RequestRehab.Request
         * @static
         * @param {Qot_RequestRehab.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_RequestRehab.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_RequestRehab.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_RequestRehab.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Qot_RequestRehab.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_RequestRehab.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_RequestRehab.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Qot_RequestRehab.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_RequestRehab.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_RequestRehab.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_RequestRehab.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_RequestRehab.Request)
                return object;
            var message = new $root.Qot_RequestRehab.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Qot_RequestRehab.Request.c2s: object expected");
                message.c2s = $root.Qot_RequestRehab.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_RequestRehab.Request
         * @static
         * @param {Qot_RequestRehab.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Qot_RequestRehab.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Qot_RequestRehab.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Qot_RequestRehab.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_RequestRehab
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_RequestRehab.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_RequestRehab
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_RequestRehab.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_RequestRehab.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_RequestRehab.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_RequestRehab.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_RequestRehab.IS2C|null|undefined} s2c
         * @memberof Qot_RequestRehab.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_RequestRehab.Response
         * @static
         * @param {Qot_RequestRehab.IResponse=} [properties] Properties to set
         * @returns {Qot_RequestRehab.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_RequestRehab.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_RequestRehab.Response
         * @static
         * @param {Qot_RequestRehab.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_RequestRehab.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_RequestRehab.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_RequestRehab.Response
         * @static
         * @param {Qot_RequestRehab.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_RequestRehab.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_RequestRehab.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_RequestRehab.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_RequestRehab.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_RequestRehab.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_RequestRehab.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_RequestRehab.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_RequestRehab.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_RequestRehab.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_RequestRehab.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_RequestRehab.Response)
                return object;
            var message = new $root.Qot_RequestRehab.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_RequestRehab.Response.s2c: object expected");
                message.s2c = $root.Qot_RequestRehab.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_RequestRehab.Response
         * @static
         * @param {Qot_RequestRehab.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_RequestRehab.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_RequestRehab.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_RequestRehab;
})();

$root.Qot_Sub = (function() {

    /**
     * Namespace Qot_Sub.
     * @exports Qot_Sub
     * @namespace
     */
    var Qot_Sub = {};

    Qot_Sub.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Qot_Sub
         * @interface IC2S
         * @property {Array.<Qot_Common.ISecurity>|null} [securityList] C2S securityList
         * @property {Array.<number>|null} [subTypeList] C2S subTypeList
         * @property {boolean} isSubOrUnSub C2S isSubOrUnSub
         * @property {boolean|null} [isRegOrUnRegPush] C2S isRegOrUnRegPush
         * @property {Array.<number>|null} [regPushRehabTypeList] C2S regPushRehabTypeList
         * @property {boolean|null} [isFirstPush] C2S isFirstPush
         */

        /**
         * Constructs a new C2S.
         * @memberof Qot_Sub
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Qot_Sub.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            this.securityList = [];
            this.subTypeList = [];
            this.regPushRehabTypeList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S securityList.
         * @member {Array.<Qot_Common.ISecurity>} securityList
         * @memberof Qot_Sub.C2S
         * @instance
         */
        C2S.prototype.securityList = $util.emptyArray;

        /**
         * C2S subTypeList.
         * @member {Array.<number>} subTypeList
         * @memberof Qot_Sub.C2S
         * @instance
         */
        C2S.prototype.subTypeList = $util.emptyArray;

        /**
         * C2S isSubOrUnSub.
         * @member {boolean} isSubOrUnSub
         * @memberof Qot_Sub.C2S
         * @instance
         */
        C2S.prototype.isSubOrUnSub = false;

        /**
         * C2S isRegOrUnRegPush.
         * @member {boolean} isRegOrUnRegPush
         * @memberof Qot_Sub.C2S
         * @instance
         */
        C2S.prototype.isRegOrUnRegPush = false;

        /**
         * C2S regPushRehabTypeList.
         * @member {Array.<number>} regPushRehabTypeList
         * @memberof Qot_Sub.C2S
         * @instance
         */
        C2S.prototype.regPushRehabTypeList = $util.emptyArray;

        /**
         * C2S isFirstPush.
         * @member {boolean} isFirstPush
         * @memberof Qot_Sub.C2S
         * @instance
         */
        C2S.prototype.isFirstPush = false;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Qot_Sub.C2S
         * @static
         * @param {Qot_Sub.IC2S=} [properties] Properties to set
         * @returns {Qot_Sub.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Qot_Sub.C2S.verify|verify} messages.
         * @function encode
         * @memberof Qot_Sub.C2S
         * @static
         * @param {Qot_Sub.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.securityList != null && message.securityList.length)
                for (var i = 0; i < message.securityList.length; ++i)
                    $root.Qot_Common.Security.encode(message.securityList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.subTypeList != null && message.subTypeList.length)
                for (var i = 0; i < message.subTypeList.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.subTypeList[i]);
            writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isSubOrUnSub);
            if (message.isRegOrUnRegPush != null && message.hasOwnProperty("isRegOrUnRegPush"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.isRegOrUnRegPush);
            if (message.regPushRehabTypeList != null && message.regPushRehabTypeList.length)
                for (var i = 0; i < message.regPushRehabTypeList.length; ++i)
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.regPushRehabTypeList[i]);
            if (message.isFirstPush != null && message.hasOwnProperty("isFirstPush"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.isFirstPush);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Qot_Sub.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_Sub.C2S
         * @static
         * @param {Qot_Sub.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_Sub.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_Sub.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_Sub.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.securityList && message.securityList.length))
                        message.securityList = [];
                    message.securityList.push($root.Qot_Common.Security.decode(reader, reader.uint32()));
                    break;
                case 2:
                    if (!(message.subTypeList && message.subTypeList.length))
                        message.subTypeList = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.subTypeList.push(reader.int32());
                    } else
                        message.subTypeList.push(reader.int32());
                    break;
                case 3:
                    message.isSubOrUnSub = reader.bool();
                    break;
                case 4:
                    message.isRegOrUnRegPush = reader.bool();
                    break;
                case 5:
                    if (!(message.regPushRehabTypeList && message.regPushRehabTypeList.length))
                        message.regPushRehabTypeList = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.regPushRehabTypeList.push(reader.int32());
                    } else
                        message.regPushRehabTypeList.push(reader.int32());
                    break;
                case 6:
                    message.isFirstPush = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("isSubOrUnSub"))
                throw $util.ProtocolError("missing required 'isSubOrUnSub'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_Sub.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_Sub.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Qot_Sub.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.securityList != null && message.hasOwnProperty("securityList")) {
                if (!Array.isArray(message.securityList))
                    return "securityList: array expected";
                for (var i = 0; i < message.securityList.length; ++i) {
                    var error = $root.Qot_Common.Security.verify(message.securityList[i]);
                    if (error)
                        return "securityList." + error;
                }
            }
            if (message.subTypeList != null && message.hasOwnProperty("subTypeList")) {
                if (!Array.isArray(message.subTypeList))
                    return "subTypeList: array expected";
                for (var i = 0; i < message.subTypeList.length; ++i)
                    if (!$util.isInteger(message.subTypeList[i]))
                        return "subTypeList: integer[] expected";
            }
            if (typeof message.isSubOrUnSub !== "boolean")
                return "isSubOrUnSub: boolean expected";
            if (message.isRegOrUnRegPush != null && message.hasOwnProperty("isRegOrUnRegPush"))
                if (typeof message.isRegOrUnRegPush !== "boolean")
                    return "isRegOrUnRegPush: boolean expected";
            if (message.regPushRehabTypeList != null && message.hasOwnProperty("regPushRehabTypeList")) {
                if (!Array.isArray(message.regPushRehabTypeList))
                    return "regPushRehabTypeList: array expected";
                for (var i = 0; i < message.regPushRehabTypeList.length; ++i)
                    if (!$util.isInteger(message.regPushRehabTypeList[i]))
                        return "regPushRehabTypeList: integer[] expected";
            }
            if (message.isFirstPush != null && message.hasOwnProperty("isFirstPush"))
                if (typeof message.isFirstPush !== "boolean")
                    return "isFirstPush: boolean expected";
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_Sub.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_Sub.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_Sub.C2S)
                return object;
            var message = new $root.Qot_Sub.C2S();
            if (object.securityList) {
                if (!Array.isArray(object.securityList))
                    throw TypeError(".Qot_Sub.C2S.securityList: array expected");
                message.securityList = [];
                for (var i = 0; i < object.securityList.length; ++i) {
                    if (typeof object.securityList[i] !== "object")
                        throw TypeError(".Qot_Sub.C2S.securityList: object expected");
                    message.securityList[i] = $root.Qot_Common.Security.fromObject(object.securityList[i]);
                }
            }
            if (object.subTypeList) {
                if (!Array.isArray(object.subTypeList))
                    throw TypeError(".Qot_Sub.C2S.subTypeList: array expected");
                message.subTypeList = [];
                for (var i = 0; i < object.subTypeList.length; ++i)
                    message.subTypeList[i] = object.subTypeList[i] | 0;
            }
            if (object.isSubOrUnSub != null)
                message.isSubOrUnSub = Boolean(object.isSubOrUnSub);
            if (object.isRegOrUnRegPush != null)
                message.isRegOrUnRegPush = Boolean(object.isRegOrUnRegPush);
            if (object.regPushRehabTypeList) {
                if (!Array.isArray(object.regPushRehabTypeList))
                    throw TypeError(".Qot_Sub.C2S.regPushRehabTypeList: array expected");
                message.regPushRehabTypeList = [];
                for (var i = 0; i < object.regPushRehabTypeList.length; ++i)
                    message.regPushRehabTypeList[i] = object.regPushRehabTypeList[i] | 0;
            }
            if (object.isFirstPush != null)
                message.isFirstPush = Boolean(object.isFirstPush);
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_Sub.C2S
         * @static
         * @param {Qot_Sub.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.securityList = [];
                object.subTypeList = [];
                object.regPushRehabTypeList = [];
            }
            if (options.defaults) {
                object.isSubOrUnSub = false;
                object.isRegOrUnRegPush = false;
                object.isFirstPush = false;
            }
            if (message.securityList && message.securityList.length) {
                object.securityList = [];
                for (var j = 0; j < message.securityList.length; ++j)
                    object.securityList[j] = $root.Qot_Common.Security.toObject(message.securityList[j], options);
            }
            if (message.subTypeList && message.subTypeList.length) {
                object.subTypeList = [];
                for (var j = 0; j < message.subTypeList.length; ++j)
                    object.subTypeList[j] = message.subTypeList[j];
            }
            if (message.isSubOrUnSub != null && message.hasOwnProperty("isSubOrUnSub"))
                object.isSubOrUnSub = message.isSubOrUnSub;
            if (message.isRegOrUnRegPush != null && message.hasOwnProperty("isRegOrUnRegPush"))
                object.isRegOrUnRegPush = message.isRegOrUnRegPush;
            if (message.regPushRehabTypeList && message.regPushRehabTypeList.length) {
                object.regPushRehabTypeList = [];
                for (var j = 0; j < message.regPushRehabTypeList.length; ++j)
                    object.regPushRehabTypeList[j] = message.regPushRehabTypeList[j];
            }
            if (message.isFirstPush != null && message.hasOwnProperty("isFirstPush"))
                object.isFirstPush = message.isFirstPush;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Qot_Sub.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Qot_Sub.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_Sub
         * @interface IS2C
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_Sub
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_Sub.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_Sub.S2C
         * @static
         * @param {Qot_Sub.IS2C=} [properties] Properties to set
         * @returns {Qot_Sub.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_Sub.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_Sub.S2C
         * @static
         * @param {Qot_Sub.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_Sub.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_Sub.S2C
         * @static
         * @param {Qot_Sub.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_Sub.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_Sub.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_Sub.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_Sub.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_Sub.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_Sub.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_Sub.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_Sub.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_Sub.S2C)
                return object;
            return new $root.Qot_Sub.S2C();
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_Sub.S2C
         * @static
         * @param {Qot_Sub.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_Sub.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_Sub.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Qot_Sub
         * @interface IRequest
         * @property {Qot_Sub.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Qot_Sub
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Qot_Sub.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Qot_Sub.IC2S} c2s
         * @memberof Qot_Sub.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Qot_Sub.Request
         * @static
         * @param {Qot_Sub.IRequest=} [properties] Properties to set
         * @returns {Qot_Sub.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Qot_Sub.Request.verify|verify} messages.
         * @function encode
         * @memberof Qot_Sub.Request
         * @static
         * @param {Qot_Sub.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Sub.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Qot_Sub.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_Sub.Request
         * @static
         * @param {Qot_Sub.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_Sub.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_Sub.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_Sub.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Qot_Sub.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_Sub.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_Sub.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Qot_Sub.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Sub.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_Sub.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_Sub.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_Sub.Request)
                return object;
            var message = new $root.Qot_Sub.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Qot_Sub.Request.c2s: object expected");
                message.c2s = $root.Qot_Sub.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_Sub.Request
         * @static
         * @param {Qot_Sub.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Qot_Sub.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Qot_Sub.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Qot_Sub.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_Sub
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_Sub.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_Sub
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_Sub.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_Sub.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_Sub.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_Sub.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_Sub.IS2C|null|undefined} s2c
         * @memberof Qot_Sub.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_Sub.Response
         * @static
         * @param {Qot_Sub.IResponse=} [properties] Properties to set
         * @returns {Qot_Sub.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_Sub.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_Sub.Response
         * @static
         * @param {Qot_Sub.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_Sub.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_Sub.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_Sub.Response
         * @static
         * @param {Qot_Sub.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_Sub.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_Sub.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_Sub.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_Sub.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_Sub.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_Sub.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_Sub.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_Sub.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_Sub.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_Sub.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_Sub.Response)
                return object;
            var message = new $root.Qot_Sub.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_Sub.Response.s2c: object expected");
                message.s2c = $root.Qot_Sub.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_Sub.Response
         * @static
         * @param {Qot_Sub.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_Sub.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_Sub.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_Sub;
})();

$root.Qot_UpdateBasicQot = (function() {

    /**
     * Namespace Qot_UpdateBasicQot.
     * @exports Qot_UpdateBasicQot
     * @namespace
     */
    var Qot_UpdateBasicQot = {};

    Qot_UpdateBasicQot.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_UpdateBasicQot
         * @interface IS2C
         * @property {Array.<Qot_Common.IBasicQot>|null} [basicQotList] S2C basicQotList
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_UpdateBasicQot
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_UpdateBasicQot.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.basicQotList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C basicQotList.
         * @member {Array.<Qot_Common.IBasicQot>} basicQotList
         * @memberof Qot_UpdateBasicQot.S2C
         * @instance
         */
        S2C.prototype.basicQotList = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_UpdateBasicQot.S2C
         * @static
         * @param {Qot_UpdateBasicQot.IS2C=} [properties] Properties to set
         * @returns {Qot_UpdateBasicQot.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_UpdateBasicQot.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_UpdateBasicQot.S2C
         * @static
         * @param {Qot_UpdateBasicQot.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.basicQotList != null && message.basicQotList.length)
                for (var i = 0; i < message.basicQotList.length; ++i)
                    $root.Qot_Common.BasicQot.encode(message.basicQotList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_UpdateBasicQot.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_UpdateBasicQot.S2C
         * @static
         * @param {Qot_UpdateBasicQot.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_UpdateBasicQot.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_UpdateBasicQot.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_UpdateBasicQot.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.basicQotList && message.basicQotList.length))
                        message.basicQotList = [];
                    message.basicQotList.push($root.Qot_Common.BasicQot.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_UpdateBasicQot.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_UpdateBasicQot.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_UpdateBasicQot.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.basicQotList != null && message.hasOwnProperty("basicQotList")) {
                if (!Array.isArray(message.basicQotList))
                    return "basicQotList: array expected";
                for (var i = 0; i < message.basicQotList.length; ++i) {
                    var error = $root.Qot_Common.BasicQot.verify(message.basicQotList[i]);
                    if (error)
                        return "basicQotList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_UpdateBasicQot.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_UpdateBasicQot.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_UpdateBasicQot.S2C)
                return object;
            var message = new $root.Qot_UpdateBasicQot.S2C();
            if (object.basicQotList) {
                if (!Array.isArray(object.basicQotList))
                    throw TypeError(".Qot_UpdateBasicQot.S2C.basicQotList: array expected");
                message.basicQotList = [];
                for (var i = 0; i < object.basicQotList.length; ++i) {
                    if (typeof object.basicQotList[i] !== "object")
                        throw TypeError(".Qot_UpdateBasicQot.S2C.basicQotList: object expected");
                    message.basicQotList[i] = $root.Qot_Common.BasicQot.fromObject(object.basicQotList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_UpdateBasicQot.S2C
         * @static
         * @param {Qot_UpdateBasicQot.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.basicQotList = [];
            if (message.basicQotList && message.basicQotList.length) {
                object.basicQotList = [];
                for (var j = 0; j < message.basicQotList.length; ++j)
                    object.basicQotList[j] = $root.Qot_Common.BasicQot.toObject(message.basicQotList[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_UpdateBasicQot.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_UpdateBasicQot.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_UpdateBasicQot
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_UpdateBasicQot.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_UpdateBasicQot
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_UpdateBasicQot.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_UpdateBasicQot.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_UpdateBasicQot.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_UpdateBasicQot.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_UpdateBasicQot.IS2C|null|undefined} s2c
         * @memberof Qot_UpdateBasicQot.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_UpdateBasicQot.Response
         * @static
         * @param {Qot_UpdateBasicQot.IResponse=} [properties] Properties to set
         * @returns {Qot_UpdateBasicQot.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_UpdateBasicQot.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_UpdateBasicQot.Response
         * @static
         * @param {Qot_UpdateBasicQot.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_UpdateBasicQot.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_UpdateBasicQot.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_UpdateBasicQot.Response
         * @static
         * @param {Qot_UpdateBasicQot.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_UpdateBasicQot.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_UpdateBasicQot.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_UpdateBasicQot.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_UpdateBasicQot.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_UpdateBasicQot.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_UpdateBasicQot.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_UpdateBasicQot.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_UpdateBasicQot.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_UpdateBasicQot.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_UpdateBasicQot.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_UpdateBasicQot.Response)
                return object;
            var message = new $root.Qot_UpdateBasicQot.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_UpdateBasicQot.Response.s2c: object expected");
                message.s2c = $root.Qot_UpdateBasicQot.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_UpdateBasicQot.Response
         * @static
         * @param {Qot_UpdateBasicQot.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_UpdateBasicQot.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_UpdateBasicQot.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_UpdateBasicQot;
})();

$root.Qot_UpdateBroker = (function() {

    /**
     * Namespace Qot_UpdateBroker.
     * @exports Qot_UpdateBroker
     * @namespace
     */
    var Qot_UpdateBroker = {};

    Qot_UpdateBroker.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_UpdateBroker
         * @interface IS2C
         * @property {Qot_Common.ISecurity} security S2C security
         * @property {Array.<Qot_Common.IBroker>|null} [brokerAskList] S2C brokerAskList
         * @property {Array.<Qot_Common.IBroker>|null} [brokerBidList] S2C brokerBidList
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_UpdateBroker
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_UpdateBroker.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.brokerAskList = [];
            this.brokerBidList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_UpdateBroker.S2C
         * @instance
         */
        S2C.prototype.security = null;

        /**
         * S2C brokerAskList.
         * @member {Array.<Qot_Common.IBroker>} brokerAskList
         * @memberof Qot_UpdateBroker.S2C
         * @instance
         */
        S2C.prototype.brokerAskList = $util.emptyArray;

        /**
         * S2C brokerBidList.
         * @member {Array.<Qot_Common.IBroker>} brokerBidList
         * @memberof Qot_UpdateBroker.S2C
         * @instance
         */
        S2C.prototype.brokerBidList = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_UpdateBroker.S2C
         * @static
         * @param {Qot_UpdateBroker.IS2C=} [properties] Properties to set
         * @returns {Qot_UpdateBroker.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_UpdateBroker.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_UpdateBroker.S2C
         * @static
         * @param {Qot_UpdateBroker.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.brokerAskList != null && message.brokerAskList.length)
                for (var i = 0; i < message.brokerAskList.length; ++i)
                    $root.Qot_Common.Broker.encode(message.brokerAskList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.brokerBidList != null && message.brokerBidList.length)
                for (var i = 0; i < message.brokerBidList.length; ++i)
                    $root.Qot_Common.Broker.encode(message.brokerBidList[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_UpdateBroker.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_UpdateBroker.S2C
         * @static
         * @param {Qot_UpdateBroker.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_UpdateBroker.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_UpdateBroker.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_UpdateBroker.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.brokerAskList && message.brokerAskList.length))
                        message.brokerAskList = [];
                    message.brokerAskList.push($root.Qot_Common.Broker.decode(reader, reader.uint32()));
                    break;
                case 3:
                    if (!(message.brokerBidList && message.brokerBidList.length))
                        message.brokerBidList = [];
                    message.brokerBidList.push($root.Qot_Common.Broker.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_UpdateBroker.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_UpdateBroker.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_UpdateBroker.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            if (message.brokerAskList != null && message.hasOwnProperty("brokerAskList")) {
                if (!Array.isArray(message.brokerAskList))
                    return "brokerAskList: array expected";
                for (var i = 0; i < message.brokerAskList.length; ++i) {
                    var error = $root.Qot_Common.Broker.verify(message.brokerAskList[i]);
                    if (error)
                        return "brokerAskList." + error;
                }
            }
            if (message.brokerBidList != null && message.hasOwnProperty("brokerBidList")) {
                if (!Array.isArray(message.brokerBidList))
                    return "brokerBidList: array expected";
                for (var i = 0; i < message.brokerBidList.length; ++i) {
                    var error = $root.Qot_Common.Broker.verify(message.brokerBidList[i]);
                    if (error)
                        return "brokerBidList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_UpdateBroker.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_UpdateBroker.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_UpdateBroker.S2C)
                return object;
            var message = new $root.Qot_UpdateBroker.S2C();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_UpdateBroker.S2C.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            if (object.brokerAskList) {
                if (!Array.isArray(object.brokerAskList))
                    throw TypeError(".Qot_UpdateBroker.S2C.brokerAskList: array expected");
                message.brokerAskList = [];
                for (var i = 0; i < object.brokerAskList.length; ++i) {
                    if (typeof object.brokerAskList[i] !== "object")
                        throw TypeError(".Qot_UpdateBroker.S2C.brokerAskList: object expected");
                    message.brokerAskList[i] = $root.Qot_Common.Broker.fromObject(object.brokerAskList[i]);
                }
            }
            if (object.brokerBidList) {
                if (!Array.isArray(object.brokerBidList))
                    throw TypeError(".Qot_UpdateBroker.S2C.brokerBidList: array expected");
                message.brokerBidList = [];
                for (var i = 0; i < object.brokerBidList.length; ++i) {
                    if (typeof object.brokerBidList[i] !== "object")
                        throw TypeError(".Qot_UpdateBroker.S2C.brokerBidList: object expected");
                    message.brokerBidList[i] = $root.Qot_Common.Broker.fromObject(object.brokerBidList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_UpdateBroker.S2C
         * @static
         * @param {Qot_UpdateBroker.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.brokerAskList = [];
                object.brokerBidList = [];
            }
            if (options.defaults)
                object.security = null;
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            if (message.brokerAskList && message.brokerAskList.length) {
                object.brokerAskList = [];
                for (var j = 0; j < message.brokerAskList.length; ++j)
                    object.brokerAskList[j] = $root.Qot_Common.Broker.toObject(message.brokerAskList[j], options);
            }
            if (message.brokerBidList && message.brokerBidList.length) {
                object.brokerBidList = [];
                for (var j = 0; j < message.brokerBidList.length; ++j)
                    object.brokerBidList[j] = $root.Qot_Common.Broker.toObject(message.brokerBidList[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_UpdateBroker.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_UpdateBroker.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_UpdateBroker
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_UpdateBroker.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_UpdateBroker
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_UpdateBroker.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_UpdateBroker.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_UpdateBroker.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_UpdateBroker.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_UpdateBroker.IS2C|null|undefined} s2c
         * @memberof Qot_UpdateBroker.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_UpdateBroker.Response
         * @static
         * @param {Qot_UpdateBroker.IResponse=} [properties] Properties to set
         * @returns {Qot_UpdateBroker.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_UpdateBroker.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_UpdateBroker.Response
         * @static
         * @param {Qot_UpdateBroker.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_UpdateBroker.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_UpdateBroker.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_UpdateBroker.Response
         * @static
         * @param {Qot_UpdateBroker.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_UpdateBroker.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_UpdateBroker.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_UpdateBroker.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_UpdateBroker.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_UpdateBroker.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_UpdateBroker.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_UpdateBroker.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_UpdateBroker.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_UpdateBroker.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_UpdateBroker.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_UpdateBroker.Response)
                return object;
            var message = new $root.Qot_UpdateBroker.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_UpdateBroker.Response.s2c: object expected");
                message.s2c = $root.Qot_UpdateBroker.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_UpdateBroker.Response
         * @static
         * @param {Qot_UpdateBroker.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_UpdateBroker.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_UpdateBroker.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_UpdateBroker;
})();

$root.Qot_UpdateKL = (function() {

    /**
     * Namespace Qot_UpdateKL.
     * @exports Qot_UpdateKL
     * @namespace
     */
    var Qot_UpdateKL = {};

    Qot_UpdateKL.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_UpdateKL
         * @interface IS2C
         * @property {number} rehabType S2C rehabType
         * @property {number} klType S2C klType
         * @property {Qot_Common.ISecurity} security S2C security
         * @property {Array.<Qot_Common.IKLine>|null} [klList] S2C klList
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_UpdateKL
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_UpdateKL.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.klList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C rehabType.
         * @member {number} rehabType
         * @memberof Qot_UpdateKL.S2C
         * @instance
         */
        S2C.prototype.rehabType = 0;

        /**
         * S2C klType.
         * @member {number} klType
         * @memberof Qot_UpdateKL.S2C
         * @instance
         */
        S2C.prototype.klType = 0;

        /**
         * S2C security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_UpdateKL.S2C
         * @instance
         */
        S2C.prototype.security = null;

        /**
         * S2C klList.
         * @member {Array.<Qot_Common.IKLine>} klList
         * @memberof Qot_UpdateKL.S2C
         * @instance
         */
        S2C.prototype.klList = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_UpdateKL.S2C
         * @static
         * @param {Qot_UpdateKL.IS2C=} [properties] Properties to set
         * @returns {Qot_UpdateKL.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_UpdateKL.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_UpdateKL.S2C
         * @static
         * @param {Qot_UpdateKL.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.rehabType);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.klType);
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.klList != null && message.klList.length)
                for (var i = 0; i < message.klList.length; ++i)
                    $root.Qot_Common.KLine.encode(message.klList[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_UpdateKL.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_UpdateKL.S2C
         * @static
         * @param {Qot_UpdateKL.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_UpdateKL.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_UpdateKL.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_UpdateKL.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rehabType = reader.int32();
                    break;
                case 2:
                    message.klType = reader.int32();
                    break;
                case 3:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 4:
                    if (!(message.klList && message.klList.length))
                        message.klList = [];
                    message.klList.push($root.Qot_Common.KLine.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("rehabType"))
                throw $util.ProtocolError("missing required 'rehabType'", { instance: message });
            if (!message.hasOwnProperty("klType"))
                throw $util.ProtocolError("missing required 'klType'", { instance: message });
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_UpdateKL.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_UpdateKL.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_UpdateKL.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.rehabType))
                return "rehabType: integer expected";
            if (!$util.isInteger(message.klType))
                return "klType: integer expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            if (message.klList != null && message.hasOwnProperty("klList")) {
                if (!Array.isArray(message.klList))
                    return "klList: array expected";
                for (var i = 0; i < message.klList.length; ++i) {
                    var error = $root.Qot_Common.KLine.verify(message.klList[i]);
                    if (error)
                        return "klList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_UpdateKL.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_UpdateKL.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_UpdateKL.S2C)
                return object;
            var message = new $root.Qot_UpdateKL.S2C();
            if (object.rehabType != null)
                message.rehabType = object.rehabType | 0;
            if (object.klType != null)
                message.klType = object.klType | 0;
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_UpdateKL.S2C.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            if (object.klList) {
                if (!Array.isArray(object.klList))
                    throw TypeError(".Qot_UpdateKL.S2C.klList: array expected");
                message.klList = [];
                for (var i = 0; i < object.klList.length; ++i) {
                    if (typeof object.klList[i] !== "object")
                        throw TypeError(".Qot_UpdateKL.S2C.klList: object expected");
                    message.klList[i] = $root.Qot_Common.KLine.fromObject(object.klList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_UpdateKL.S2C
         * @static
         * @param {Qot_UpdateKL.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.klList = [];
            if (options.defaults) {
                object.rehabType = 0;
                object.klType = 0;
                object.security = null;
            }
            if (message.rehabType != null && message.hasOwnProperty("rehabType"))
                object.rehabType = message.rehabType;
            if (message.klType != null && message.hasOwnProperty("klType"))
                object.klType = message.klType;
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            if (message.klList && message.klList.length) {
                object.klList = [];
                for (var j = 0; j < message.klList.length; ++j)
                    object.klList[j] = $root.Qot_Common.KLine.toObject(message.klList[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_UpdateKL.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_UpdateKL.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_UpdateKL
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_UpdateKL.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_UpdateKL
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_UpdateKL.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_UpdateKL.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_UpdateKL.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_UpdateKL.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_UpdateKL.IS2C|null|undefined} s2c
         * @memberof Qot_UpdateKL.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_UpdateKL.Response
         * @static
         * @param {Qot_UpdateKL.IResponse=} [properties] Properties to set
         * @returns {Qot_UpdateKL.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_UpdateKL.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_UpdateKL.Response
         * @static
         * @param {Qot_UpdateKL.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_UpdateKL.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_UpdateKL.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_UpdateKL.Response
         * @static
         * @param {Qot_UpdateKL.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_UpdateKL.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_UpdateKL.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_UpdateKL.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_UpdateKL.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_UpdateKL.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_UpdateKL.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_UpdateKL.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_UpdateKL.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_UpdateKL.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_UpdateKL.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_UpdateKL.Response)
                return object;
            var message = new $root.Qot_UpdateKL.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_UpdateKL.Response.s2c: object expected");
                message.s2c = $root.Qot_UpdateKL.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_UpdateKL.Response
         * @static
         * @param {Qot_UpdateKL.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_UpdateKL.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_UpdateKL.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_UpdateKL;
})();

$root.Qot_UpdateOrderBook = (function() {

    /**
     * Namespace Qot_UpdateOrderBook.
     * @exports Qot_UpdateOrderBook
     * @namespace
     */
    var Qot_UpdateOrderBook = {};

    Qot_UpdateOrderBook.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_UpdateOrderBook
         * @interface IS2C
         * @property {Qot_Common.ISecurity} security S2C security
         * @property {Array.<Qot_Common.IOrderBook>|null} [orderBookAskList] S2C orderBookAskList
         * @property {Array.<Qot_Common.IOrderBook>|null} [orderBookBidList] S2C orderBookBidList
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_UpdateOrderBook
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_UpdateOrderBook.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.orderBookAskList = [];
            this.orderBookBidList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_UpdateOrderBook.S2C
         * @instance
         */
        S2C.prototype.security = null;

        /**
         * S2C orderBookAskList.
         * @member {Array.<Qot_Common.IOrderBook>} orderBookAskList
         * @memberof Qot_UpdateOrderBook.S2C
         * @instance
         */
        S2C.prototype.orderBookAskList = $util.emptyArray;

        /**
         * S2C orderBookBidList.
         * @member {Array.<Qot_Common.IOrderBook>} orderBookBidList
         * @memberof Qot_UpdateOrderBook.S2C
         * @instance
         */
        S2C.prototype.orderBookBidList = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_UpdateOrderBook.S2C
         * @static
         * @param {Qot_UpdateOrderBook.IS2C=} [properties] Properties to set
         * @returns {Qot_UpdateOrderBook.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_UpdateOrderBook.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_UpdateOrderBook.S2C
         * @static
         * @param {Qot_UpdateOrderBook.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.orderBookAskList != null && message.orderBookAskList.length)
                for (var i = 0; i < message.orderBookAskList.length; ++i)
                    $root.Qot_Common.OrderBook.encode(message.orderBookAskList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.orderBookBidList != null && message.orderBookBidList.length)
                for (var i = 0; i < message.orderBookBidList.length; ++i)
                    $root.Qot_Common.OrderBook.encode(message.orderBookBidList[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_UpdateOrderBook.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_UpdateOrderBook.S2C
         * @static
         * @param {Qot_UpdateOrderBook.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_UpdateOrderBook.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_UpdateOrderBook.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_UpdateOrderBook.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.orderBookAskList && message.orderBookAskList.length))
                        message.orderBookAskList = [];
                    message.orderBookAskList.push($root.Qot_Common.OrderBook.decode(reader, reader.uint32()));
                    break;
                case 3:
                    if (!(message.orderBookBidList && message.orderBookBidList.length))
                        message.orderBookBidList = [];
                    message.orderBookBidList.push($root.Qot_Common.OrderBook.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_UpdateOrderBook.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_UpdateOrderBook.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_UpdateOrderBook.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            if (message.orderBookAskList != null && message.hasOwnProperty("orderBookAskList")) {
                if (!Array.isArray(message.orderBookAskList))
                    return "orderBookAskList: array expected";
                for (var i = 0; i < message.orderBookAskList.length; ++i) {
                    var error = $root.Qot_Common.OrderBook.verify(message.orderBookAskList[i]);
                    if (error)
                        return "orderBookAskList." + error;
                }
            }
            if (message.orderBookBidList != null && message.hasOwnProperty("orderBookBidList")) {
                if (!Array.isArray(message.orderBookBidList))
                    return "orderBookBidList: array expected";
                for (var i = 0; i < message.orderBookBidList.length; ++i) {
                    var error = $root.Qot_Common.OrderBook.verify(message.orderBookBidList[i]);
                    if (error)
                        return "orderBookBidList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_UpdateOrderBook.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_UpdateOrderBook.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_UpdateOrderBook.S2C)
                return object;
            var message = new $root.Qot_UpdateOrderBook.S2C();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_UpdateOrderBook.S2C.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            if (object.orderBookAskList) {
                if (!Array.isArray(object.orderBookAskList))
                    throw TypeError(".Qot_UpdateOrderBook.S2C.orderBookAskList: array expected");
                message.orderBookAskList = [];
                for (var i = 0; i < object.orderBookAskList.length; ++i) {
                    if (typeof object.orderBookAskList[i] !== "object")
                        throw TypeError(".Qot_UpdateOrderBook.S2C.orderBookAskList: object expected");
                    message.orderBookAskList[i] = $root.Qot_Common.OrderBook.fromObject(object.orderBookAskList[i]);
                }
            }
            if (object.orderBookBidList) {
                if (!Array.isArray(object.orderBookBidList))
                    throw TypeError(".Qot_UpdateOrderBook.S2C.orderBookBidList: array expected");
                message.orderBookBidList = [];
                for (var i = 0; i < object.orderBookBidList.length; ++i) {
                    if (typeof object.orderBookBidList[i] !== "object")
                        throw TypeError(".Qot_UpdateOrderBook.S2C.orderBookBidList: object expected");
                    message.orderBookBidList[i] = $root.Qot_Common.OrderBook.fromObject(object.orderBookBidList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_UpdateOrderBook.S2C
         * @static
         * @param {Qot_UpdateOrderBook.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.orderBookAskList = [];
                object.orderBookBidList = [];
            }
            if (options.defaults)
                object.security = null;
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            if (message.orderBookAskList && message.orderBookAskList.length) {
                object.orderBookAskList = [];
                for (var j = 0; j < message.orderBookAskList.length; ++j)
                    object.orderBookAskList[j] = $root.Qot_Common.OrderBook.toObject(message.orderBookAskList[j], options);
            }
            if (message.orderBookBidList && message.orderBookBidList.length) {
                object.orderBookBidList = [];
                for (var j = 0; j < message.orderBookBidList.length; ++j)
                    object.orderBookBidList[j] = $root.Qot_Common.OrderBook.toObject(message.orderBookBidList[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_UpdateOrderBook.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_UpdateOrderBook.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_UpdateOrderBook
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_UpdateOrderBook.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_UpdateOrderBook
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_UpdateOrderBook.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_UpdateOrderBook.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_UpdateOrderBook.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_UpdateOrderBook.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_UpdateOrderBook.IS2C|null|undefined} s2c
         * @memberof Qot_UpdateOrderBook.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_UpdateOrderBook.Response
         * @static
         * @param {Qot_UpdateOrderBook.IResponse=} [properties] Properties to set
         * @returns {Qot_UpdateOrderBook.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_UpdateOrderBook.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_UpdateOrderBook.Response
         * @static
         * @param {Qot_UpdateOrderBook.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_UpdateOrderBook.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_UpdateOrderBook.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_UpdateOrderBook.Response
         * @static
         * @param {Qot_UpdateOrderBook.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_UpdateOrderBook.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_UpdateOrderBook.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_UpdateOrderBook.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_UpdateOrderBook.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_UpdateOrderBook.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_UpdateOrderBook.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_UpdateOrderBook.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_UpdateOrderBook.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_UpdateOrderBook.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_UpdateOrderBook.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_UpdateOrderBook.Response)
                return object;
            var message = new $root.Qot_UpdateOrderBook.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_UpdateOrderBook.Response.s2c: object expected");
                message.s2c = $root.Qot_UpdateOrderBook.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_UpdateOrderBook.Response
         * @static
         * @param {Qot_UpdateOrderBook.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_UpdateOrderBook.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_UpdateOrderBook.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_UpdateOrderBook;
})();

$root.Qot_UpdateOrderDetail = (function() {

    /**
     * Namespace Qot_UpdateOrderDetail.
     * @exports Qot_UpdateOrderDetail
     * @namespace
     */
    var Qot_UpdateOrderDetail = {};

    Qot_UpdateOrderDetail.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_UpdateOrderDetail
         * @interface IS2C
         * @property {Qot_Common.ISecurity} security S2C security
         * @property {Qot_Common.IOrderDetail} orderDetailAsk S2C orderDetailAsk
         * @property {Qot_Common.IOrderDetail} orderDetailBid S2C orderDetailBid
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_UpdateOrderDetail
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_UpdateOrderDetail.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_UpdateOrderDetail.S2C
         * @instance
         */
        S2C.prototype.security = null;

        /**
         * S2C orderDetailAsk.
         * @member {Qot_Common.IOrderDetail} orderDetailAsk
         * @memberof Qot_UpdateOrderDetail.S2C
         * @instance
         */
        S2C.prototype.orderDetailAsk = null;

        /**
         * S2C orderDetailBid.
         * @member {Qot_Common.IOrderDetail} orderDetailBid
         * @memberof Qot_UpdateOrderDetail.S2C
         * @instance
         */
        S2C.prototype.orderDetailBid = null;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_UpdateOrderDetail.S2C
         * @static
         * @param {Qot_UpdateOrderDetail.IS2C=} [properties] Properties to set
         * @returns {Qot_UpdateOrderDetail.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_UpdateOrderDetail.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_UpdateOrderDetail.S2C
         * @static
         * @param {Qot_UpdateOrderDetail.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            $root.Qot_Common.OrderDetail.encode(message.orderDetailAsk, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            $root.Qot_Common.OrderDetail.encode(message.orderDetailBid, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_UpdateOrderDetail.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_UpdateOrderDetail.S2C
         * @static
         * @param {Qot_UpdateOrderDetail.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_UpdateOrderDetail.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_UpdateOrderDetail.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_UpdateOrderDetail.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.orderDetailAsk = $root.Qot_Common.OrderDetail.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.orderDetailBid = $root.Qot_Common.OrderDetail.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            if (!message.hasOwnProperty("orderDetailAsk"))
                throw $util.ProtocolError("missing required 'orderDetailAsk'", { instance: message });
            if (!message.hasOwnProperty("orderDetailBid"))
                throw $util.ProtocolError("missing required 'orderDetailBid'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_UpdateOrderDetail.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_UpdateOrderDetail.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_UpdateOrderDetail.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            {
                var error = $root.Qot_Common.OrderDetail.verify(message.orderDetailAsk);
                if (error)
                    return "orderDetailAsk." + error;
            }
            {
                var error = $root.Qot_Common.OrderDetail.verify(message.orderDetailBid);
                if (error)
                    return "orderDetailBid." + error;
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_UpdateOrderDetail.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_UpdateOrderDetail.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_UpdateOrderDetail.S2C)
                return object;
            var message = new $root.Qot_UpdateOrderDetail.S2C();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_UpdateOrderDetail.S2C.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            if (object.orderDetailAsk != null) {
                if (typeof object.orderDetailAsk !== "object")
                    throw TypeError(".Qot_UpdateOrderDetail.S2C.orderDetailAsk: object expected");
                message.orderDetailAsk = $root.Qot_Common.OrderDetail.fromObject(object.orderDetailAsk);
            }
            if (object.orderDetailBid != null) {
                if (typeof object.orderDetailBid !== "object")
                    throw TypeError(".Qot_UpdateOrderDetail.S2C.orderDetailBid: object expected");
                message.orderDetailBid = $root.Qot_Common.OrderDetail.fromObject(object.orderDetailBid);
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_UpdateOrderDetail.S2C
         * @static
         * @param {Qot_UpdateOrderDetail.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.security = null;
                object.orderDetailAsk = null;
                object.orderDetailBid = null;
            }
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            if (message.orderDetailAsk != null && message.hasOwnProperty("orderDetailAsk"))
                object.orderDetailAsk = $root.Qot_Common.OrderDetail.toObject(message.orderDetailAsk, options);
            if (message.orderDetailBid != null && message.hasOwnProperty("orderDetailBid"))
                object.orderDetailBid = $root.Qot_Common.OrderDetail.toObject(message.orderDetailBid, options);
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_UpdateOrderDetail.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_UpdateOrderDetail.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_UpdateOrderDetail
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_UpdateOrderDetail.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_UpdateOrderDetail
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_UpdateOrderDetail.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_UpdateOrderDetail.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_UpdateOrderDetail.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_UpdateOrderDetail.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_UpdateOrderDetail.IS2C|null|undefined} s2c
         * @memberof Qot_UpdateOrderDetail.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_UpdateOrderDetail.Response
         * @static
         * @param {Qot_UpdateOrderDetail.IResponse=} [properties] Properties to set
         * @returns {Qot_UpdateOrderDetail.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_UpdateOrderDetail.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_UpdateOrderDetail.Response
         * @static
         * @param {Qot_UpdateOrderDetail.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_UpdateOrderDetail.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_UpdateOrderDetail.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_UpdateOrderDetail.Response
         * @static
         * @param {Qot_UpdateOrderDetail.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_UpdateOrderDetail.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_UpdateOrderDetail.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_UpdateOrderDetail.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_UpdateOrderDetail.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_UpdateOrderDetail.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_UpdateOrderDetail.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_UpdateOrderDetail.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_UpdateOrderDetail.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_UpdateOrderDetail.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_UpdateOrderDetail.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_UpdateOrderDetail.Response)
                return object;
            var message = new $root.Qot_UpdateOrderDetail.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_UpdateOrderDetail.Response.s2c: object expected");
                message.s2c = $root.Qot_UpdateOrderDetail.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_UpdateOrderDetail.Response
         * @static
         * @param {Qot_UpdateOrderDetail.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_UpdateOrderDetail.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_UpdateOrderDetail.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_UpdateOrderDetail;
})();

$root.Qot_UpdateRT = (function() {

    /**
     * Namespace Qot_UpdateRT.
     * @exports Qot_UpdateRT
     * @namespace
     */
    var Qot_UpdateRT = {};

    Qot_UpdateRT.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_UpdateRT
         * @interface IS2C
         * @property {Qot_Common.ISecurity} security S2C security
         * @property {Array.<Qot_Common.ITimeShare>|null} [rtList] S2C rtList
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_UpdateRT
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_UpdateRT.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.rtList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_UpdateRT.S2C
         * @instance
         */
        S2C.prototype.security = null;

        /**
         * S2C rtList.
         * @member {Array.<Qot_Common.ITimeShare>} rtList
         * @memberof Qot_UpdateRT.S2C
         * @instance
         */
        S2C.prototype.rtList = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_UpdateRT.S2C
         * @static
         * @param {Qot_UpdateRT.IS2C=} [properties] Properties to set
         * @returns {Qot_UpdateRT.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_UpdateRT.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_UpdateRT.S2C
         * @static
         * @param {Qot_UpdateRT.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.rtList != null && message.rtList.length)
                for (var i = 0; i < message.rtList.length; ++i)
                    $root.Qot_Common.TimeShare.encode(message.rtList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_UpdateRT.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_UpdateRT.S2C
         * @static
         * @param {Qot_UpdateRT.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_UpdateRT.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_UpdateRT.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_UpdateRT.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.rtList && message.rtList.length))
                        message.rtList = [];
                    message.rtList.push($root.Qot_Common.TimeShare.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_UpdateRT.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_UpdateRT.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_UpdateRT.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            if (message.rtList != null && message.hasOwnProperty("rtList")) {
                if (!Array.isArray(message.rtList))
                    return "rtList: array expected";
                for (var i = 0; i < message.rtList.length; ++i) {
                    var error = $root.Qot_Common.TimeShare.verify(message.rtList[i]);
                    if (error)
                        return "rtList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_UpdateRT.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_UpdateRT.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_UpdateRT.S2C)
                return object;
            var message = new $root.Qot_UpdateRT.S2C();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_UpdateRT.S2C.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            if (object.rtList) {
                if (!Array.isArray(object.rtList))
                    throw TypeError(".Qot_UpdateRT.S2C.rtList: array expected");
                message.rtList = [];
                for (var i = 0; i < object.rtList.length; ++i) {
                    if (typeof object.rtList[i] !== "object")
                        throw TypeError(".Qot_UpdateRT.S2C.rtList: object expected");
                    message.rtList[i] = $root.Qot_Common.TimeShare.fromObject(object.rtList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_UpdateRT.S2C
         * @static
         * @param {Qot_UpdateRT.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.rtList = [];
            if (options.defaults)
                object.security = null;
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            if (message.rtList && message.rtList.length) {
                object.rtList = [];
                for (var j = 0; j < message.rtList.length; ++j)
                    object.rtList[j] = $root.Qot_Common.TimeShare.toObject(message.rtList[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_UpdateRT.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_UpdateRT.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_UpdateRT
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_UpdateRT.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_UpdateRT
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_UpdateRT.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_UpdateRT.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_UpdateRT.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_UpdateRT.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_UpdateRT.IS2C|null|undefined} s2c
         * @memberof Qot_UpdateRT.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_UpdateRT.Response
         * @static
         * @param {Qot_UpdateRT.IResponse=} [properties] Properties to set
         * @returns {Qot_UpdateRT.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_UpdateRT.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_UpdateRT.Response
         * @static
         * @param {Qot_UpdateRT.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_UpdateRT.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_UpdateRT.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_UpdateRT.Response
         * @static
         * @param {Qot_UpdateRT.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_UpdateRT.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_UpdateRT.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_UpdateRT.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_UpdateRT.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_UpdateRT.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_UpdateRT.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_UpdateRT.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_UpdateRT.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_UpdateRT.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_UpdateRT.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_UpdateRT.Response)
                return object;
            var message = new $root.Qot_UpdateRT.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_UpdateRT.Response.s2c: object expected");
                message.s2c = $root.Qot_UpdateRT.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_UpdateRT.Response
         * @static
         * @param {Qot_UpdateRT.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_UpdateRT.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_UpdateRT.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_UpdateRT;
})();

$root.Qot_UpdateTicker = (function() {

    /**
     * Namespace Qot_UpdateTicker.
     * @exports Qot_UpdateTicker
     * @namespace
     */
    var Qot_UpdateTicker = {};

    Qot_UpdateTicker.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Qot_UpdateTicker
         * @interface IS2C
         * @property {Qot_Common.ISecurity} security S2C security
         * @property {Array.<Qot_Common.ITicker>|null} [tickerList] S2C tickerList
         */

        /**
         * Constructs a new S2C.
         * @memberof Qot_UpdateTicker
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Qot_UpdateTicker.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.tickerList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C security.
         * @member {Qot_Common.ISecurity} security
         * @memberof Qot_UpdateTicker.S2C
         * @instance
         */
        S2C.prototype.security = null;

        /**
         * S2C tickerList.
         * @member {Array.<Qot_Common.ITicker>} tickerList
         * @memberof Qot_UpdateTicker.S2C
         * @instance
         */
        S2C.prototype.tickerList = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Qot_UpdateTicker.S2C
         * @static
         * @param {Qot_UpdateTicker.IS2C=} [properties] Properties to set
         * @returns {Qot_UpdateTicker.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Qot_UpdateTicker.S2C.verify|verify} messages.
         * @function encode
         * @memberof Qot_UpdateTicker.S2C
         * @static
         * @param {Qot_UpdateTicker.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Qot_Common.Security.encode(message.security, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.tickerList != null && message.tickerList.length)
                for (var i = 0; i < message.tickerList.length; ++i)
                    $root.Qot_Common.Ticker.encode(message.tickerList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Qot_UpdateTicker.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_UpdateTicker.S2C
         * @static
         * @param {Qot_UpdateTicker.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_UpdateTicker.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_UpdateTicker.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_UpdateTicker.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.security = $root.Qot_Common.Security.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.tickerList && message.tickerList.length))
                        message.tickerList = [];
                    message.tickerList.push($root.Qot_Common.Ticker.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("security"))
                throw $util.ProtocolError("missing required 'security'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_UpdateTicker.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_UpdateTicker.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Qot_UpdateTicker.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Qot_Common.Security.verify(message.security);
                if (error)
                    return "security." + error;
            }
            if (message.tickerList != null && message.hasOwnProperty("tickerList")) {
                if (!Array.isArray(message.tickerList))
                    return "tickerList: array expected";
                for (var i = 0; i < message.tickerList.length; ++i) {
                    var error = $root.Qot_Common.Ticker.verify(message.tickerList[i]);
                    if (error)
                        return "tickerList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_UpdateTicker.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_UpdateTicker.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_UpdateTicker.S2C)
                return object;
            var message = new $root.Qot_UpdateTicker.S2C();
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".Qot_UpdateTicker.S2C.security: object expected");
                message.security = $root.Qot_Common.Security.fromObject(object.security);
            }
            if (object.tickerList) {
                if (!Array.isArray(object.tickerList))
                    throw TypeError(".Qot_UpdateTicker.S2C.tickerList: array expected");
                message.tickerList = [];
                for (var i = 0; i < object.tickerList.length; ++i) {
                    if (typeof object.tickerList[i] !== "object")
                        throw TypeError(".Qot_UpdateTicker.S2C.tickerList: object expected");
                    message.tickerList[i] = $root.Qot_Common.Ticker.fromObject(object.tickerList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_UpdateTicker.S2C
         * @static
         * @param {Qot_UpdateTicker.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.tickerList = [];
            if (options.defaults)
                object.security = null;
            if (message.security != null && message.hasOwnProperty("security"))
                object.security = $root.Qot_Common.Security.toObject(message.security, options);
            if (message.tickerList && message.tickerList.length) {
                object.tickerList = [];
                for (var j = 0; j < message.tickerList.length; ++j)
                    object.tickerList[j] = $root.Qot_Common.Ticker.toObject(message.tickerList[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Qot_UpdateTicker.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Qot_UpdateTicker.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Qot_UpdateTicker
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Qot_UpdateTicker.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Qot_UpdateTicker
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Qot_UpdateTicker.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Qot_UpdateTicker.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Qot_UpdateTicker.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Qot_UpdateTicker.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Qot_UpdateTicker.IS2C|null|undefined} s2c
         * @memberof Qot_UpdateTicker.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Qot_UpdateTicker.Response
         * @static
         * @param {Qot_UpdateTicker.IResponse=} [properties] Properties to set
         * @returns {Qot_UpdateTicker.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Qot_UpdateTicker.Response.verify|verify} messages.
         * @function encode
         * @memberof Qot_UpdateTicker.Response
         * @static
         * @param {Qot_UpdateTicker.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Qot_UpdateTicker.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Qot_UpdateTicker.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Qot_UpdateTicker.Response
         * @static
         * @param {Qot_UpdateTicker.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Qot_UpdateTicker.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Qot_UpdateTicker.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Qot_UpdateTicker.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Qot_UpdateTicker.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Qot_UpdateTicker.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Qot_UpdateTicker.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Qot_UpdateTicker.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Qot_UpdateTicker.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Qot_UpdateTicker.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Qot_UpdateTicker.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Qot_UpdateTicker.Response)
                return object;
            var message = new $root.Qot_UpdateTicker.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Qot_UpdateTicker.Response.s2c: object expected");
                message.s2c = $root.Qot_UpdateTicker.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Qot_UpdateTicker.Response
         * @static
         * @param {Qot_UpdateTicker.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Qot_UpdateTicker.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Qot_UpdateTicker.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Qot_UpdateTicker;
})();

$root.Trd_Common = (function() {

    /**
     * Namespace Trd_Common.
     * @exports Trd_Common
     * @namespace
     */
    var Trd_Common = {};

    /**
     * TrdEnv enum.
     * @name Trd_Common.TrdEnv
     * @enum {string}
     * @property {number} TrdEnv_Simulate=0 TrdEnv_Simulate value
     * @property {number} TrdEnv_Real=1 TrdEnv_Real value
     */
    Trd_Common.TrdEnv = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "TrdEnv_Simulate"] = 0;
        values[valuesById[1] = "TrdEnv_Real"] = 1;
        return values;
    })();

    /**
     * TrdMarket enum.
     * @name Trd_Common.TrdMarket
     * @enum {string}
     * @property {number} TrdMarket_Unknown=0 TrdMarket_Unknown value
     * @property {number} TrdMarket_HK=1 TrdMarket_HK value
     * @property {number} TrdMarket_US=2 TrdMarket_US value
     * @property {number} TrdMarket_CN=3 TrdMarket_CN value
     * @property {number} TrdMarket_HKCC=4 TrdMarket_HKCC value
     */
    Trd_Common.TrdMarket = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "TrdMarket_Unknown"] = 0;
        values[valuesById[1] = "TrdMarket_HK"] = 1;
        values[valuesById[2] = "TrdMarket_US"] = 2;
        values[valuesById[3] = "TrdMarket_CN"] = 3;
        values[valuesById[4] = "TrdMarket_HKCC"] = 4;
        return values;
    })();

    /**
     * TrdSecMarket enum.
     * @name Trd_Common.TrdSecMarket
     * @enum {string}
     * @property {number} TrdSecMarket_Unknown=0 TrdSecMarket_Unknown value
     * @property {number} TrdSecMarket_HK=1 TrdSecMarket_HK value
     * @property {number} TrdSecMarket_US=2 TrdSecMarket_US value
     * @property {number} TrdSecMarket_CN_SH=31 TrdSecMarket_CN_SH value
     * @property {number} TrdSecMarket_CN_SZ=32 TrdSecMarket_CN_SZ value
     */
    Trd_Common.TrdSecMarket = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "TrdSecMarket_Unknown"] = 0;
        values[valuesById[1] = "TrdSecMarket_HK"] = 1;
        values[valuesById[2] = "TrdSecMarket_US"] = 2;
        values[valuesById[31] = "TrdSecMarket_CN_SH"] = 31;
        values[valuesById[32] = "TrdSecMarket_CN_SZ"] = 32;
        return values;
    })();

    /**
     * TrdSide enum.
     * @name Trd_Common.TrdSide
     * @enum {string}
     * @property {number} TrdSide_Unknown=0 TrdSide_Unknown value
     * @property {number} TrdSide_Buy=1 TrdSide_Buy value
     * @property {number} TrdSide_Sell=2 TrdSide_Sell value
     * @property {number} TrdSide_SellShort=3 TrdSide_SellShort value
     * @property {number} TrdSide_BuyBack=4 TrdSide_BuyBack value
     */
    Trd_Common.TrdSide = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "TrdSide_Unknown"] = 0;
        values[valuesById[1] = "TrdSide_Buy"] = 1;
        values[valuesById[2] = "TrdSide_Sell"] = 2;
        values[valuesById[3] = "TrdSide_SellShort"] = 3;
        values[valuesById[4] = "TrdSide_BuyBack"] = 4;
        return values;
    })();

    /**
     * OrderType enum.
     * @name Trd_Common.OrderType
     * @enum {string}
     * @property {number} OrderType_Unknown=0 OrderType_Unknown value
     * @property {number} OrderType_Normal=1 OrderType_Normal value
     * @property {number} OrderType_Market=2 OrderType_Market value
     * @property {number} OrderType_AbsoluteLimit=5 OrderType_AbsoluteLimit value
     * @property {number} OrderType_Auction=6 OrderType_Auction value
     * @property {number} OrderType_AuctionLimit=7 OrderType_AuctionLimit value
     * @property {number} OrderType_SpecialLimit=8 OrderType_SpecialLimit value
     */
    Trd_Common.OrderType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "OrderType_Unknown"] = 0;
        values[valuesById[1] = "OrderType_Normal"] = 1;
        values[valuesById[2] = "OrderType_Market"] = 2;
        values[valuesById[5] = "OrderType_AbsoluteLimit"] = 5;
        values[valuesById[6] = "OrderType_Auction"] = 6;
        values[valuesById[7] = "OrderType_AuctionLimit"] = 7;
        values[valuesById[8] = "OrderType_SpecialLimit"] = 8;
        return values;
    })();

    /**
     * OrderStatus enum.
     * @name Trd_Common.OrderStatus
     * @enum {string}
     * @property {number} OrderStatus_Unsubmitted=0 OrderStatus_Unsubmitted value
     * @property {number} OrderStatus_Unknown=-1 OrderStatus_Unknown value
     * @property {number} OrderStatus_WaitingSubmit=1 OrderStatus_WaitingSubmit value
     * @property {number} OrderStatus_Submitting=2 OrderStatus_Submitting value
     * @property {number} OrderStatus_SubmitFailed=3 OrderStatus_SubmitFailed value
     * @property {number} OrderStatus_TimeOut=4 OrderStatus_TimeOut value
     * @property {number} OrderStatus_Submitted=5 OrderStatus_Submitted value
     * @property {number} OrderStatus_Filled_Part=10 OrderStatus_Filled_Part value
     * @property {number} OrderStatus_Filled_All=11 OrderStatus_Filled_All value
     * @property {number} OrderStatus_Cancelling_Part=12 OrderStatus_Cancelling_Part value
     * @property {number} OrderStatus_Cancelling_All=13 OrderStatus_Cancelling_All value
     * @property {number} OrderStatus_Cancelled_Part=14 OrderStatus_Cancelled_Part value
     * @property {number} OrderStatus_Cancelled_All=15 OrderStatus_Cancelled_All value
     * @property {number} OrderStatus_Failed=21 OrderStatus_Failed value
     * @property {number} OrderStatus_Disabled=22 OrderStatus_Disabled value
     * @property {number} OrderStatus_Deleted=23 OrderStatus_Deleted value
     */
    Trd_Common.OrderStatus = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "OrderStatus_Unsubmitted"] = 0;
        values[valuesById[-1] = "OrderStatus_Unknown"] = -1;
        values[valuesById[1] = "OrderStatus_WaitingSubmit"] = 1;
        values[valuesById[2] = "OrderStatus_Submitting"] = 2;
        values[valuesById[3] = "OrderStatus_SubmitFailed"] = 3;
        values[valuesById[4] = "OrderStatus_TimeOut"] = 4;
        values[valuesById[5] = "OrderStatus_Submitted"] = 5;
        values[valuesById[10] = "OrderStatus_Filled_Part"] = 10;
        values[valuesById[11] = "OrderStatus_Filled_All"] = 11;
        values[valuesById[12] = "OrderStatus_Cancelling_Part"] = 12;
        values[valuesById[13] = "OrderStatus_Cancelling_All"] = 13;
        values[valuesById[14] = "OrderStatus_Cancelled_Part"] = 14;
        values[valuesById[15] = "OrderStatus_Cancelled_All"] = 15;
        values[valuesById[21] = "OrderStatus_Failed"] = 21;
        values[valuesById[22] = "OrderStatus_Disabled"] = 22;
        values[valuesById[23] = "OrderStatus_Deleted"] = 23;
        return values;
    })();

    /**
     * PositionSide enum.
     * @name Trd_Common.PositionSide
     * @enum {string}
     * @property {number} PositionSide_Long=0 PositionSide_Long value
     * @property {number} PositionSide_Unknown=-1 PositionSide_Unknown value
     * @property {number} PositionSide_Short=1 PositionSide_Short value
     */
    Trd_Common.PositionSide = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "PositionSide_Long"] = 0;
        values[valuesById[-1] = "PositionSide_Unknown"] = -1;
        values[valuesById[1] = "PositionSide_Short"] = 1;
        return values;
    })();

    /**
     * ModifyOrderOp enum.
     * @name Trd_Common.ModifyOrderOp
     * @enum {string}
     * @property {number} ModifyOrderOp_Unknown=0 ModifyOrderOp_Unknown value
     * @property {number} ModifyOrderOp_Normal=1 ModifyOrderOp_Normal value
     * @property {number} ModifyOrderOp_Cancel=2 ModifyOrderOp_Cancel value
     * @property {number} ModifyOrderOp_Disable=3 ModifyOrderOp_Disable value
     * @property {number} ModifyOrderOp_Enable=4 ModifyOrderOp_Enable value
     * @property {number} ModifyOrderOp_Delete=5 ModifyOrderOp_Delete value
     */
    Trd_Common.ModifyOrderOp = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "ModifyOrderOp_Unknown"] = 0;
        values[valuesById[1] = "ModifyOrderOp_Normal"] = 1;
        values[valuesById[2] = "ModifyOrderOp_Cancel"] = 2;
        values[valuesById[3] = "ModifyOrderOp_Disable"] = 3;
        values[valuesById[4] = "ModifyOrderOp_Enable"] = 4;
        values[valuesById[5] = "ModifyOrderOp_Delete"] = 5;
        return values;
    })();

    /**
     * ReconfirmOrderReason enum.
     * @name Trd_Common.ReconfirmOrderReason
     * @enum {string}
     * @property {number} ReconfirmOrderReason_Unknown=0 ReconfirmOrderReason_Unknown value
     * @property {number} ReconfirmOrderReason_QtyTooLarge=1 ReconfirmOrderReason_QtyTooLarge value
     * @property {number} ReconfirmOrderReason_PriceAbnormal=2 ReconfirmOrderReason_PriceAbnormal value
     */
    Trd_Common.ReconfirmOrderReason = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "ReconfirmOrderReason_Unknown"] = 0;
        values[valuesById[1] = "ReconfirmOrderReason_QtyTooLarge"] = 1;
        values[valuesById[2] = "ReconfirmOrderReason_PriceAbnormal"] = 2;
        return values;
    })();

    Trd_Common.TrdHeader = (function() {

        /**
         * Properties of a TrdHeader.
         * @memberof Trd_Common
         * @interface ITrdHeader
         * @property {number} trdEnv TrdHeader trdEnv
         * @property {number|Long} accID TrdHeader accID
         * @property {number} trdMarket TrdHeader trdMarket
         */

        /**
         * Constructs a new TrdHeader.
         * @memberof Trd_Common
         * @classdesc Represents a TrdHeader.
         * @implements ITrdHeader
         * @constructor
         * @param {Trd_Common.ITrdHeader=} [properties] Properties to set
         */
        function TrdHeader(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TrdHeader trdEnv.
         * @member {number} trdEnv
         * @memberof Trd_Common.TrdHeader
         * @instance
         */
        TrdHeader.prototype.trdEnv = 0;

        /**
         * TrdHeader accID.
         * @member {number|Long} accID
         * @memberof Trd_Common.TrdHeader
         * @instance
         */
        TrdHeader.prototype.accID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * TrdHeader trdMarket.
         * @member {number} trdMarket
         * @memberof Trd_Common.TrdHeader
         * @instance
         */
        TrdHeader.prototype.trdMarket = 0;

        /**
         * Creates a new TrdHeader instance using the specified properties.
         * @function create
         * @memberof Trd_Common.TrdHeader
         * @static
         * @param {Trd_Common.ITrdHeader=} [properties] Properties to set
         * @returns {Trd_Common.TrdHeader} TrdHeader instance
         */
        TrdHeader.create = function create(properties) {
            return new TrdHeader(properties);
        };

        /**
         * Encodes the specified TrdHeader message. Does not implicitly {@link Trd_Common.TrdHeader.verify|verify} messages.
         * @function encode
         * @memberof Trd_Common.TrdHeader
         * @static
         * @param {Trd_Common.ITrdHeader} message TrdHeader message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TrdHeader.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.trdEnv);
            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.accID);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.trdMarket);
            return writer;
        };

        /**
         * Encodes the specified TrdHeader message, length delimited. Does not implicitly {@link Trd_Common.TrdHeader.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_Common.TrdHeader
         * @static
         * @param {Trd_Common.ITrdHeader} message TrdHeader message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TrdHeader.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TrdHeader message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_Common.TrdHeader
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_Common.TrdHeader} TrdHeader
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TrdHeader.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_Common.TrdHeader();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.trdEnv = reader.int32();
                    break;
                case 2:
                    message.accID = reader.uint64();
                    break;
                case 3:
                    message.trdMarket = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("trdEnv"))
                throw $util.ProtocolError("missing required 'trdEnv'", { instance: message });
            if (!message.hasOwnProperty("accID"))
                throw $util.ProtocolError("missing required 'accID'", { instance: message });
            if (!message.hasOwnProperty("trdMarket"))
                throw $util.ProtocolError("missing required 'trdMarket'", { instance: message });
            return message;
        };

        /**
         * Decodes a TrdHeader message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_Common.TrdHeader
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_Common.TrdHeader} TrdHeader
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TrdHeader.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TrdHeader message.
         * @function verify
         * @memberof Trd_Common.TrdHeader
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TrdHeader.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.trdEnv))
                return "trdEnv: integer expected";
            if (!$util.isInteger(message.accID) && !(message.accID && $util.isInteger(message.accID.low) && $util.isInteger(message.accID.high)))
                return "accID: integer|Long expected";
            if (!$util.isInteger(message.trdMarket))
                return "trdMarket: integer expected";
            return null;
        };

        /**
         * Creates a TrdHeader message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_Common.TrdHeader
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_Common.TrdHeader} TrdHeader
         */
        TrdHeader.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_Common.TrdHeader)
                return object;
            var message = new $root.Trd_Common.TrdHeader();
            if (object.trdEnv != null)
                message.trdEnv = object.trdEnv | 0;
            if (object.accID != null)
                if ($util.Long)
                    (message.accID = $util.Long.fromValue(object.accID)).unsigned = true;
                else if (typeof object.accID === "string")
                    message.accID = parseInt(object.accID, 10);
                else if (typeof object.accID === "number")
                    message.accID = object.accID;
                else if (typeof object.accID === "object")
                    message.accID = new $util.LongBits(object.accID.low >>> 0, object.accID.high >>> 0).toNumber(true);
            if (object.trdMarket != null)
                message.trdMarket = object.trdMarket | 0;
            return message;
        };

        /**
         * Creates a plain object from a TrdHeader message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_Common.TrdHeader
         * @static
         * @param {Trd_Common.TrdHeader} message TrdHeader
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TrdHeader.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.trdEnv = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.accID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.accID = options.longs === String ? "0" : 0;
                object.trdMarket = 0;
            }
            if (message.trdEnv != null && message.hasOwnProperty("trdEnv"))
                object.trdEnv = message.trdEnv;
            if (message.accID != null && message.hasOwnProperty("accID"))
                if (typeof message.accID === "number")
                    object.accID = options.longs === String ? String(message.accID) : message.accID;
                else
                    object.accID = options.longs === String ? $util.Long.prototype.toString.call(message.accID) : options.longs === Number ? new $util.LongBits(message.accID.low >>> 0, message.accID.high >>> 0).toNumber(true) : message.accID;
            if (message.trdMarket != null && message.hasOwnProperty("trdMarket"))
                object.trdMarket = message.trdMarket;
            return object;
        };

        /**
         * Converts this TrdHeader to JSON.
         * @function toJSON
         * @memberof Trd_Common.TrdHeader
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TrdHeader.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TrdHeader;
    })();

    Trd_Common.TrdAcc = (function() {

        /**
         * Properties of a TrdAcc.
         * @memberof Trd_Common
         * @interface ITrdAcc
         * @property {number} trdEnv TrdAcc trdEnv
         * @property {number|Long} accID TrdAcc accID
         * @property {Array.<number>|null} [trdMarketAuthList] TrdAcc trdMarketAuthList
         */

        /**
         * Constructs a new TrdAcc.
         * @memberof Trd_Common
         * @classdesc Represents a TrdAcc.
         * @implements ITrdAcc
         * @constructor
         * @param {Trd_Common.ITrdAcc=} [properties] Properties to set
         */
        function TrdAcc(properties) {
            this.trdMarketAuthList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TrdAcc trdEnv.
         * @member {number} trdEnv
         * @memberof Trd_Common.TrdAcc
         * @instance
         */
        TrdAcc.prototype.trdEnv = 0;

        /**
         * TrdAcc accID.
         * @member {number|Long} accID
         * @memberof Trd_Common.TrdAcc
         * @instance
         */
        TrdAcc.prototype.accID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * TrdAcc trdMarketAuthList.
         * @member {Array.<number>} trdMarketAuthList
         * @memberof Trd_Common.TrdAcc
         * @instance
         */
        TrdAcc.prototype.trdMarketAuthList = $util.emptyArray;

        /**
         * Creates a new TrdAcc instance using the specified properties.
         * @function create
         * @memberof Trd_Common.TrdAcc
         * @static
         * @param {Trd_Common.ITrdAcc=} [properties] Properties to set
         * @returns {Trd_Common.TrdAcc} TrdAcc instance
         */
        TrdAcc.create = function create(properties) {
            return new TrdAcc(properties);
        };

        /**
         * Encodes the specified TrdAcc message. Does not implicitly {@link Trd_Common.TrdAcc.verify|verify} messages.
         * @function encode
         * @memberof Trd_Common.TrdAcc
         * @static
         * @param {Trd_Common.ITrdAcc} message TrdAcc message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TrdAcc.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.trdEnv);
            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.accID);
            if (message.trdMarketAuthList != null && message.trdMarketAuthList.length)
                for (var i = 0; i < message.trdMarketAuthList.length; ++i)
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.trdMarketAuthList[i]);
            return writer;
        };

        /**
         * Encodes the specified TrdAcc message, length delimited. Does not implicitly {@link Trd_Common.TrdAcc.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_Common.TrdAcc
         * @static
         * @param {Trd_Common.ITrdAcc} message TrdAcc message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TrdAcc.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TrdAcc message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_Common.TrdAcc
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_Common.TrdAcc} TrdAcc
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TrdAcc.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_Common.TrdAcc();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.trdEnv = reader.int32();
                    break;
                case 2:
                    message.accID = reader.uint64();
                    break;
                case 3:
                    if (!(message.trdMarketAuthList && message.trdMarketAuthList.length))
                        message.trdMarketAuthList = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.trdMarketAuthList.push(reader.int32());
                    } else
                        message.trdMarketAuthList.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("trdEnv"))
                throw $util.ProtocolError("missing required 'trdEnv'", { instance: message });
            if (!message.hasOwnProperty("accID"))
                throw $util.ProtocolError("missing required 'accID'", { instance: message });
            return message;
        };

        /**
         * Decodes a TrdAcc message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_Common.TrdAcc
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_Common.TrdAcc} TrdAcc
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TrdAcc.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TrdAcc message.
         * @function verify
         * @memberof Trd_Common.TrdAcc
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TrdAcc.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.trdEnv))
                return "trdEnv: integer expected";
            if (!$util.isInteger(message.accID) && !(message.accID && $util.isInteger(message.accID.low) && $util.isInteger(message.accID.high)))
                return "accID: integer|Long expected";
            if (message.trdMarketAuthList != null && message.hasOwnProperty("trdMarketAuthList")) {
                if (!Array.isArray(message.trdMarketAuthList))
                    return "trdMarketAuthList: array expected";
                for (var i = 0; i < message.trdMarketAuthList.length; ++i)
                    if (!$util.isInteger(message.trdMarketAuthList[i]))
                        return "trdMarketAuthList: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a TrdAcc message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_Common.TrdAcc
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_Common.TrdAcc} TrdAcc
         */
        TrdAcc.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_Common.TrdAcc)
                return object;
            var message = new $root.Trd_Common.TrdAcc();
            if (object.trdEnv != null)
                message.trdEnv = object.trdEnv | 0;
            if (object.accID != null)
                if ($util.Long)
                    (message.accID = $util.Long.fromValue(object.accID)).unsigned = true;
                else if (typeof object.accID === "string")
                    message.accID = parseInt(object.accID, 10);
                else if (typeof object.accID === "number")
                    message.accID = object.accID;
                else if (typeof object.accID === "object")
                    message.accID = new $util.LongBits(object.accID.low >>> 0, object.accID.high >>> 0).toNumber(true);
            if (object.trdMarketAuthList) {
                if (!Array.isArray(object.trdMarketAuthList))
                    throw TypeError(".Trd_Common.TrdAcc.trdMarketAuthList: array expected");
                message.trdMarketAuthList = [];
                for (var i = 0; i < object.trdMarketAuthList.length; ++i)
                    message.trdMarketAuthList[i] = object.trdMarketAuthList[i] | 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a TrdAcc message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_Common.TrdAcc
         * @static
         * @param {Trd_Common.TrdAcc} message TrdAcc
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TrdAcc.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.trdMarketAuthList = [];
            if (options.defaults) {
                object.trdEnv = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.accID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.accID = options.longs === String ? "0" : 0;
            }
            if (message.trdEnv != null && message.hasOwnProperty("trdEnv"))
                object.trdEnv = message.trdEnv;
            if (message.accID != null && message.hasOwnProperty("accID"))
                if (typeof message.accID === "number")
                    object.accID = options.longs === String ? String(message.accID) : message.accID;
                else
                    object.accID = options.longs === String ? $util.Long.prototype.toString.call(message.accID) : options.longs === Number ? new $util.LongBits(message.accID.low >>> 0, message.accID.high >>> 0).toNumber(true) : message.accID;
            if (message.trdMarketAuthList && message.trdMarketAuthList.length) {
                object.trdMarketAuthList = [];
                for (var j = 0; j < message.trdMarketAuthList.length; ++j)
                    object.trdMarketAuthList[j] = message.trdMarketAuthList[j];
            }
            return object;
        };

        /**
         * Converts this TrdAcc to JSON.
         * @function toJSON
         * @memberof Trd_Common.TrdAcc
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TrdAcc.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TrdAcc;
    })();

    Trd_Common.Funds = (function() {

        /**
         * Properties of a Funds.
         * @memberof Trd_Common
         * @interface IFunds
         * @property {number} power Funds power
         * @property {number} totalAssets Funds totalAssets
         * @property {number} cash Funds cash
         * @property {number} marketVal Funds marketVal
         * @property {number} frozenCash Funds frozenCash
         * @property {number} debtCash Funds debtCash
         * @property {number} avlWithdrawalCash Funds avlWithdrawalCash
         */

        /**
         * Constructs a new Funds.
         * @memberof Trd_Common
         * @classdesc Represents a Funds.
         * @implements IFunds
         * @constructor
         * @param {Trd_Common.IFunds=} [properties] Properties to set
         */
        function Funds(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Funds power.
         * @member {number} power
         * @memberof Trd_Common.Funds
         * @instance
         */
        Funds.prototype.power = 0;

        /**
         * Funds totalAssets.
         * @member {number} totalAssets
         * @memberof Trd_Common.Funds
         * @instance
         */
        Funds.prototype.totalAssets = 0;

        /**
         * Funds cash.
         * @member {number} cash
         * @memberof Trd_Common.Funds
         * @instance
         */
        Funds.prototype.cash = 0;

        /**
         * Funds marketVal.
         * @member {number} marketVal
         * @memberof Trd_Common.Funds
         * @instance
         */
        Funds.prototype.marketVal = 0;

        /**
         * Funds frozenCash.
         * @member {number} frozenCash
         * @memberof Trd_Common.Funds
         * @instance
         */
        Funds.prototype.frozenCash = 0;

        /**
         * Funds debtCash.
         * @member {number} debtCash
         * @memberof Trd_Common.Funds
         * @instance
         */
        Funds.prototype.debtCash = 0;

        /**
         * Funds avlWithdrawalCash.
         * @member {number} avlWithdrawalCash
         * @memberof Trd_Common.Funds
         * @instance
         */
        Funds.prototype.avlWithdrawalCash = 0;

        /**
         * Creates a new Funds instance using the specified properties.
         * @function create
         * @memberof Trd_Common.Funds
         * @static
         * @param {Trd_Common.IFunds=} [properties] Properties to set
         * @returns {Trd_Common.Funds} Funds instance
         */
        Funds.create = function create(properties) {
            return new Funds(properties);
        };

        /**
         * Encodes the specified Funds message. Does not implicitly {@link Trd_Common.Funds.verify|verify} messages.
         * @function encode
         * @memberof Trd_Common.Funds
         * @static
         * @param {Trd_Common.IFunds} message Funds message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Funds.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 1 =*/9).double(message.power);
            writer.uint32(/* id 2, wireType 1 =*/17).double(message.totalAssets);
            writer.uint32(/* id 3, wireType 1 =*/25).double(message.cash);
            writer.uint32(/* id 4, wireType 1 =*/33).double(message.marketVal);
            writer.uint32(/* id 5, wireType 1 =*/41).double(message.frozenCash);
            writer.uint32(/* id 6, wireType 1 =*/49).double(message.debtCash);
            writer.uint32(/* id 7, wireType 1 =*/57).double(message.avlWithdrawalCash);
            return writer;
        };

        /**
         * Encodes the specified Funds message, length delimited. Does not implicitly {@link Trd_Common.Funds.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_Common.Funds
         * @static
         * @param {Trd_Common.IFunds} message Funds message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Funds.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Funds message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_Common.Funds
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_Common.Funds} Funds
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Funds.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_Common.Funds();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.power = reader.double();
                    break;
                case 2:
                    message.totalAssets = reader.double();
                    break;
                case 3:
                    message.cash = reader.double();
                    break;
                case 4:
                    message.marketVal = reader.double();
                    break;
                case 5:
                    message.frozenCash = reader.double();
                    break;
                case 6:
                    message.debtCash = reader.double();
                    break;
                case 7:
                    message.avlWithdrawalCash = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("power"))
                throw $util.ProtocolError("missing required 'power'", { instance: message });
            if (!message.hasOwnProperty("totalAssets"))
                throw $util.ProtocolError("missing required 'totalAssets'", { instance: message });
            if (!message.hasOwnProperty("cash"))
                throw $util.ProtocolError("missing required 'cash'", { instance: message });
            if (!message.hasOwnProperty("marketVal"))
                throw $util.ProtocolError("missing required 'marketVal'", { instance: message });
            if (!message.hasOwnProperty("frozenCash"))
                throw $util.ProtocolError("missing required 'frozenCash'", { instance: message });
            if (!message.hasOwnProperty("debtCash"))
                throw $util.ProtocolError("missing required 'debtCash'", { instance: message });
            if (!message.hasOwnProperty("avlWithdrawalCash"))
                throw $util.ProtocolError("missing required 'avlWithdrawalCash'", { instance: message });
            return message;
        };

        /**
         * Decodes a Funds message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_Common.Funds
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_Common.Funds} Funds
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Funds.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Funds message.
         * @function verify
         * @memberof Trd_Common.Funds
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Funds.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (typeof message.power !== "number")
                return "power: number expected";
            if (typeof message.totalAssets !== "number")
                return "totalAssets: number expected";
            if (typeof message.cash !== "number")
                return "cash: number expected";
            if (typeof message.marketVal !== "number")
                return "marketVal: number expected";
            if (typeof message.frozenCash !== "number")
                return "frozenCash: number expected";
            if (typeof message.debtCash !== "number")
                return "debtCash: number expected";
            if (typeof message.avlWithdrawalCash !== "number")
                return "avlWithdrawalCash: number expected";
            return null;
        };

        /**
         * Creates a Funds message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_Common.Funds
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_Common.Funds} Funds
         */
        Funds.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_Common.Funds)
                return object;
            var message = new $root.Trd_Common.Funds();
            if (object.power != null)
                message.power = Number(object.power);
            if (object.totalAssets != null)
                message.totalAssets = Number(object.totalAssets);
            if (object.cash != null)
                message.cash = Number(object.cash);
            if (object.marketVal != null)
                message.marketVal = Number(object.marketVal);
            if (object.frozenCash != null)
                message.frozenCash = Number(object.frozenCash);
            if (object.debtCash != null)
                message.debtCash = Number(object.debtCash);
            if (object.avlWithdrawalCash != null)
                message.avlWithdrawalCash = Number(object.avlWithdrawalCash);
            return message;
        };

        /**
         * Creates a plain object from a Funds message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_Common.Funds
         * @static
         * @param {Trd_Common.Funds} message Funds
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Funds.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.power = 0;
                object.totalAssets = 0;
                object.cash = 0;
                object.marketVal = 0;
                object.frozenCash = 0;
                object.debtCash = 0;
                object.avlWithdrawalCash = 0;
            }
            if (message.power != null && message.hasOwnProperty("power"))
                object.power = options.json && !isFinite(message.power) ? String(message.power) : message.power;
            if (message.totalAssets != null && message.hasOwnProperty("totalAssets"))
                object.totalAssets = options.json && !isFinite(message.totalAssets) ? String(message.totalAssets) : message.totalAssets;
            if (message.cash != null && message.hasOwnProperty("cash"))
                object.cash = options.json && !isFinite(message.cash) ? String(message.cash) : message.cash;
            if (message.marketVal != null && message.hasOwnProperty("marketVal"))
                object.marketVal = options.json && !isFinite(message.marketVal) ? String(message.marketVal) : message.marketVal;
            if (message.frozenCash != null && message.hasOwnProperty("frozenCash"))
                object.frozenCash = options.json && !isFinite(message.frozenCash) ? String(message.frozenCash) : message.frozenCash;
            if (message.debtCash != null && message.hasOwnProperty("debtCash"))
                object.debtCash = options.json && !isFinite(message.debtCash) ? String(message.debtCash) : message.debtCash;
            if (message.avlWithdrawalCash != null && message.hasOwnProperty("avlWithdrawalCash"))
                object.avlWithdrawalCash = options.json && !isFinite(message.avlWithdrawalCash) ? String(message.avlWithdrawalCash) : message.avlWithdrawalCash;
            return object;
        };

        /**
         * Converts this Funds to JSON.
         * @function toJSON
         * @memberof Trd_Common.Funds
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Funds.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Funds;
    })();

    Trd_Common.Position = (function() {

        /**
         * Properties of a Position.
         * @memberof Trd_Common
         * @interface IPosition
         * @property {number|Long} positionID Position positionID
         * @property {number} positionSide Position positionSide
         * @property {string} code Position code
         * @property {string} name Position name
         * @property {number} qty Position qty
         * @property {number} canSellQty Position canSellQty
         * @property {number} price Position price
         * @property {number|null} [costPrice] Position costPrice
         * @property {number} val Position val
         * @property {number} plVal Position plVal
         * @property {number|null} [plRatio] Position plRatio
         * @property {number|null} [secMarket] Position secMarket
         * @property {number|null} [tdPlVal] Position tdPlVal
         * @property {number|null} [tdTrdVal] Position tdTrdVal
         * @property {number|null} [tdBuyVal] Position tdBuyVal
         * @property {number|null} [tdBuyQty] Position tdBuyQty
         * @property {number|null} [tdSellVal] Position tdSellVal
         * @property {number|null} [tdSellQty] Position tdSellQty
         */

        /**
         * Constructs a new Position.
         * @memberof Trd_Common
         * @classdesc Represents a Position.
         * @implements IPosition
         * @constructor
         * @param {Trd_Common.IPosition=} [properties] Properties to set
         */
        function Position(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Position positionID.
         * @member {number|Long} positionID
         * @memberof Trd_Common.Position
         * @instance
         */
        Position.prototype.positionID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Position positionSide.
         * @member {number} positionSide
         * @memberof Trd_Common.Position
         * @instance
         */
        Position.prototype.positionSide = 0;

        /**
         * Position code.
         * @member {string} code
         * @memberof Trd_Common.Position
         * @instance
         */
        Position.prototype.code = "";

        /**
         * Position name.
         * @member {string} name
         * @memberof Trd_Common.Position
         * @instance
         */
        Position.prototype.name = "";

        /**
         * Position qty.
         * @member {number} qty
         * @memberof Trd_Common.Position
         * @instance
         */
        Position.prototype.qty = 0;

        /**
         * Position canSellQty.
         * @member {number} canSellQty
         * @memberof Trd_Common.Position
         * @instance
         */
        Position.prototype.canSellQty = 0;

        /**
         * Position price.
         * @member {number} price
         * @memberof Trd_Common.Position
         * @instance
         */
        Position.prototype.price = 0;

        /**
         * Position costPrice.
         * @member {number} costPrice
         * @memberof Trd_Common.Position
         * @instance
         */
        Position.prototype.costPrice = 0;

        /**
         * Position val.
         * @member {number} val
         * @memberof Trd_Common.Position
         * @instance
         */
        Position.prototype.val = 0;

        /**
         * Position plVal.
         * @member {number} plVal
         * @memberof Trd_Common.Position
         * @instance
         */
        Position.prototype.plVal = 0;

        /**
         * Position plRatio.
         * @member {number} plRatio
         * @memberof Trd_Common.Position
         * @instance
         */
        Position.prototype.plRatio = 0;

        /**
         * Position secMarket.
         * @member {number} secMarket
         * @memberof Trd_Common.Position
         * @instance
         */
        Position.prototype.secMarket = 0;

        /**
         * Position tdPlVal.
         * @member {number} tdPlVal
         * @memberof Trd_Common.Position
         * @instance
         */
        Position.prototype.tdPlVal = 0;

        /**
         * Position tdTrdVal.
         * @member {number} tdTrdVal
         * @memberof Trd_Common.Position
         * @instance
         */
        Position.prototype.tdTrdVal = 0;

        /**
         * Position tdBuyVal.
         * @member {number} tdBuyVal
         * @memberof Trd_Common.Position
         * @instance
         */
        Position.prototype.tdBuyVal = 0;

        /**
         * Position tdBuyQty.
         * @member {number} tdBuyQty
         * @memberof Trd_Common.Position
         * @instance
         */
        Position.prototype.tdBuyQty = 0;

        /**
         * Position tdSellVal.
         * @member {number} tdSellVal
         * @memberof Trd_Common.Position
         * @instance
         */
        Position.prototype.tdSellVal = 0;

        /**
         * Position tdSellQty.
         * @member {number} tdSellQty
         * @memberof Trd_Common.Position
         * @instance
         */
        Position.prototype.tdSellQty = 0;

        /**
         * Creates a new Position instance using the specified properties.
         * @function create
         * @memberof Trd_Common.Position
         * @static
         * @param {Trd_Common.IPosition=} [properties] Properties to set
         * @returns {Trd_Common.Position} Position instance
         */
        Position.create = function create(properties) {
            return new Position(properties);
        };

        /**
         * Encodes the specified Position message. Does not implicitly {@link Trd_Common.Position.verify|verify} messages.
         * @function encode
         * @memberof Trd_Common.Position
         * @static
         * @param {Trd_Common.IPosition} message Position message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Position.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.positionID);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.positionSide);
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.code);
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.name);
            writer.uint32(/* id 5, wireType 1 =*/41).double(message.qty);
            writer.uint32(/* id 6, wireType 1 =*/49).double(message.canSellQty);
            writer.uint32(/* id 7, wireType 1 =*/57).double(message.price);
            if (message.costPrice != null && message.hasOwnProperty("costPrice"))
                writer.uint32(/* id 8, wireType 1 =*/65).double(message.costPrice);
            writer.uint32(/* id 9, wireType 1 =*/73).double(message.val);
            writer.uint32(/* id 10, wireType 1 =*/81).double(message.plVal);
            if (message.plRatio != null && message.hasOwnProperty("plRatio"))
                writer.uint32(/* id 11, wireType 1 =*/89).double(message.plRatio);
            if (message.secMarket != null && message.hasOwnProperty("secMarket"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.secMarket);
            if (message.tdPlVal != null && message.hasOwnProperty("tdPlVal"))
                writer.uint32(/* id 21, wireType 1 =*/169).double(message.tdPlVal);
            if (message.tdTrdVal != null && message.hasOwnProperty("tdTrdVal"))
                writer.uint32(/* id 22, wireType 1 =*/177).double(message.tdTrdVal);
            if (message.tdBuyVal != null && message.hasOwnProperty("tdBuyVal"))
                writer.uint32(/* id 23, wireType 1 =*/185).double(message.tdBuyVal);
            if (message.tdBuyQty != null && message.hasOwnProperty("tdBuyQty"))
                writer.uint32(/* id 24, wireType 1 =*/193).double(message.tdBuyQty);
            if (message.tdSellVal != null && message.hasOwnProperty("tdSellVal"))
                writer.uint32(/* id 25, wireType 1 =*/201).double(message.tdSellVal);
            if (message.tdSellQty != null && message.hasOwnProperty("tdSellQty"))
                writer.uint32(/* id 26, wireType 1 =*/209).double(message.tdSellQty);
            return writer;
        };

        /**
         * Encodes the specified Position message, length delimited. Does not implicitly {@link Trd_Common.Position.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_Common.Position
         * @static
         * @param {Trd_Common.IPosition} message Position message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Position.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Position message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_Common.Position
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_Common.Position} Position
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Position.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_Common.Position();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.positionID = reader.uint64();
                    break;
                case 2:
                    message.positionSide = reader.int32();
                    break;
                case 3:
                    message.code = reader.string();
                    break;
                case 4:
                    message.name = reader.string();
                    break;
                case 5:
                    message.qty = reader.double();
                    break;
                case 6:
                    message.canSellQty = reader.double();
                    break;
                case 7:
                    message.price = reader.double();
                    break;
                case 8:
                    message.costPrice = reader.double();
                    break;
                case 9:
                    message.val = reader.double();
                    break;
                case 10:
                    message.plVal = reader.double();
                    break;
                case 11:
                    message.plRatio = reader.double();
                    break;
                case 12:
                    message.secMarket = reader.int32();
                    break;
                case 21:
                    message.tdPlVal = reader.double();
                    break;
                case 22:
                    message.tdTrdVal = reader.double();
                    break;
                case 23:
                    message.tdBuyVal = reader.double();
                    break;
                case 24:
                    message.tdBuyQty = reader.double();
                    break;
                case 25:
                    message.tdSellVal = reader.double();
                    break;
                case 26:
                    message.tdSellQty = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("positionID"))
                throw $util.ProtocolError("missing required 'positionID'", { instance: message });
            if (!message.hasOwnProperty("positionSide"))
                throw $util.ProtocolError("missing required 'positionSide'", { instance: message });
            if (!message.hasOwnProperty("code"))
                throw $util.ProtocolError("missing required 'code'", { instance: message });
            if (!message.hasOwnProperty("name"))
                throw $util.ProtocolError("missing required 'name'", { instance: message });
            if (!message.hasOwnProperty("qty"))
                throw $util.ProtocolError("missing required 'qty'", { instance: message });
            if (!message.hasOwnProperty("canSellQty"))
                throw $util.ProtocolError("missing required 'canSellQty'", { instance: message });
            if (!message.hasOwnProperty("price"))
                throw $util.ProtocolError("missing required 'price'", { instance: message });
            if (!message.hasOwnProperty("val"))
                throw $util.ProtocolError("missing required 'val'", { instance: message });
            if (!message.hasOwnProperty("plVal"))
                throw $util.ProtocolError("missing required 'plVal'", { instance: message });
            return message;
        };

        /**
         * Decodes a Position message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_Common.Position
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_Common.Position} Position
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Position.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Position message.
         * @function verify
         * @memberof Trd_Common.Position
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Position.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.positionID) && !(message.positionID && $util.isInteger(message.positionID.low) && $util.isInteger(message.positionID.high)))
                return "positionID: integer|Long expected";
            if (!$util.isInteger(message.positionSide))
                return "positionSide: integer expected";
            if (!$util.isString(message.code))
                return "code: string expected";
            if (!$util.isString(message.name))
                return "name: string expected";
            if (typeof message.qty !== "number")
                return "qty: number expected";
            if (typeof message.canSellQty !== "number")
                return "canSellQty: number expected";
            if (typeof message.price !== "number")
                return "price: number expected";
            if (message.costPrice != null && message.hasOwnProperty("costPrice"))
                if (typeof message.costPrice !== "number")
                    return "costPrice: number expected";
            if (typeof message.val !== "number")
                return "val: number expected";
            if (typeof message.plVal !== "number")
                return "plVal: number expected";
            if (message.plRatio != null && message.hasOwnProperty("plRatio"))
                if (typeof message.plRatio !== "number")
                    return "plRatio: number expected";
            if (message.secMarket != null && message.hasOwnProperty("secMarket"))
                if (!$util.isInteger(message.secMarket))
                    return "secMarket: integer expected";
            if (message.tdPlVal != null && message.hasOwnProperty("tdPlVal"))
                if (typeof message.tdPlVal !== "number")
                    return "tdPlVal: number expected";
            if (message.tdTrdVal != null && message.hasOwnProperty("tdTrdVal"))
                if (typeof message.tdTrdVal !== "number")
                    return "tdTrdVal: number expected";
            if (message.tdBuyVal != null && message.hasOwnProperty("tdBuyVal"))
                if (typeof message.tdBuyVal !== "number")
                    return "tdBuyVal: number expected";
            if (message.tdBuyQty != null && message.hasOwnProperty("tdBuyQty"))
                if (typeof message.tdBuyQty !== "number")
                    return "tdBuyQty: number expected";
            if (message.tdSellVal != null && message.hasOwnProperty("tdSellVal"))
                if (typeof message.tdSellVal !== "number")
                    return "tdSellVal: number expected";
            if (message.tdSellQty != null && message.hasOwnProperty("tdSellQty"))
                if (typeof message.tdSellQty !== "number")
                    return "tdSellQty: number expected";
            return null;
        };

        /**
         * Creates a Position message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_Common.Position
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_Common.Position} Position
         */
        Position.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_Common.Position)
                return object;
            var message = new $root.Trd_Common.Position();
            if (object.positionID != null)
                if ($util.Long)
                    (message.positionID = $util.Long.fromValue(object.positionID)).unsigned = true;
                else if (typeof object.positionID === "string")
                    message.positionID = parseInt(object.positionID, 10);
                else if (typeof object.positionID === "number")
                    message.positionID = object.positionID;
                else if (typeof object.positionID === "object")
                    message.positionID = new $util.LongBits(object.positionID.low >>> 0, object.positionID.high >>> 0).toNumber(true);
            if (object.positionSide != null)
                message.positionSide = object.positionSide | 0;
            if (object.code != null)
                message.code = String(object.code);
            if (object.name != null)
                message.name = String(object.name);
            if (object.qty != null)
                message.qty = Number(object.qty);
            if (object.canSellQty != null)
                message.canSellQty = Number(object.canSellQty);
            if (object.price != null)
                message.price = Number(object.price);
            if (object.costPrice != null)
                message.costPrice = Number(object.costPrice);
            if (object.val != null)
                message.val = Number(object.val);
            if (object.plVal != null)
                message.plVal = Number(object.plVal);
            if (object.plRatio != null)
                message.plRatio = Number(object.plRatio);
            if (object.secMarket != null)
                message.secMarket = object.secMarket | 0;
            if (object.tdPlVal != null)
                message.tdPlVal = Number(object.tdPlVal);
            if (object.tdTrdVal != null)
                message.tdTrdVal = Number(object.tdTrdVal);
            if (object.tdBuyVal != null)
                message.tdBuyVal = Number(object.tdBuyVal);
            if (object.tdBuyQty != null)
                message.tdBuyQty = Number(object.tdBuyQty);
            if (object.tdSellVal != null)
                message.tdSellVal = Number(object.tdSellVal);
            if (object.tdSellQty != null)
                message.tdSellQty = Number(object.tdSellQty);
            return message;
        };

        /**
         * Creates a plain object from a Position message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_Common.Position
         * @static
         * @param {Trd_Common.Position} message Position
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Position.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.positionID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.positionID = options.longs === String ? "0" : 0;
                object.positionSide = 0;
                object.code = "";
                object.name = "";
                object.qty = 0;
                object.canSellQty = 0;
                object.price = 0;
                object.costPrice = 0;
                object.val = 0;
                object.plVal = 0;
                object.plRatio = 0;
                object.secMarket = 0;
                object.tdPlVal = 0;
                object.tdTrdVal = 0;
                object.tdBuyVal = 0;
                object.tdBuyQty = 0;
                object.tdSellVal = 0;
                object.tdSellQty = 0;
            }
            if (message.positionID != null && message.hasOwnProperty("positionID"))
                if (typeof message.positionID === "number")
                    object.positionID = options.longs === String ? String(message.positionID) : message.positionID;
                else
                    object.positionID = options.longs === String ? $util.Long.prototype.toString.call(message.positionID) : options.longs === Number ? new $util.LongBits(message.positionID.low >>> 0, message.positionID.high >>> 0).toNumber(true) : message.positionID;
            if (message.positionSide != null && message.hasOwnProperty("positionSide"))
                object.positionSide = message.positionSide;
            if (message.code != null && message.hasOwnProperty("code"))
                object.code = message.code;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.qty != null && message.hasOwnProperty("qty"))
                object.qty = options.json && !isFinite(message.qty) ? String(message.qty) : message.qty;
            if (message.canSellQty != null && message.hasOwnProperty("canSellQty"))
                object.canSellQty = options.json && !isFinite(message.canSellQty) ? String(message.canSellQty) : message.canSellQty;
            if (message.price != null && message.hasOwnProperty("price"))
                object.price = options.json && !isFinite(message.price) ? String(message.price) : message.price;
            if (message.costPrice != null && message.hasOwnProperty("costPrice"))
                object.costPrice = options.json && !isFinite(message.costPrice) ? String(message.costPrice) : message.costPrice;
            if (message.val != null && message.hasOwnProperty("val"))
                object.val = options.json && !isFinite(message.val) ? String(message.val) : message.val;
            if (message.plVal != null && message.hasOwnProperty("plVal"))
                object.plVal = options.json && !isFinite(message.plVal) ? String(message.plVal) : message.plVal;
            if (message.plRatio != null && message.hasOwnProperty("plRatio"))
                object.plRatio = options.json && !isFinite(message.plRatio) ? String(message.plRatio) : message.plRatio;
            if (message.secMarket != null && message.hasOwnProperty("secMarket"))
                object.secMarket = message.secMarket;
            if (message.tdPlVal != null && message.hasOwnProperty("tdPlVal"))
                object.tdPlVal = options.json && !isFinite(message.tdPlVal) ? String(message.tdPlVal) : message.tdPlVal;
            if (message.tdTrdVal != null && message.hasOwnProperty("tdTrdVal"))
                object.tdTrdVal = options.json && !isFinite(message.tdTrdVal) ? String(message.tdTrdVal) : message.tdTrdVal;
            if (message.tdBuyVal != null && message.hasOwnProperty("tdBuyVal"))
                object.tdBuyVal = options.json && !isFinite(message.tdBuyVal) ? String(message.tdBuyVal) : message.tdBuyVal;
            if (message.tdBuyQty != null && message.hasOwnProperty("tdBuyQty"))
                object.tdBuyQty = options.json && !isFinite(message.tdBuyQty) ? String(message.tdBuyQty) : message.tdBuyQty;
            if (message.tdSellVal != null && message.hasOwnProperty("tdSellVal"))
                object.tdSellVal = options.json && !isFinite(message.tdSellVal) ? String(message.tdSellVal) : message.tdSellVal;
            if (message.tdSellQty != null && message.hasOwnProperty("tdSellQty"))
                object.tdSellQty = options.json && !isFinite(message.tdSellQty) ? String(message.tdSellQty) : message.tdSellQty;
            return object;
        };

        /**
         * Converts this Position to JSON.
         * @function toJSON
         * @memberof Trd_Common.Position
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Position.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Position;
    })();

    Trd_Common.Order = (function() {

        /**
         * Properties of an Order.
         * @memberof Trd_Common
         * @interface IOrder
         * @property {number} trdSide Order trdSide
         * @property {number} orderType Order orderType
         * @property {number} orderStatus Order orderStatus
         * @property {number|Long} orderID Order orderID
         * @property {string} orderIDEx Order orderIDEx
         * @property {string} code Order code
         * @property {string} name Order name
         * @property {number} qty Order qty
         * @property {number|null} [price] Order price
         * @property {string} createTime Order createTime
         * @property {string} updateTime Order updateTime
         * @property {number|null} [fillQty] Order fillQty
         * @property {number|null} [fillAvgPrice] Order fillAvgPrice
         * @property {string|null} [lastErrMsg] Order lastErrMsg
         * @property {number|null} [secMarket] Order secMarket
         * @property {number|null} [createTimestamp] Order createTimestamp
         * @property {number|null} [updateTimestamp] Order updateTimestamp
         */

        /**
         * Constructs a new Order.
         * @memberof Trd_Common
         * @classdesc Represents an Order.
         * @implements IOrder
         * @constructor
         * @param {Trd_Common.IOrder=} [properties] Properties to set
         */
        function Order(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Order trdSide.
         * @member {number} trdSide
         * @memberof Trd_Common.Order
         * @instance
         */
        Order.prototype.trdSide = 0;

        /**
         * Order orderType.
         * @member {number} orderType
         * @memberof Trd_Common.Order
         * @instance
         */
        Order.prototype.orderType = 0;

        /**
         * Order orderStatus.
         * @member {number} orderStatus
         * @memberof Trd_Common.Order
         * @instance
         */
        Order.prototype.orderStatus = 0;

        /**
         * Order orderID.
         * @member {number|Long} orderID
         * @memberof Trd_Common.Order
         * @instance
         */
        Order.prototype.orderID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Order orderIDEx.
         * @member {string} orderIDEx
         * @memberof Trd_Common.Order
         * @instance
         */
        Order.prototype.orderIDEx = "";

        /**
         * Order code.
         * @member {string} code
         * @memberof Trd_Common.Order
         * @instance
         */
        Order.prototype.code = "";

        /**
         * Order name.
         * @member {string} name
         * @memberof Trd_Common.Order
         * @instance
         */
        Order.prototype.name = "";

        /**
         * Order qty.
         * @member {number} qty
         * @memberof Trd_Common.Order
         * @instance
         */
        Order.prototype.qty = 0;

        /**
         * Order price.
         * @member {number} price
         * @memberof Trd_Common.Order
         * @instance
         */
        Order.prototype.price = 0;

        /**
         * Order createTime.
         * @member {string} createTime
         * @memberof Trd_Common.Order
         * @instance
         */
        Order.prototype.createTime = "";

        /**
         * Order updateTime.
         * @member {string} updateTime
         * @memberof Trd_Common.Order
         * @instance
         */
        Order.prototype.updateTime = "";

        /**
         * Order fillQty.
         * @member {number} fillQty
         * @memberof Trd_Common.Order
         * @instance
         */
        Order.prototype.fillQty = 0;

        /**
         * Order fillAvgPrice.
         * @member {number} fillAvgPrice
         * @memberof Trd_Common.Order
         * @instance
         */
        Order.prototype.fillAvgPrice = 0;

        /**
         * Order lastErrMsg.
         * @member {string} lastErrMsg
         * @memberof Trd_Common.Order
         * @instance
         */
        Order.prototype.lastErrMsg = "";

        /**
         * Order secMarket.
         * @member {number} secMarket
         * @memberof Trd_Common.Order
         * @instance
         */
        Order.prototype.secMarket = 0;

        /**
         * Order createTimestamp.
         * @member {number} createTimestamp
         * @memberof Trd_Common.Order
         * @instance
         */
        Order.prototype.createTimestamp = 0;

        /**
         * Order updateTimestamp.
         * @member {number} updateTimestamp
         * @memberof Trd_Common.Order
         * @instance
         */
        Order.prototype.updateTimestamp = 0;

        /**
         * Creates a new Order instance using the specified properties.
         * @function create
         * @memberof Trd_Common.Order
         * @static
         * @param {Trd_Common.IOrder=} [properties] Properties to set
         * @returns {Trd_Common.Order} Order instance
         */
        Order.create = function create(properties) {
            return new Order(properties);
        };

        /**
         * Encodes the specified Order message. Does not implicitly {@link Trd_Common.Order.verify|verify} messages.
         * @function encode
         * @memberof Trd_Common.Order
         * @static
         * @param {Trd_Common.IOrder} message Order message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Order.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.trdSide);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.orderType);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.orderStatus);
            writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.orderID);
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.orderIDEx);
            writer.uint32(/* id 6, wireType 2 =*/50).string(message.code);
            writer.uint32(/* id 7, wireType 2 =*/58).string(message.name);
            writer.uint32(/* id 8, wireType 1 =*/65).double(message.qty);
            if (message.price != null && message.hasOwnProperty("price"))
                writer.uint32(/* id 9, wireType 1 =*/73).double(message.price);
            writer.uint32(/* id 10, wireType 2 =*/82).string(message.createTime);
            writer.uint32(/* id 11, wireType 2 =*/90).string(message.updateTime);
            if (message.fillQty != null && message.hasOwnProperty("fillQty"))
                writer.uint32(/* id 12, wireType 1 =*/97).double(message.fillQty);
            if (message.fillAvgPrice != null && message.hasOwnProperty("fillAvgPrice"))
                writer.uint32(/* id 13, wireType 1 =*/105).double(message.fillAvgPrice);
            if (message.lastErrMsg != null && message.hasOwnProperty("lastErrMsg"))
                writer.uint32(/* id 14, wireType 2 =*/114).string(message.lastErrMsg);
            if (message.secMarket != null && message.hasOwnProperty("secMarket"))
                writer.uint32(/* id 15, wireType 0 =*/120).int32(message.secMarket);
            if (message.createTimestamp != null && message.hasOwnProperty("createTimestamp"))
                writer.uint32(/* id 16, wireType 1 =*/129).double(message.createTimestamp);
            if (message.updateTimestamp != null && message.hasOwnProperty("updateTimestamp"))
                writer.uint32(/* id 17, wireType 1 =*/137).double(message.updateTimestamp);
            return writer;
        };

        /**
         * Encodes the specified Order message, length delimited. Does not implicitly {@link Trd_Common.Order.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_Common.Order
         * @static
         * @param {Trd_Common.IOrder} message Order message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Order.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Order message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_Common.Order
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_Common.Order} Order
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Order.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_Common.Order();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.trdSide = reader.int32();
                    break;
                case 2:
                    message.orderType = reader.int32();
                    break;
                case 3:
                    message.orderStatus = reader.int32();
                    break;
                case 4:
                    message.orderID = reader.uint64();
                    break;
                case 5:
                    message.orderIDEx = reader.string();
                    break;
                case 6:
                    message.code = reader.string();
                    break;
                case 7:
                    message.name = reader.string();
                    break;
                case 8:
                    message.qty = reader.double();
                    break;
                case 9:
                    message.price = reader.double();
                    break;
                case 10:
                    message.createTime = reader.string();
                    break;
                case 11:
                    message.updateTime = reader.string();
                    break;
                case 12:
                    message.fillQty = reader.double();
                    break;
                case 13:
                    message.fillAvgPrice = reader.double();
                    break;
                case 14:
                    message.lastErrMsg = reader.string();
                    break;
                case 15:
                    message.secMarket = reader.int32();
                    break;
                case 16:
                    message.createTimestamp = reader.double();
                    break;
                case 17:
                    message.updateTimestamp = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("trdSide"))
                throw $util.ProtocolError("missing required 'trdSide'", { instance: message });
            if (!message.hasOwnProperty("orderType"))
                throw $util.ProtocolError("missing required 'orderType'", { instance: message });
            if (!message.hasOwnProperty("orderStatus"))
                throw $util.ProtocolError("missing required 'orderStatus'", { instance: message });
            if (!message.hasOwnProperty("orderID"))
                throw $util.ProtocolError("missing required 'orderID'", { instance: message });
            if (!message.hasOwnProperty("orderIDEx"))
                throw $util.ProtocolError("missing required 'orderIDEx'", { instance: message });
            if (!message.hasOwnProperty("code"))
                throw $util.ProtocolError("missing required 'code'", { instance: message });
            if (!message.hasOwnProperty("name"))
                throw $util.ProtocolError("missing required 'name'", { instance: message });
            if (!message.hasOwnProperty("qty"))
                throw $util.ProtocolError("missing required 'qty'", { instance: message });
            if (!message.hasOwnProperty("createTime"))
                throw $util.ProtocolError("missing required 'createTime'", { instance: message });
            if (!message.hasOwnProperty("updateTime"))
                throw $util.ProtocolError("missing required 'updateTime'", { instance: message });
            return message;
        };

        /**
         * Decodes an Order message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_Common.Order
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_Common.Order} Order
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Order.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Order message.
         * @function verify
         * @memberof Trd_Common.Order
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Order.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.trdSide))
                return "trdSide: integer expected";
            if (!$util.isInteger(message.orderType))
                return "orderType: integer expected";
            if (!$util.isInteger(message.orderStatus))
                return "orderStatus: integer expected";
            if (!$util.isInteger(message.orderID) && !(message.orderID && $util.isInteger(message.orderID.low) && $util.isInteger(message.orderID.high)))
                return "orderID: integer|Long expected";
            if (!$util.isString(message.orderIDEx))
                return "orderIDEx: string expected";
            if (!$util.isString(message.code))
                return "code: string expected";
            if (!$util.isString(message.name))
                return "name: string expected";
            if (typeof message.qty !== "number")
                return "qty: number expected";
            if (message.price != null && message.hasOwnProperty("price"))
                if (typeof message.price !== "number")
                    return "price: number expected";
            if (!$util.isString(message.createTime))
                return "createTime: string expected";
            if (!$util.isString(message.updateTime))
                return "updateTime: string expected";
            if (message.fillQty != null && message.hasOwnProperty("fillQty"))
                if (typeof message.fillQty !== "number")
                    return "fillQty: number expected";
            if (message.fillAvgPrice != null && message.hasOwnProperty("fillAvgPrice"))
                if (typeof message.fillAvgPrice !== "number")
                    return "fillAvgPrice: number expected";
            if (message.lastErrMsg != null && message.hasOwnProperty("lastErrMsg"))
                if (!$util.isString(message.lastErrMsg))
                    return "lastErrMsg: string expected";
            if (message.secMarket != null && message.hasOwnProperty("secMarket"))
                if (!$util.isInteger(message.secMarket))
                    return "secMarket: integer expected";
            if (message.createTimestamp != null && message.hasOwnProperty("createTimestamp"))
                if (typeof message.createTimestamp !== "number")
                    return "createTimestamp: number expected";
            if (message.updateTimestamp != null && message.hasOwnProperty("updateTimestamp"))
                if (typeof message.updateTimestamp !== "number")
                    return "updateTimestamp: number expected";
            return null;
        };

        /**
         * Creates an Order message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_Common.Order
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_Common.Order} Order
         */
        Order.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_Common.Order)
                return object;
            var message = new $root.Trd_Common.Order();
            if (object.trdSide != null)
                message.trdSide = object.trdSide | 0;
            if (object.orderType != null)
                message.orderType = object.orderType | 0;
            if (object.orderStatus != null)
                message.orderStatus = object.orderStatus | 0;
            if (object.orderID != null)
                if ($util.Long)
                    (message.orderID = $util.Long.fromValue(object.orderID)).unsigned = true;
                else if (typeof object.orderID === "string")
                    message.orderID = parseInt(object.orderID, 10);
                else if (typeof object.orderID === "number")
                    message.orderID = object.orderID;
                else if (typeof object.orderID === "object")
                    message.orderID = new $util.LongBits(object.orderID.low >>> 0, object.orderID.high >>> 0).toNumber(true);
            if (object.orderIDEx != null)
                message.orderIDEx = String(object.orderIDEx);
            if (object.code != null)
                message.code = String(object.code);
            if (object.name != null)
                message.name = String(object.name);
            if (object.qty != null)
                message.qty = Number(object.qty);
            if (object.price != null)
                message.price = Number(object.price);
            if (object.createTime != null)
                message.createTime = String(object.createTime);
            if (object.updateTime != null)
                message.updateTime = String(object.updateTime);
            if (object.fillQty != null)
                message.fillQty = Number(object.fillQty);
            if (object.fillAvgPrice != null)
                message.fillAvgPrice = Number(object.fillAvgPrice);
            if (object.lastErrMsg != null)
                message.lastErrMsg = String(object.lastErrMsg);
            if (object.secMarket != null)
                message.secMarket = object.secMarket | 0;
            if (object.createTimestamp != null)
                message.createTimestamp = Number(object.createTimestamp);
            if (object.updateTimestamp != null)
                message.updateTimestamp = Number(object.updateTimestamp);
            return message;
        };

        /**
         * Creates a plain object from an Order message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_Common.Order
         * @static
         * @param {Trd_Common.Order} message Order
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Order.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.trdSide = 0;
                object.orderType = 0;
                object.orderStatus = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.orderID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.orderID = options.longs === String ? "0" : 0;
                object.orderIDEx = "";
                object.code = "";
                object.name = "";
                object.qty = 0;
                object.price = 0;
                object.createTime = "";
                object.updateTime = "";
                object.fillQty = 0;
                object.fillAvgPrice = 0;
                object.lastErrMsg = "";
                object.secMarket = 0;
                object.createTimestamp = 0;
                object.updateTimestamp = 0;
            }
            if (message.trdSide != null && message.hasOwnProperty("trdSide"))
                object.trdSide = message.trdSide;
            if (message.orderType != null && message.hasOwnProperty("orderType"))
                object.orderType = message.orderType;
            if (message.orderStatus != null && message.hasOwnProperty("orderStatus"))
                object.orderStatus = message.orderStatus;
            if (message.orderID != null && message.hasOwnProperty("orderID"))
                if (typeof message.orderID === "number")
                    object.orderID = options.longs === String ? String(message.orderID) : message.orderID;
                else
                    object.orderID = options.longs === String ? $util.Long.prototype.toString.call(message.orderID) : options.longs === Number ? new $util.LongBits(message.orderID.low >>> 0, message.orderID.high >>> 0).toNumber(true) : message.orderID;
            if (message.orderIDEx != null && message.hasOwnProperty("orderIDEx"))
                object.orderIDEx = message.orderIDEx;
            if (message.code != null && message.hasOwnProperty("code"))
                object.code = message.code;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.qty != null && message.hasOwnProperty("qty"))
                object.qty = options.json && !isFinite(message.qty) ? String(message.qty) : message.qty;
            if (message.price != null && message.hasOwnProperty("price"))
                object.price = options.json && !isFinite(message.price) ? String(message.price) : message.price;
            if (message.createTime != null && message.hasOwnProperty("createTime"))
                object.createTime = message.createTime;
            if (message.updateTime != null && message.hasOwnProperty("updateTime"))
                object.updateTime = message.updateTime;
            if (message.fillQty != null && message.hasOwnProperty("fillQty"))
                object.fillQty = options.json && !isFinite(message.fillQty) ? String(message.fillQty) : message.fillQty;
            if (message.fillAvgPrice != null && message.hasOwnProperty("fillAvgPrice"))
                object.fillAvgPrice = options.json && !isFinite(message.fillAvgPrice) ? String(message.fillAvgPrice) : message.fillAvgPrice;
            if (message.lastErrMsg != null && message.hasOwnProperty("lastErrMsg"))
                object.lastErrMsg = message.lastErrMsg;
            if (message.secMarket != null && message.hasOwnProperty("secMarket"))
                object.secMarket = message.secMarket;
            if (message.createTimestamp != null && message.hasOwnProperty("createTimestamp"))
                object.createTimestamp = options.json && !isFinite(message.createTimestamp) ? String(message.createTimestamp) : message.createTimestamp;
            if (message.updateTimestamp != null && message.hasOwnProperty("updateTimestamp"))
                object.updateTimestamp = options.json && !isFinite(message.updateTimestamp) ? String(message.updateTimestamp) : message.updateTimestamp;
            return object;
        };

        /**
         * Converts this Order to JSON.
         * @function toJSON
         * @memberof Trd_Common.Order
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Order.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Order;
    })();

    Trd_Common.OrderFill = (function() {

        /**
         * Properties of an OrderFill.
         * @memberof Trd_Common
         * @interface IOrderFill
         * @property {number} trdSide OrderFill trdSide
         * @property {number|Long} fillID OrderFill fillID
         * @property {string} fillIDEx OrderFill fillIDEx
         * @property {number|Long|null} [orderID] OrderFill orderID
         * @property {string|null} [orderIDEx] OrderFill orderIDEx
         * @property {string} code OrderFill code
         * @property {string} name OrderFill name
         * @property {number} qty OrderFill qty
         * @property {number} price OrderFill price
         * @property {string} createTime OrderFill createTime
         * @property {number|null} [counterBrokerID] OrderFill counterBrokerID
         * @property {string|null} [counterBrokerName] OrderFill counterBrokerName
         * @property {number|null} [secMarket] OrderFill secMarket
         * @property {number|null} [createTimestamp] OrderFill createTimestamp
         */

        /**
         * Constructs a new OrderFill.
         * @memberof Trd_Common
         * @classdesc Represents an OrderFill.
         * @implements IOrderFill
         * @constructor
         * @param {Trd_Common.IOrderFill=} [properties] Properties to set
         */
        function OrderFill(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OrderFill trdSide.
         * @member {number} trdSide
         * @memberof Trd_Common.OrderFill
         * @instance
         */
        OrderFill.prototype.trdSide = 0;

        /**
         * OrderFill fillID.
         * @member {number|Long} fillID
         * @memberof Trd_Common.OrderFill
         * @instance
         */
        OrderFill.prototype.fillID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * OrderFill fillIDEx.
         * @member {string} fillIDEx
         * @memberof Trd_Common.OrderFill
         * @instance
         */
        OrderFill.prototype.fillIDEx = "";

        /**
         * OrderFill orderID.
         * @member {number|Long} orderID
         * @memberof Trd_Common.OrderFill
         * @instance
         */
        OrderFill.prototype.orderID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * OrderFill orderIDEx.
         * @member {string} orderIDEx
         * @memberof Trd_Common.OrderFill
         * @instance
         */
        OrderFill.prototype.orderIDEx = "";

        /**
         * OrderFill code.
         * @member {string} code
         * @memberof Trd_Common.OrderFill
         * @instance
         */
        OrderFill.prototype.code = "";

        /**
         * OrderFill name.
         * @member {string} name
         * @memberof Trd_Common.OrderFill
         * @instance
         */
        OrderFill.prototype.name = "";

        /**
         * OrderFill qty.
         * @member {number} qty
         * @memberof Trd_Common.OrderFill
         * @instance
         */
        OrderFill.prototype.qty = 0;

        /**
         * OrderFill price.
         * @member {number} price
         * @memberof Trd_Common.OrderFill
         * @instance
         */
        OrderFill.prototype.price = 0;

        /**
         * OrderFill createTime.
         * @member {string} createTime
         * @memberof Trd_Common.OrderFill
         * @instance
         */
        OrderFill.prototype.createTime = "";

        /**
         * OrderFill counterBrokerID.
         * @member {number} counterBrokerID
         * @memberof Trd_Common.OrderFill
         * @instance
         */
        OrderFill.prototype.counterBrokerID = 0;

        /**
         * OrderFill counterBrokerName.
         * @member {string} counterBrokerName
         * @memberof Trd_Common.OrderFill
         * @instance
         */
        OrderFill.prototype.counterBrokerName = "";

        /**
         * OrderFill secMarket.
         * @member {number} secMarket
         * @memberof Trd_Common.OrderFill
         * @instance
         */
        OrderFill.prototype.secMarket = 0;

        /**
         * OrderFill createTimestamp.
         * @member {number} createTimestamp
         * @memberof Trd_Common.OrderFill
         * @instance
         */
        OrderFill.prototype.createTimestamp = 0;

        /**
         * Creates a new OrderFill instance using the specified properties.
         * @function create
         * @memberof Trd_Common.OrderFill
         * @static
         * @param {Trd_Common.IOrderFill=} [properties] Properties to set
         * @returns {Trd_Common.OrderFill} OrderFill instance
         */
        OrderFill.create = function create(properties) {
            return new OrderFill(properties);
        };

        /**
         * Encodes the specified OrderFill message. Does not implicitly {@link Trd_Common.OrderFill.verify|verify} messages.
         * @function encode
         * @memberof Trd_Common.OrderFill
         * @static
         * @param {Trd_Common.IOrderFill} message OrderFill message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OrderFill.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.trdSide);
            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.fillID);
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.fillIDEx);
            if (message.orderID != null && message.hasOwnProperty("orderID"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.orderID);
            if (message.orderIDEx != null && message.hasOwnProperty("orderIDEx"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.orderIDEx);
            writer.uint32(/* id 6, wireType 2 =*/50).string(message.code);
            writer.uint32(/* id 7, wireType 2 =*/58).string(message.name);
            writer.uint32(/* id 8, wireType 1 =*/65).double(message.qty);
            writer.uint32(/* id 9, wireType 1 =*/73).double(message.price);
            writer.uint32(/* id 10, wireType 2 =*/82).string(message.createTime);
            if (message.counterBrokerID != null && message.hasOwnProperty("counterBrokerID"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.counterBrokerID);
            if (message.counterBrokerName != null && message.hasOwnProperty("counterBrokerName"))
                writer.uint32(/* id 12, wireType 2 =*/98).string(message.counterBrokerName);
            if (message.secMarket != null && message.hasOwnProperty("secMarket"))
                writer.uint32(/* id 13, wireType 0 =*/104).int32(message.secMarket);
            if (message.createTimestamp != null && message.hasOwnProperty("createTimestamp"))
                writer.uint32(/* id 14, wireType 1 =*/113).double(message.createTimestamp);
            return writer;
        };

        /**
         * Encodes the specified OrderFill message, length delimited. Does not implicitly {@link Trd_Common.OrderFill.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_Common.OrderFill
         * @static
         * @param {Trd_Common.IOrderFill} message OrderFill message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OrderFill.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OrderFill message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_Common.OrderFill
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_Common.OrderFill} OrderFill
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OrderFill.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_Common.OrderFill();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.trdSide = reader.int32();
                    break;
                case 2:
                    message.fillID = reader.uint64();
                    break;
                case 3:
                    message.fillIDEx = reader.string();
                    break;
                case 4:
                    message.orderID = reader.uint64();
                    break;
                case 5:
                    message.orderIDEx = reader.string();
                    break;
                case 6:
                    message.code = reader.string();
                    break;
                case 7:
                    message.name = reader.string();
                    break;
                case 8:
                    message.qty = reader.double();
                    break;
                case 9:
                    message.price = reader.double();
                    break;
                case 10:
                    message.createTime = reader.string();
                    break;
                case 11:
                    message.counterBrokerID = reader.int32();
                    break;
                case 12:
                    message.counterBrokerName = reader.string();
                    break;
                case 13:
                    message.secMarket = reader.int32();
                    break;
                case 14:
                    message.createTimestamp = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("trdSide"))
                throw $util.ProtocolError("missing required 'trdSide'", { instance: message });
            if (!message.hasOwnProperty("fillID"))
                throw $util.ProtocolError("missing required 'fillID'", { instance: message });
            if (!message.hasOwnProperty("fillIDEx"))
                throw $util.ProtocolError("missing required 'fillIDEx'", { instance: message });
            if (!message.hasOwnProperty("code"))
                throw $util.ProtocolError("missing required 'code'", { instance: message });
            if (!message.hasOwnProperty("name"))
                throw $util.ProtocolError("missing required 'name'", { instance: message });
            if (!message.hasOwnProperty("qty"))
                throw $util.ProtocolError("missing required 'qty'", { instance: message });
            if (!message.hasOwnProperty("price"))
                throw $util.ProtocolError("missing required 'price'", { instance: message });
            if (!message.hasOwnProperty("createTime"))
                throw $util.ProtocolError("missing required 'createTime'", { instance: message });
            return message;
        };

        /**
         * Decodes an OrderFill message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_Common.OrderFill
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_Common.OrderFill} OrderFill
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OrderFill.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OrderFill message.
         * @function verify
         * @memberof Trd_Common.OrderFill
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OrderFill.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.trdSide))
                return "trdSide: integer expected";
            if (!$util.isInteger(message.fillID) && !(message.fillID && $util.isInteger(message.fillID.low) && $util.isInteger(message.fillID.high)))
                return "fillID: integer|Long expected";
            if (!$util.isString(message.fillIDEx))
                return "fillIDEx: string expected";
            if (message.orderID != null && message.hasOwnProperty("orderID"))
                if (!$util.isInteger(message.orderID) && !(message.orderID && $util.isInteger(message.orderID.low) && $util.isInteger(message.orderID.high)))
                    return "orderID: integer|Long expected";
            if (message.orderIDEx != null && message.hasOwnProperty("orderIDEx"))
                if (!$util.isString(message.orderIDEx))
                    return "orderIDEx: string expected";
            if (!$util.isString(message.code))
                return "code: string expected";
            if (!$util.isString(message.name))
                return "name: string expected";
            if (typeof message.qty !== "number")
                return "qty: number expected";
            if (typeof message.price !== "number")
                return "price: number expected";
            if (!$util.isString(message.createTime))
                return "createTime: string expected";
            if (message.counterBrokerID != null && message.hasOwnProperty("counterBrokerID"))
                if (!$util.isInteger(message.counterBrokerID))
                    return "counterBrokerID: integer expected";
            if (message.counterBrokerName != null && message.hasOwnProperty("counterBrokerName"))
                if (!$util.isString(message.counterBrokerName))
                    return "counterBrokerName: string expected";
            if (message.secMarket != null && message.hasOwnProperty("secMarket"))
                if (!$util.isInteger(message.secMarket))
                    return "secMarket: integer expected";
            if (message.createTimestamp != null && message.hasOwnProperty("createTimestamp"))
                if (typeof message.createTimestamp !== "number")
                    return "createTimestamp: number expected";
            return null;
        };

        /**
         * Creates an OrderFill message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_Common.OrderFill
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_Common.OrderFill} OrderFill
         */
        OrderFill.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_Common.OrderFill)
                return object;
            var message = new $root.Trd_Common.OrderFill();
            if (object.trdSide != null)
                message.trdSide = object.trdSide | 0;
            if (object.fillID != null)
                if ($util.Long)
                    (message.fillID = $util.Long.fromValue(object.fillID)).unsigned = true;
                else if (typeof object.fillID === "string")
                    message.fillID = parseInt(object.fillID, 10);
                else if (typeof object.fillID === "number")
                    message.fillID = object.fillID;
                else if (typeof object.fillID === "object")
                    message.fillID = new $util.LongBits(object.fillID.low >>> 0, object.fillID.high >>> 0).toNumber(true);
            if (object.fillIDEx != null)
                message.fillIDEx = String(object.fillIDEx);
            if (object.orderID != null)
                if ($util.Long)
                    (message.orderID = $util.Long.fromValue(object.orderID)).unsigned = true;
                else if (typeof object.orderID === "string")
                    message.orderID = parseInt(object.orderID, 10);
                else if (typeof object.orderID === "number")
                    message.orderID = object.orderID;
                else if (typeof object.orderID === "object")
                    message.orderID = new $util.LongBits(object.orderID.low >>> 0, object.orderID.high >>> 0).toNumber(true);
            if (object.orderIDEx != null)
                message.orderIDEx = String(object.orderIDEx);
            if (object.code != null)
                message.code = String(object.code);
            if (object.name != null)
                message.name = String(object.name);
            if (object.qty != null)
                message.qty = Number(object.qty);
            if (object.price != null)
                message.price = Number(object.price);
            if (object.createTime != null)
                message.createTime = String(object.createTime);
            if (object.counterBrokerID != null)
                message.counterBrokerID = object.counterBrokerID | 0;
            if (object.counterBrokerName != null)
                message.counterBrokerName = String(object.counterBrokerName);
            if (object.secMarket != null)
                message.secMarket = object.secMarket | 0;
            if (object.createTimestamp != null)
                message.createTimestamp = Number(object.createTimestamp);
            return message;
        };

        /**
         * Creates a plain object from an OrderFill message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_Common.OrderFill
         * @static
         * @param {Trd_Common.OrderFill} message OrderFill
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OrderFill.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.trdSide = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.fillID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fillID = options.longs === String ? "0" : 0;
                object.fillIDEx = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.orderID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.orderID = options.longs === String ? "0" : 0;
                object.orderIDEx = "";
                object.code = "";
                object.name = "";
                object.qty = 0;
                object.price = 0;
                object.createTime = "";
                object.counterBrokerID = 0;
                object.counterBrokerName = "";
                object.secMarket = 0;
                object.createTimestamp = 0;
            }
            if (message.trdSide != null && message.hasOwnProperty("trdSide"))
                object.trdSide = message.trdSide;
            if (message.fillID != null && message.hasOwnProperty("fillID"))
                if (typeof message.fillID === "number")
                    object.fillID = options.longs === String ? String(message.fillID) : message.fillID;
                else
                    object.fillID = options.longs === String ? $util.Long.prototype.toString.call(message.fillID) : options.longs === Number ? new $util.LongBits(message.fillID.low >>> 0, message.fillID.high >>> 0).toNumber(true) : message.fillID;
            if (message.fillIDEx != null && message.hasOwnProperty("fillIDEx"))
                object.fillIDEx = message.fillIDEx;
            if (message.orderID != null && message.hasOwnProperty("orderID"))
                if (typeof message.orderID === "number")
                    object.orderID = options.longs === String ? String(message.orderID) : message.orderID;
                else
                    object.orderID = options.longs === String ? $util.Long.prototype.toString.call(message.orderID) : options.longs === Number ? new $util.LongBits(message.orderID.low >>> 0, message.orderID.high >>> 0).toNumber(true) : message.orderID;
            if (message.orderIDEx != null && message.hasOwnProperty("orderIDEx"))
                object.orderIDEx = message.orderIDEx;
            if (message.code != null && message.hasOwnProperty("code"))
                object.code = message.code;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.qty != null && message.hasOwnProperty("qty"))
                object.qty = options.json && !isFinite(message.qty) ? String(message.qty) : message.qty;
            if (message.price != null && message.hasOwnProperty("price"))
                object.price = options.json && !isFinite(message.price) ? String(message.price) : message.price;
            if (message.createTime != null && message.hasOwnProperty("createTime"))
                object.createTime = message.createTime;
            if (message.counterBrokerID != null && message.hasOwnProperty("counterBrokerID"))
                object.counterBrokerID = message.counterBrokerID;
            if (message.counterBrokerName != null && message.hasOwnProperty("counterBrokerName"))
                object.counterBrokerName = message.counterBrokerName;
            if (message.secMarket != null && message.hasOwnProperty("secMarket"))
                object.secMarket = message.secMarket;
            if (message.createTimestamp != null && message.hasOwnProperty("createTimestamp"))
                object.createTimestamp = options.json && !isFinite(message.createTimestamp) ? String(message.createTimestamp) : message.createTimestamp;
            return object;
        };

        /**
         * Converts this OrderFill to JSON.
         * @function toJSON
         * @memberof Trd_Common.OrderFill
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OrderFill.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return OrderFill;
    })();

    Trd_Common.MaxTrdQtys = (function() {

        /**
         * Properties of a MaxTrdQtys.
         * @memberof Trd_Common
         * @interface IMaxTrdQtys
         * @property {number} maxCashBuy MaxTrdQtys maxCashBuy
         * @property {number|null} [maxCashAndMarginBuy] MaxTrdQtys maxCashAndMarginBuy
         * @property {number} maxPositionSell MaxTrdQtys maxPositionSell
         * @property {number|null} [maxSellShort] MaxTrdQtys maxSellShort
         * @property {number|null} [maxBuyBack] MaxTrdQtys maxBuyBack
         */

        /**
         * Constructs a new MaxTrdQtys.
         * @memberof Trd_Common
         * @classdesc Represents a MaxTrdQtys.
         * @implements IMaxTrdQtys
         * @constructor
         * @param {Trd_Common.IMaxTrdQtys=} [properties] Properties to set
         */
        function MaxTrdQtys(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MaxTrdQtys maxCashBuy.
         * @member {number} maxCashBuy
         * @memberof Trd_Common.MaxTrdQtys
         * @instance
         */
        MaxTrdQtys.prototype.maxCashBuy = 0;

        /**
         * MaxTrdQtys maxCashAndMarginBuy.
         * @member {number} maxCashAndMarginBuy
         * @memberof Trd_Common.MaxTrdQtys
         * @instance
         */
        MaxTrdQtys.prototype.maxCashAndMarginBuy = 0;

        /**
         * MaxTrdQtys maxPositionSell.
         * @member {number} maxPositionSell
         * @memberof Trd_Common.MaxTrdQtys
         * @instance
         */
        MaxTrdQtys.prototype.maxPositionSell = 0;

        /**
         * MaxTrdQtys maxSellShort.
         * @member {number} maxSellShort
         * @memberof Trd_Common.MaxTrdQtys
         * @instance
         */
        MaxTrdQtys.prototype.maxSellShort = 0;

        /**
         * MaxTrdQtys maxBuyBack.
         * @member {number} maxBuyBack
         * @memberof Trd_Common.MaxTrdQtys
         * @instance
         */
        MaxTrdQtys.prototype.maxBuyBack = 0;

        /**
         * Creates a new MaxTrdQtys instance using the specified properties.
         * @function create
         * @memberof Trd_Common.MaxTrdQtys
         * @static
         * @param {Trd_Common.IMaxTrdQtys=} [properties] Properties to set
         * @returns {Trd_Common.MaxTrdQtys} MaxTrdQtys instance
         */
        MaxTrdQtys.create = function create(properties) {
            return new MaxTrdQtys(properties);
        };

        /**
         * Encodes the specified MaxTrdQtys message. Does not implicitly {@link Trd_Common.MaxTrdQtys.verify|verify} messages.
         * @function encode
         * @memberof Trd_Common.MaxTrdQtys
         * @static
         * @param {Trd_Common.IMaxTrdQtys} message MaxTrdQtys message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MaxTrdQtys.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 1 =*/9).double(message.maxCashBuy);
            if (message.maxCashAndMarginBuy != null && message.hasOwnProperty("maxCashAndMarginBuy"))
                writer.uint32(/* id 2, wireType 1 =*/17).double(message.maxCashAndMarginBuy);
            writer.uint32(/* id 3, wireType 1 =*/25).double(message.maxPositionSell);
            if (message.maxSellShort != null && message.hasOwnProperty("maxSellShort"))
                writer.uint32(/* id 4, wireType 1 =*/33).double(message.maxSellShort);
            if (message.maxBuyBack != null && message.hasOwnProperty("maxBuyBack"))
                writer.uint32(/* id 5, wireType 1 =*/41).double(message.maxBuyBack);
            return writer;
        };

        /**
         * Encodes the specified MaxTrdQtys message, length delimited. Does not implicitly {@link Trd_Common.MaxTrdQtys.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_Common.MaxTrdQtys
         * @static
         * @param {Trd_Common.IMaxTrdQtys} message MaxTrdQtys message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MaxTrdQtys.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MaxTrdQtys message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_Common.MaxTrdQtys
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_Common.MaxTrdQtys} MaxTrdQtys
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MaxTrdQtys.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_Common.MaxTrdQtys();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.maxCashBuy = reader.double();
                    break;
                case 2:
                    message.maxCashAndMarginBuy = reader.double();
                    break;
                case 3:
                    message.maxPositionSell = reader.double();
                    break;
                case 4:
                    message.maxSellShort = reader.double();
                    break;
                case 5:
                    message.maxBuyBack = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("maxCashBuy"))
                throw $util.ProtocolError("missing required 'maxCashBuy'", { instance: message });
            if (!message.hasOwnProperty("maxPositionSell"))
                throw $util.ProtocolError("missing required 'maxPositionSell'", { instance: message });
            return message;
        };

        /**
         * Decodes a MaxTrdQtys message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_Common.MaxTrdQtys
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_Common.MaxTrdQtys} MaxTrdQtys
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MaxTrdQtys.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MaxTrdQtys message.
         * @function verify
         * @memberof Trd_Common.MaxTrdQtys
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MaxTrdQtys.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (typeof message.maxCashBuy !== "number")
                return "maxCashBuy: number expected";
            if (message.maxCashAndMarginBuy != null && message.hasOwnProperty("maxCashAndMarginBuy"))
                if (typeof message.maxCashAndMarginBuy !== "number")
                    return "maxCashAndMarginBuy: number expected";
            if (typeof message.maxPositionSell !== "number")
                return "maxPositionSell: number expected";
            if (message.maxSellShort != null && message.hasOwnProperty("maxSellShort"))
                if (typeof message.maxSellShort !== "number")
                    return "maxSellShort: number expected";
            if (message.maxBuyBack != null && message.hasOwnProperty("maxBuyBack"))
                if (typeof message.maxBuyBack !== "number")
                    return "maxBuyBack: number expected";
            return null;
        };

        /**
         * Creates a MaxTrdQtys message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_Common.MaxTrdQtys
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_Common.MaxTrdQtys} MaxTrdQtys
         */
        MaxTrdQtys.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_Common.MaxTrdQtys)
                return object;
            var message = new $root.Trd_Common.MaxTrdQtys();
            if (object.maxCashBuy != null)
                message.maxCashBuy = Number(object.maxCashBuy);
            if (object.maxCashAndMarginBuy != null)
                message.maxCashAndMarginBuy = Number(object.maxCashAndMarginBuy);
            if (object.maxPositionSell != null)
                message.maxPositionSell = Number(object.maxPositionSell);
            if (object.maxSellShort != null)
                message.maxSellShort = Number(object.maxSellShort);
            if (object.maxBuyBack != null)
                message.maxBuyBack = Number(object.maxBuyBack);
            return message;
        };

        /**
         * Creates a plain object from a MaxTrdQtys message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_Common.MaxTrdQtys
         * @static
         * @param {Trd_Common.MaxTrdQtys} message MaxTrdQtys
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MaxTrdQtys.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.maxCashBuy = 0;
                object.maxCashAndMarginBuy = 0;
                object.maxPositionSell = 0;
                object.maxSellShort = 0;
                object.maxBuyBack = 0;
            }
            if (message.maxCashBuy != null && message.hasOwnProperty("maxCashBuy"))
                object.maxCashBuy = options.json && !isFinite(message.maxCashBuy) ? String(message.maxCashBuy) : message.maxCashBuy;
            if (message.maxCashAndMarginBuy != null && message.hasOwnProperty("maxCashAndMarginBuy"))
                object.maxCashAndMarginBuy = options.json && !isFinite(message.maxCashAndMarginBuy) ? String(message.maxCashAndMarginBuy) : message.maxCashAndMarginBuy;
            if (message.maxPositionSell != null && message.hasOwnProperty("maxPositionSell"))
                object.maxPositionSell = options.json && !isFinite(message.maxPositionSell) ? String(message.maxPositionSell) : message.maxPositionSell;
            if (message.maxSellShort != null && message.hasOwnProperty("maxSellShort"))
                object.maxSellShort = options.json && !isFinite(message.maxSellShort) ? String(message.maxSellShort) : message.maxSellShort;
            if (message.maxBuyBack != null && message.hasOwnProperty("maxBuyBack"))
                object.maxBuyBack = options.json && !isFinite(message.maxBuyBack) ? String(message.maxBuyBack) : message.maxBuyBack;
            return object;
        };

        /**
         * Converts this MaxTrdQtys to JSON.
         * @function toJSON
         * @memberof Trd_Common.MaxTrdQtys
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MaxTrdQtys.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MaxTrdQtys;
    })();

    Trd_Common.TrdFilterConditions = (function() {

        /**
         * Properties of a TrdFilterConditions.
         * @memberof Trd_Common
         * @interface ITrdFilterConditions
         * @property {Array.<string>|null} [codeList] TrdFilterConditions codeList
         * @property {Array.<number|Long>|null} [idList] TrdFilterConditions idList
         * @property {string|null} [beginTime] TrdFilterConditions beginTime
         * @property {string|null} [endTime] TrdFilterConditions endTime
         */

        /**
         * Constructs a new TrdFilterConditions.
         * @memberof Trd_Common
         * @classdesc Represents a TrdFilterConditions.
         * @implements ITrdFilterConditions
         * @constructor
         * @param {Trd_Common.ITrdFilterConditions=} [properties] Properties to set
         */
        function TrdFilterConditions(properties) {
            this.codeList = [];
            this.idList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TrdFilterConditions codeList.
         * @member {Array.<string>} codeList
         * @memberof Trd_Common.TrdFilterConditions
         * @instance
         */
        TrdFilterConditions.prototype.codeList = $util.emptyArray;

        /**
         * TrdFilterConditions idList.
         * @member {Array.<number|Long>} idList
         * @memberof Trd_Common.TrdFilterConditions
         * @instance
         */
        TrdFilterConditions.prototype.idList = $util.emptyArray;

        /**
         * TrdFilterConditions beginTime.
         * @member {string} beginTime
         * @memberof Trd_Common.TrdFilterConditions
         * @instance
         */
        TrdFilterConditions.prototype.beginTime = "";

        /**
         * TrdFilterConditions endTime.
         * @member {string} endTime
         * @memberof Trd_Common.TrdFilterConditions
         * @instance
         */
        TrdFilterConditions.prototype.endTime = "";

        /**
         * Creates a new TrdFilterConditions instance using the specified properties.
         * @function create
         * @memberof Trd_Common.TrdFilterConditions
         * @static
         * @param {Trd_Common.ITrdFilterConditions=} [properties] Properties to set
         * @returns {Trd_Common.TrdFilterConditions} TrdFilterConditions instance
         */
        TrdFilterConditions.create = function create(properties) {
            return new TrdFilterConditions(properties);
        };

        /**
         * Encodes the specified TrdFilterConditions message. Does not implicitly {@link Trd_Common.TrdFilterConditions.verify|verify} messages.
         * @function encode
         * @memberof Trd_Common.TrdFilterConditions
         * @static
         * @param {Trd_Common.ITrdFilterConditions} message TrdFilterConditions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TrdFilterConditions.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.codeList != null && message.codeList.length)
                for (var i = 0; i < message.codeList.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.codeList[i]);
            if (message.idList != null && message.idList.length)
                for (var i = 0; i < message.idList.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.idList[i]);
            if (message.beginTime != null && message.hasOwnProperty("beginTime"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.beginTime);
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.endTime);
            return writer;
        };

        /**
         * Encodes the specified TrdFilterConditions message, length delimited. Does not implicitly {@link Trd_Common.TrdFilterConditions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_Common.TrdFilterConditions
         * @static
         * @param {Trd_Common.ITrdFilterConditions} message TrdFilterConditions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TrdFilterConditions.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TrdFilterConditions message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_Common.TrdFilterConditions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_Common.TrdFilterConditions} TrdFilterConditions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TrdFilterConditions.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_Common.TrdFilterConditions();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.codeList && message.codeList.length))
                        message.codeList = [];
                    message.codeList.push(reader.string());
                    break;
                case 2:
                    if (!(message.idList && message.idList.length))
                        message.idList = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.idList.push(reader.uint64());
                    } else
                        message.idList.push(reader.uint64());
                    break;
                case 3:
                    message.beginTime = reader.string();
                    break;
                case 4:
                    message.endTime = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TrdFilterConditions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_Common.TrdFilterConditions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_Common.TrdFilterConditions} TrdFilterConditions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TrdFilterConditions.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TrdFilterConditions message.
         * @function verify
         * @memberof Trd_Common.TrdFilterConditions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TrdFilterConditions.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.codeList != null && message.hasOwnProperty("codeList")) {
                if (!Array.isArray(message.codeList))
                    return "codeList: array expected";
                for (var i = 0; i < message.codeList.length; ++i)
                    if (!$util.isString(message.codeList[i]))
                        return "codeList: string[] expected";
            }
            if (message.idList != null && message.hasOwnProperty("idList")) {
                if (!Array.isArray(message.idList))
                    return "idList: array expected";
                for (var i = 0; i < message.idList.length; ++i)
                    if (!$util.isInteger(message.idList[i]) && !(message.idList[i] && $util.isInteger(message.idList[i].low) && $util.isInteger(message.idList[i].high)))
                        return "idList: integer|Long[] expected";
            }
            if (message.beginTime != null && message.hasOwnProperty("beginTime"))
                if (!$util.isString(message.beginTime))
                    return "beginTime: string expected";
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                if (!$util.isString(message.endTime))
                    return "endTime: string expected";
            return null;
        };

        /**
         * Creates a TrdFilterConditions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_Common.TrdFilterConditions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_Common.TrdFilterConditions} TrdFilterConditions
         */
        TrdFilterConditions.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_Common.TrdFilterConditions)
                return object;
            var message = new $root.Trd_Common.TrdFilterConditions();
            if (object.codeList) {
                if (!Array.isArray(object.codeList))
                    throw TypeError(".Trd_Common.TrdFilterConditions.codeList: array expected");
                message.codeList = [];
                for (var i = 0; i < object.codeList.length; ++i)
                    message.codeList[i] = String(object.codeList[i]);
            }
            if (object.idList) {
                if (!Array.isArray(object.idList))
                    throw TypeError(".Trd_Common.TrdFilterConditions.idList: array expected");
                message.idList = [];
                for (var i = 0; i < object.idList.length; ++i)
                    if ($util.Long)
                        (message.idList[i] = $util.Long.fromValue(object.idList[i])).unsigned = true;
                    else if (typeof object.idList[i] === "string")
                        message.idList[i] = parseInt(object.idList[i], 10);
                    else if (typeof object.idList[i] === "number")
                        message.idList[i] = object.idList[i];
                    else if (typeof object.idList[i] === "object")
                        message.idList[i] = new $util.LongBits(object.idList[i].low >>> 0, object.idList[i].high >>> 0).toNumber(true);
            }
            if (object.beginTime != null)
                message.beginTime = String(object.beginTime);
            if (object.endTime != null)
                message.endTime = String(object.endTime);
            return message;
        };

        /**
         * Creates a plain object from a TrdFilterConditions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_Common.TrdFilterConditions
         * @static
         * @param {Trd_Common.TrdFilterConditions} message TrdFilterConditions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TrdFilterConditions.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.codeList = [];
                object.idList = [];
            }
            if (options.defaults) {
                object.beginTime = "";
                object.endTime = "";
            }
            if (message.codeList && message.codeList.length) {
                object.codeList = [];
                for (var j = 0; j < message.codeList.length; ++j)
                    object.codeList[j] = message.codeList[j];
            }
            if (message.idList && message.idList.length) {
                object.idList = [];
                for (var j = 0; j < message.idList.length; ++j)
                    if (typeof message.idList[j] === "number")
                        object.idList[j] = options.longs === String ? String(message.idList[j]) : message.idList[j];
                    else
                        object.idList[j] = options.longs === String ? $util.Long.prototype.toString.call(message.idList[j]) : options.longs === Number ? new $util.LongBits(message.idList[j].low >>> 0, message.idList[j].high >>> 0).toNumber(true) : message.idList[j];
            }
            if (message.beginTime != null && message.hasOwnProperty("beginTime"))
                object.beginTime = message.beginTime;
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                object.endTime = message.endTime;
            return object;
        };

        /**
         * Converts this TrdFilterConditions to JSON.
         * @function toJSON
         * @memberof Trd_Common.TrdFilterConditions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TrdFilterConditions.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TrdFilterConditions;
    })();

    return Trd_Common;
})();

$root.Trd_GetAccList = (function() {

    /**
     * Namespace Trd_GetAccList.
     * @exports Trd_GetAccList
     * @namespace
     */
    var Trd_GetAccList = {};

    Trd_GetAccList.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Trd_GetAccList
         * @interface IC2S
         * @property {number|Long} userID C2S userID
         */

        /**
         * Constructs a new C2S.
         * @memberof Trd_GetAccList
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Trd_GetAccList.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S userID.
         * @member {number|Long} userID
         * @memberof Trd_GetAccList.C2S
         * @instance
         */
        C2S.prototype.userID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Trd_GetAccList.C2S
         * @static
         * @param {Trd_GetAccList.IC2S=} [properties] Properties to set
         * @returns {Trd_GetAccList.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Trd_GetAccList.C2S.verify|verify} messages.
         * @function encode
         * @memberof Trd_GetAccList.C2S
         * @static
         * @param {Trd_GetAccList.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.userID);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Trd_GetAccList.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_GetAccList.C2S
         * @static
         * @param {Trd_GetAccList.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_GetAccList.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_GetAccList.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_GetAccList.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.userID = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("userID"))
                throw $util.ProtocolError("missing required 'userID'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_GetAccList.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_GetAccList.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Trd_GetAccList.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.userID) && !(message.userID && $util.isInteger(message.userID.low) && $util.isInteger(message.userID.high)))
                return "userID: integer|Long expected";
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_GetAccList.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_GetAccList.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_GetAccList.C2S)
                return object;
            var message = new $root.Trd_GetAccList.C2S();
            if (object.userID != null)
                if ($util.Long)
                    (message.userID = $util.Long.fromValue(object.userID)).unsigned = true;
                else if (typeof object.userID === "string")
                    message.userID = parseInt(object.userID, 10);
                else if (typeof object.userID === "number")
                    message.userID = object.userID;
                else if (typeof object.userID === "object")
                    message.userID = new $util.LongBits(object.userID.low >>> 0, object.userID.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_GetAccList.C2S
         * @static
         * @param {Trd_GetAccList.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.userID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.userID = options.longs === String ? "0" : 0;
            if (message.userID != null && message.hasOwnProperty("userID"))
                if (typeof message.userID === "number")
                    object.userID = options.longs === String ? String(message.userID) : message.userID;
                else
                    object.userID = options.longs === String ? $util.Long.prototype.toString.call(message.userID) : options.longs === Number ? new $util.LongBits(message.userID.low >>> 0, message.userID.high >>> 0).toNumber(true) : message.userID;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Trd_GetAccList.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Trd_GetAccList.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Trd_GetAccList
         * @interface IS2C
         * @property {Array.<Trd_Common.ITrdAcc>|null} [accList] S2C accList
         */

        /**
         * Constructs a new S2C.
         * @memberof Trd_GetAccList
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Trd_GetAccList.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.accList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C accList.
         * @member {Array.<Trd_Common.ITrdAcc>} accList
         * @memberof Trd_GetAccList.S2C
         * @instance
         */
        S2C.prototype.accList = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Trd_GetAccList.S2C
         * @static
         * @param {Trd_GetAccList.IS2C=} [properties] Properties to set
         * @returns {Trd_GetAccList.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Trd_GetAccList.S2C.verify|verify} messages.
         * @function encode
         * @memberof Trd_GetAccList.S2C
         * @static
         * @param {Trd_GetAccList.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.accList != null && message.accList.length)
                for (var i = 0; i < message.accList.length; ++i)
                    $root.Trd_Common.TrdAcc.encode(message.accList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Trd_GetAccList.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_GetAccList.S2C
         * @static
         * @param {Trd_GetAccList.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_GetAccList.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_GetAccList.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_GetAccList.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.accList && message.accList.length))
                        message.accList = [];
                    message.accList.push($root.Trd_Common.TrdAcc.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_GetAccList.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_GetAccList.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Trd_GetAccList.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.accList != null && message.hasOwnProperty("accList")) {
                if (!Array.isArray(message.accList))
                    return "accList: array expected";
                for (var i = 0; i < message.accList.length; ++i) {
                    var error = $root.Trd_Common.TrdAcc.verify(message.accList[i]);
                    if (error)
                        return "accList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_GetAccList.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_GetAccList.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_GetAccList.S2C)
                return object;
            var message = new $root.Trd_GetAccList.S2C();
            if (object.accList) {
                if (!Array.isArray(object.accList))
                    throw TypeError(".Trd_GetAccList.S2C.accList: array expected");
                message.accList = [];
                for (var i = 0; i < object.accList.length; ++i) {
                    if (typeof object.accList[i] !== "object")
                        throw TypeError(".Trd_GetAccList.S2C.accList: object expected");
                    message.accList[i] = $root.Trd_Common.TrdAcc.fromObject(object.accList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_GetAccList.S2C
         * @static
         * @param {Trd_GetAccList.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.accList = [];
            if (message.accList && message.accList.length) {
                object.accList = [];
                for (var j = 0; j < message.accList.length; ++j)
                    object.accList[j] = $root.Trd_Common.TrdAcc.toObject(message.accList[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Trd_GetAccList.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Trd_GetAccList.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Trd_GetAccList
         * @interface IRequest
         * @property {Trd_GetAccList.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Trd_GetAccList
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Trd_GetAccList.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Trd_GetAccList.IC2S} c2s
         * @memberof Trd_GetAccList.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Trd_GetAccList.Request
         * @static
         * @param {Trd_GetAccList.IRequest=} [properties] Properties to set
         * @returns {Trd_GetAccList.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Trd_GetAccList.Request.verify|verify} messages.
         * @function encode
         * @memberof Trd_GetAccList.Request
         * @static
         * @param {Trd_GetAccList.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Trd_GetAccList.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Trd_GetAccList.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_GetAccList.Request
         * @static
         * @param {Trd_GetAccList.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_GetAccList.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_GetAccList.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_GetAccList.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Trd_GetAccList.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_GetAccList.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_GetAccList.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Trd_GetAccList.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Trd_GetAccList.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_GetAccList.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_GetAccList.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_GetAccList.Request)
                return object;
            var message = new $root.Trd_GetAccList.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Trd_GetAccList.Request.c2s: object expected");
                message.c2s = $root.Trd_GetAccList.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_GetAccList.Request
         * @static
         * @param {Trd_GetAccList.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Trd_GetAccList.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Trd_GetAccList.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Trd_GetAccList.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Trd_GetAccList
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Trd_GetAccList.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Trd_GetAccList
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Trd_GetAccList.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Trd_GetAccList.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Trd_GetAccList.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Trd_GetAccList.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Trd_GetAccList.IS2C|null|undefined} s2c
         * @memberof Trd_GetAccList.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Trd_GetAccList.Response
         * @static
         * @param {Trd_GetAccList.IResponse=} [properties] Properties to set
         * @returns {Trd_GetAccList.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Trd_GetAccList.Response.verify|verify} messages.
         * @function encode
         * @memberof Trd_GetAccList.Response
         * @static
         * @param {Trd_GetAccList.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Trd_GetAccList.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Trd_GetAccList.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_GetAccList.Response
         * @static
         * @param {Trd_GetAccList.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_GetAccList.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_GetAccList.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_GetAccList.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Trd_GetAccList.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_GetAccList.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_GetAccList.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Trd_GetAccList.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Trd_GetAccList.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_GetAccList.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_GetAccList.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_GetAccList.Response)
                return object;
            var message = new $root.Trd_GetAccList.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Trd_GetAccList.Response.s2c: object expected");
                message.s2c = $root.Trd_GetAccList.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_GetAccList.Response
         * @static
         * @param {Trd_GetAccList.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Trd_GetAccList.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Trd_GetAccList.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Trd_GetAccList;
})();

$root.Trd_GetFunds = (function() {

    /**
     * Namespace Trd_GetFunds.
     * @exports Trd_GetFunds
     * @namespace
     */
    var Trd_GetFunds = {};

    Trd_GetFunds.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Trd_GetFunds
         * @interface IC2S
         * @property {Trd_Common.ITrdHeader} header C2S header
         */

        /**
         * Constructs a new C2S.
         * @memberof Trd_GetFunds
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Trd_GetFunds.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S header.
         * @member {Trd_Common.ITrdHeader} header
         * @memberof Trd_GetFunds.C2S
         * @instance
         */
        C2S.prototype.header = null;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Trd_GetFunds.C2S
         * @static
         * @param {Trd_GetFunds.IC2S=} [properties] Properties to set
         * @returns {Trd_GetFunds.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Trd_GetFunds.C2S.verify|verify} messages.
         * @function encode
         * @memberof Trd_GetFunds.C2S
         * @static
         * @param {Trd_GetFunds.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Trd_Common.TrdHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Trd_GetFunds.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_GetFunds.C2S
         * @static
         * @param {Trd_GetFunds.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_GetFunds.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_GetFunds.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_GetFunds.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.header = $root.Trd_Common.TrdHeader.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("header"))
                throw $util.ProtocolError("missing required 'header'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_GetFunds.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_GetFunds.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Trd_GetFunds.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Trd_Common.TrdHeader.verify(message.header);
                if (error)
                    return "header." + error;
            }
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_GetFunds.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_GetFunds.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_GetFunds.C2S)
                return object;
            var message = new $root.Trd_GetFunds.C2S();
            if (object.header != null) {
                if (typeof object.header !== "object")
                    throw TypeError(".Trd_GetFunds.C2S.header: object expected");
                message.header = $root.Trd_Common.TrdHeader.fromObject(object.header);
            }
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_GetFunds.C2S
         * @static
         * @param {Trd_GetFunds.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.header = null;
            if (message.header != null && message.hasOwnProperty("header"))
                object.header = $root.Trd_Common.TrdHeader.toObject(message.header, options);
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Trd_GetFunds.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Trd_GetFunds.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Trd_GetFunds
         * @interface IS2C
         * @property {Trd_Common.ITrdHeader} header S2C header
         * @property {Trd_Common.IFunds|null} [funds] S2C funds
         */

        /**
         * Constructs a new S2C.
         * @memberof Trd_GetFunds
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Trd_GetFunds.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C header.
         * @member {Trd_Common.ITrdHeader} header
         * @memberof Trd_GetFunds.S2C
         * @instance
         */
        S2C.prototype.header = null;

        /**
         * S2C funds.
         * @member {Trd_Common.IFunds|null|undefined} funds
         * @memberof Trd_GetFunds.S2C
         * @instance
         */
        S2C.prototype.funds = null;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Trd_GetFunds.S2C
         * @static
         * @param {Trd_GetFunds.IS2C=} [properties] Properties to set
         * @returns {Trd_GetFunds.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Trd_GetFunds.S2C.verify|verify} messages.
         * @function encode
         * @memberof Trd_GetFunds.S2C
         * @static
         * @param {Trd_GetFunds.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Trd_Common.TrdHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.funds != null && message.hasOwnProperty("funds"))
                $root.Trd_Common.Funds.encode(message.funds, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Trd_GetFunds.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_GetFunds.S2C
         * @static
         * @param {Trd_GetFunds.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_GetFunds.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_GetFunds.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_GetFunds.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.header = $root.Trd_Common.TrdHeader.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.funds = $root.Trd_Common.Funds.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("header"))
                throw $util.ProtocolError("missing required 'header'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_GetFunds.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_GetFunds.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Trd_GetFunds.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Trd_Common.TrdHeader.verify(message.header);
                if (error)
                    return "header." + error;
            }
            if (message.funds != null && message.hasOwnProperty("funds")) {
                var error = $root.Trd_Common.Funds.verify(message.funds);
                if (error)
                    return "funds." + error;
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_GetFunds.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_GetFunds.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_GetFunds.S2C)
                return object;
            var message = new $root.Trd_GetFunds.S2C();
            if (object.header != null) {
                if (typeof object.header !== "object")
                    throw TypeError(".Trd_GetFunds.S2C.header: object expected");
                message.header = $root.Trd_Common.TrdHeader.fromObject(object.header);
            }
            if (object.funds != null) {
                if (typeof object.funds !== "object")
                    throw TypeError(".Trd_GetFunds.S2C.funds: object expected");
                message.funds = $root.Trd_Common.Funds.fromObject(object.funds);
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_GetFunds.S2C
         * @static
         * @param {Trd_GetFunds.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.header = null;
                object.funds = null;
            }
            if (message.header != null && message.hasOwnProperty("header"))
                object.header = $root.Trd_Common.TrdHeader.toObject(message.header, options);
            if (message.funds != null && message.hasOwnProperty("funds"))
                object.funds = $root.Trd_Common.Funds.toObject(message.funds, options);
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Trd_GetFunds.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Trd_GetFunds.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Trd_GetFunds
         * @interface IRequest
         * @property {Trd_GetFunds.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Trd_GetFunds
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Trd_GetFunds.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Trd_GetFunds.IC2S} c2s
         * @memberof Trd_GetFunds.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Trd_GetFunds.Request
         * @static
         * @param {Trd_GetFunds.IRequest=} [properties] Properties to set
         * @returns {Trd_GetFunds.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Trd_GetFunds.Request.verify|verify} messages.
         * @function encode
         * @memberof Trd_GetFunds.Request
         * @static
         * @param {Trd_GetFunds.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Trd_GetFunds.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Trd_GetFunds.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_GetFunds.Request
         * @static
         * @param {Trd_GetFunds.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_GetFunds.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_GetFunds.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_GetFunds.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Trd_GetFunds.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_GetFunds.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_GetFunds.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Trd_GetFunds.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Trd_GetFunds.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_GetFunds.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_GetFunds.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_GetFunds.Request)
                return object;
            var message = new $root.Trd_GetFunds.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Trd_GetFunds.Request.c2s: object expected");
                message.c2s = $root.Trd_GetFunds.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_GetFunds.Request
         * @static
         * @param {Trd_GetFunds.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Trd_GetFunds.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Trd_GetFunds.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Trd_GetFunds.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Trd_GetFunds
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Trd_GetFunds.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Trd_GetFunds
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Trd_GetFunds.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Trd_GetFunds.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Trd_GetFunds.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Trd_GetFunds.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Trd_GetFunds.IS2C|null|undefined} s2c
         * @memberof Trd_GetFunds.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Trd_GetFunds.Response
         * @static
         * @param {Trd_GetFunds.IResponse=} [properties] Properties to set
         * @returns {Trd_GetFunds.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Trd_GetFunds.Response.verify|verify} messages.
         * @function encode
         * @memberof Trd_GetFunds.Response
         * @static
         * @param {Trd_GetFunds.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Trd_GetFunds.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Trd_GetFunds.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_GetFunds.Response
         * @static
         * @param {Trd_GetFunds.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_GetFunds.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_GetFunds.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_GetFunds.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Trd_GetFunds.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_GetFunds.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_GetFunds.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Trd_GetFunds.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Trd_GetFunds.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_GetFunds.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_GetFunds.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_GetFunds.Response)
                return object;
            var message = new $root.Trd_GetFunds.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Trd_GetFunds.Response.s2c: object expected");
                message.s2c = $root.Trd_GetFunds.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_GetFunds.Response
         * @static
         * @param {Trd_GetFunds.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Trd_GetFunds.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Trd_GetFunds.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Trd_GetFunds;
})();

$root.Trd_GetHistoryOrderFillList = (function() {

    /**
     * Namespace Trd_GetHistoryOrderFillList.
     * @exports Trd_GetHistoryOrderFillList
     * @namespace
     */
    var Trd_GetHistoryOrderFillList = {};

    Trd_GetHistoryOrderFillList.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Trd_GetHistoryOrderFillList
         * @interface IC2S
         * @property {Trd_Common.ITrdHeader} header C2S header
         * @property {Trd_Common.ITrdFilterConditions} filterConditions C2S filterConditions
         */

        /**
         * Constructs a new C2S.
         * @memberof Trd_GetHistoryOrderFillList
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Trd_GetHistoryOrderFillList.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S header.
         * @member {Trd_Common.ITrdHeader} header
         * @memberof Trd_GetHistoryOrderFillList.C2S
         * @instance
         */
        C2S.prototype.header = null;

        /**
         * C2S filterConditions.
         * @member {Trd_Common.ITrdFilterConditions} filterConditions
         * @memberof Trd_GetHistoryOrderFillList.C2S
         * @instance
         */
        C2S.prototype.filterConditions = null;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Trd_GetHistoryOrderFillList.C2S
         * @static
         * @param {Trd_GetHistoryOrderFillList.IC2S=} [properties] Properties to set
         * @returns {Trd_GetHistoryOrderFillList.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Trd_GetHistoryOrderFillList.C2S.verify|verify} messages.
         * @function encode
         * @memberof Trd_GetHistoryOrderFillList.C2S
         * @static
         * @param {Trd_GetHistoryOrderFillList.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Trd_Common.TrdHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            $root.Trd_Common.TrdFilterConditions.encode(message.filterConditions, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Trd_GetHistoryOrderFillList.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_GetHistoryOrderFillList.C2S
         * @static
         * @param {Trd_GetHistoryOrderFillList.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_GetHistoryOrderFillList.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_GetHistoryOrderFillList.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_GetHistoryOrderFillList.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.header = $root.Trd_Common.TrdHeader.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.filterConditions = $root.Trd_Common.TrdFilterConditions.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("header"))
                throw $util.ProtocolError("missing required 'header'", { instance: message });
            if (!message.hasOwnProperty("filterConditions"))
                throw $util.ProtocolError("missing required 'filterConditions'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_GetHistoryOrderFillList.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_GetHistoryOrderFillList.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Trd_GetHistoryOrderFillList.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Trd_Common.TrdHeader.verify(message.header);
                if (error)
                    return "header." + error;
            }
            {
                var error = $root.Trd_Common.TrdFilterConditions.verify(message.filterConditions);
                if (error)
                    return "filterConditions." + error;
            }
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_GetHistoryOrderFillList.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_GetHistoryOrderFillList.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_GetHistoryOrderFillList.C2S)
                return object;
            var message = new $root.Trd_GetHistoryOrderFillList.C2S();
            if (object.header != null) {
                if (typeof object.header !== "object")
                    throw TypeError(".Trd_GetHistoryOrderFillList.C2S.header: object expected");
                message.header = $root.Trd_Common.TrdHeader.fromObject(object.header);
            }
            if (object.filterConditions != null) {
                if (typeof object.filterConditions !== "object")
                    throw TypeError(".Trd_GetHistoryOrderFillList.C2S.filterConditions: object expected");
                message.filterConditions = $root.Trd_Common.TrdFilterConditions.fromObject(object.filterConditions);
            }
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_GetHistoryOrderFillList.C2S
         * @static
         * @param {Trd_GetHistoryOrderFillList.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.header = null;
                object.filterConditions = null;
            }
            if (message.header != null && message.hasOwnProperty("header"))
                object.header = $root.Trd_Common.TrdHeader.toObject(message.header, options);
            if (message.filterConditions != null && message.hasOwnProperty("filterConditions"))
                object.filterConditions = $root.Trd_Common.TrdFilterConditions.toObject(message.filterConditions, options);
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Trd_GetHistoryOrderFillList.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Trd_GetHistoryOrderFillList.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Trd_GetHistoryOrderFillList
         * @interface IS2C
         * @property {Trd_Common.ITrdHeader} header S2C header
         * @property {Array.<Trd_Common.IOrderFill>|null} [orderFillList] S2C orderFillList
         */

        /**
         * Constructs a new S2C.
         * @memberof Trd_GetHistoryOrderFillList
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Trd_GetHistoryOrderFillList.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.orderFillList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C header.
         * @member {Trd_Common.ITrdHeader} header
         * @memberof Trd_GetHistoryOrderFillList.S2C
         * @instance
         */
        S2C.prototype.header = null;

        /**
         * S2C orderFillList.
         * @member {Array.<Trd_Common.IOrderFill>} orderFillList
         * @memberof Trd_GetHistoryOrderFillList.S2C
         * @instance
         */
        S2C.prototype.orderFillList = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Trd_GetHistoryOrderFillList.S2C
         * @static
         * @param {Trd_GetHistoryOrderFillList.IS2C=} [properties] Properties to set
         * @returns {Trd_GetHistoryOrderFillList.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Trd_GetHistoryOrderFillList.S2C.verify|verify} messages.
         * @function encode
         * @memberof Trd_GetHistoryOrderFillList.S2C
         * @static
         * @param {Trd_GetHistoryOrderFillList.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Trd_Common.TrdHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.orderFillList != null && message.orderFillList.length)
                for (var i = 0; i < message.orderFillList.length; ++i)
                    $root.Trd_Common.OrderFill.encode(message.orderFillList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Trd_GetHistoryOrderFillList.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_GetHistoryOrderFillList.S2C
         * @static
         * @param {Trd_GetHistoryOrderFillList.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_GetHistoryOrderFillList.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_GetHistoryOrderFillList.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_GetHistoryOrderFillList.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.header = $root.Trd_Common.TrdHeader.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.orderFillList && message.orderFillList.length))
                        message.orderFillList = [];
                    message.orderFillList.push($root.Trd_Common.OrderFill.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("header"))
                throw $util.ProtocolError("missing required 'header'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_GetHistoryOrderFillList.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_GetHistoryOrderFillList.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Trd_GetHistoryOrderFillList.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Trd_Common.TrdHeader.verify(message.header);
                if (error)
                    return "header." + error;
            }
            if (message.orderFillList != null && message.hasOwnProperty("orderFillList")) {
                if (!Array.isArray(message.orderFillList))
                    return "orderFillList: array expected";
                for (var i = 0; i < message.orderFillList.length; ++i) {
                    var error = $root.Trd_Common.OrderFill.verify(message.orderFillList[i]);
                    if (error)
                        return "orderFillList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_GetHistoryOrderFillList.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_GetHistoryOrderFillList.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_GetHistoryOrderFillList.S2C)
                return object;
            var message = new $root.Trd_GetHistoryOrderFillList.S2C();
            if (object.header != null) {
                if (typeof object.header !== "object")
                    throw TypeError(".Trd_GetHistoryOrderFillList.S2C.header: object expected");
                message.header = $root.Trd_Common.TrdHeader.fromObject(object.header);
            }
            if (object.orderFillList) {
                if (!Array.isArray(object.orderFillList))
                    throw TypeError(".Trd_GetHistoryOrderFillList.S2C.orderFillList: array expected");
                message.orderFillList = [];
                for (var i = 0; i < object.orderFillList.length; ++i) {
                    if (typeof object.orderFillList[i] !== "object")
                        throw TypeError(".Trd_GetHistoryOrderFillList.S2C.orderFillList: object expected");
                    message.orderFillList[i] = $root.Trd_Common.OrderFill.fromObject(object.orderFillList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_GetHistoryOrderFillList.S2C
         * @static
         * @param {Trd_GetHistoryOrderFillList.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.orderFillList = [];
            if (options.defaults)
                object.header = null;
            if (message.header != null && message.hasOwnProperty("header"))
                object.header = $root.Trd_Common.TrdHeader.toObject(message.header, options);
            if (message.orderFillList && message.orderFillList.length) {
                object.orderFillList = [];
                for (var j = 0; j < message.orderFillList.length; ++j)
                    object.orderFillList[j] = $root.Trd_Common.OrderFill.toObject(message.orderFillList[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Trd_GetHistoryOrderFillList.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Trd_GetHistoryOrderFillList.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Trd_GetHistoryOrderFillList
         * @interface IRequest
         * @property {Trd_GetHistoryOrderFillList.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Trd_GetHistoryOrderFillList
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Trd_GetHistoryOrderFillList.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Trd_GetHistoryOrderFillList.IC2S} c2s
         * @memberof Trd_GetHistoryOrderFillList.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Trd_GetHistoryOrderFillList.Request
         * @static
         * @param {Trd_GetHistoryOrderFillList.IRequest=} [properties] Properties to set
         * @returns {Trd_GetHistoryOrderFillList.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Trd_GetHistoryOrderFillList.Request.verify|verify} messages.
         * @function encode
         * @memberof Trd_GetHistoryOrderFillList.Request
         * @static
         * @param {Trd_GetHistoryOrderFillList.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Trd_GetHistoryOrderFillList.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Trd_GetHistoryOrderFillList.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_GetHistoryOrderFillList.Request
         * @static
         * @param {Trd_GetHistoryOrderFillList.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_GetHistoryOrderFillList.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_GetHistoryOrderFillList.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_GetHistoryOrderFillList.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Trd_GetHistoryOrderFillList.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_GetHistoryOrderFillList.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_GetHistoryOrderFillList.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Trd_GetHistoryOrderFillList.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Trd_GetHistoryOrderFillList.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_GetHistoryOrderFillList.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_GetHistoryOrderFillList.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_GetHistoryOrderFillList.Request)
                return object;
            var message = new $root.Trd_GetHistoryOrderFillList.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Trd_GetHistoryOrderFillList.Request.c2s: object expected");
                message.c2s = $root.Trd_GetHistoryOrderFillList.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_GetHistoryOrderFillList.Request
         * @static
         * @param {Trd_GetHistoryOrderFillList.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Trd_GetHistoryOrderFillList.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Trd_GetHistoryOrderFillList.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Trd_GetHistoryOrderFillList.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Trd_GetHistoryOrderFillList
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Trd_GetHistoryOrderFillList.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Trd_GetHistoryOrderFillList
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Trd_GetHistoryOrderFillList.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Trd_GetHistoryOrderFillList.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Trd_GetHistoryOrderFillList.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Trd_GetHistoryOrderFillList.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Trd_GetHistoryOrderFillList.IS2C|null|undefined} s2c
         * @memberof Trd_GetHistoryOrderFillList.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Trd_GetHistoryOrderFillList.Response
         * @static
         * @param {Trd_GetHistoryOrderFillList.IResponse=} [properties] Properties to set
         * @returns {Trd_GetHistoryOrderFillList.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Trd_GetHistoryOrderFillList.Response.verify|verify} messages.
         * @function encode
         * @memberof Trd_GetHistoryOrderFillList.Response
         * @static
         * @param {Trd_GetHistoryOrderFillList.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Trd_GetHistoryOrderFillList.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Trd_GetHistoryOrderFillList.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_GetHistoryOrderFillList.Response
         * @static
         * @param {Trd_GetHistoryOrderFillList.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_GetHistoryOrderFillList.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_GetHistoryOrderFillList.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_GetHistoryOrderFillList.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Trd_GetHistoryOrderFillList.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_GetHistoryOrderFillList.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_GetHistoryOrderFillList.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Trd_GetHistoryOrderFillList.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Trd_GetHistoryOrderFillList.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_GetHistoryOrderFillList.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_GetHistoryOrderFillList.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_GetHistoryOrderFillList.Response)
                return object;
            var message = new $root.Trd_GetHistoryOrderFillList.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Trd_GetHistoryOrderFillList.Response.s2c: object expected");
                message.s2c = $root.Trd_GetHistoryOrderFillList.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_GetHistoryOrderFillList.Response
         * @static
         * @param {Trd_GetHistoryOrderFillList.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Trd_GetHistoryOrderFillList.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Trd_GetHistoryOrderFillList.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Trd_GetHistoryOrderFillList;
})();

$root.Trd_GetHistoryOrderList = (function() {

    /**
     * Namespace Trd_GetHistoryOrderList.
     * @exports Trd_GetHistoryOrderList
     * @namespace
     */
    var Trd_GetHistoryOrderList = {};

    Trd_GetHistoryOrderList.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Trd_GetHistoryOrderList
         * @interface IC2S
         * @property {Trd_Common.ITrdHeader} header C2S header
         * @property {Trd_Common.ITrdFilterConditions} filterConditions C2S filterConditions
         * @property {Array.<number>|null} [filterStatusList] C2S filterStatusList
         */

        /**
         * Constructs a new C2S.
         * @memberof Trd_GetHistoryOrderList
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Trd_GetHistoryOrderList.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            this.filterStatusList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S header.
         * @member {Trd_Common.ITrdHeader} header
         * @memberof Trd_GetHistoryOrderList.C2S
         * @instance
         */
        C2S.prototype.header = null;

        /**
         * C2S filterConditions.
         * @member {Trd_Common.ITrdFilterConditions} filterConditions
         * @memberof Trd_GetHistoryOrderList.C2S
         * @instance
         */
        C2S.prototype.filterConditions = null;

        /**
         * C2S filterStatusList.
         * @member {Array.<number>} filterStatusList
         * @memberof Trd_GetHistoryOrderList.C2S
         * @instance
         */
        C2S.prototype.filterStatusList = $util.emptyArray;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Trd_GetHistoryOrderList.C2S
         * @static
         * @param {Trd_GetHistoryOrderList.IC2S=} [properties] Properties to set
         * @returns {Trd_GetHistoryOrderList.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Trd_GetHistoryOrderList.C2S.verify|verify} messages.
         * @function encode
         * @memberof Trd_GetHistoryOrderList.C2S
         * @static
         * @param {Trd_GetHistoryOrderList.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Trd_Common.TrdHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            $root.Trd_Common.TrdFilterConditions.encode(message.filterConditions, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.filterStatusList != null && message.filterStatusList.length)
                for (var i = 0; i < message.filterStatusList.length; ++i)
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.filterStatusList[i]);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Trd_GetHistoryOrderList.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_GetHistoryOrderList.C2S
         * @static
         * @param {Trd_GetHistoryOrderList.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_GetHistoryOrderList.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_GetHistoryOrderList.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_GetHistoryOrderList.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.header = $root.Trd_Common.TrdHeader.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.filterConditions = $root.Trd_Common.TrdFilterConditions.decode(reader, reader.uint32());
                    break;
                case 3:
                    if (!(message.filterStatusList && message.filterStatusList.length))
                        message.filterStatusList = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.filterStatusList.push(reader.int32());
                    } else
                        message.filterStatusList.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("header"))
                throw $util.ProtocolError("missing required 'header'", { instance: message });
            if (!message.hasOwnProperty("filterConditions"))
                throw $util.ProtocolError("missing required 'filterConditions'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_GetHistoryOrderList.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_GetHistoryOrderList.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Trd_GetHistoryOrderList.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Trd_Common.TrdHeader.verify(message.header);
                if (error)
                    return "header." + error;
            }
            {
                var error = $root.Trd_Common.TrdFilterConditions.verify(message.filterConditions);
                if (error)
                    return "filterConditions." + error;
            }
            if (message.filterStatusList != null && message.hasOwnProperty("filterStatusList")) {
                if (!Array.isArray(message.filterStatusList))
                    return "filterStatusList: array expected";
                for (var i = 0; i < message.filterStatusList.length; ++i)
                    if (!$util.isInteger(message.filterStatusList[i]))
                        return "filterStatusList: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_GetHistoryOrderList.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_GetHistoryOrderList.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_GetHistoryOrderList.C2S)
                return object;
            var message = new $root.Trd_GetHistoryOrderList.C2S();
            if (object.header != null) {
                if (typeof object.header !== "object")
                    throw TypeError(".Trd_GetHistoryOrderList.C2S.header: object expected");
                message.header = $root.Trd_Common.TrdHeader.fromObject(object.header);
            }
            if (object.filterConditions != null) {
                if (typeof object.filterConditions !== "object")
                    throw TypeError(".Trd_GetHistoryOrderList.C2S.filterConditions: object expected");
                message.filterConditions = $root.Trd_Common.TrdFilterConditions.fromObject(object.filterConditions);
            }
            if (object.filterStatusList) {
                if (!Array.isArray(object.filterStatusList))
                    throw TypeError(".Trd_GetHistoryOrderList.C2S.filterStatusList: array expected");
                message.filterStatusList = [];
                for (var i = 0; i < object.filterStatusList.length; ++i)
                    message.filterStatusList[i] = object.filterStatusList[i] | 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_GetHistoryOrderList.C2S
         * @static
         * @param {Trd_GetHistoryOrderList.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.filterStatusList = [];
            if (options.defaults) {
                object.header = null;
                object.filterConditions = null;
            }
            if (message.header != null && message.hasOwnProperty("header"))
                object.header = $root.Trd_Common.TrdHeader.toObject(message.header, options);
            if (message.filterConditions != null && message.hasOwnProperty("filterConditions"))
                object.filterConditions = $root.Trd_Common.TrdFilterConditions.toObject(message.filterConditions, options);
            if (message.filterStatusList && message.filterStatusList.length) {
                object.filterStatusList = [];
                for (var j = 0; j < message.filterStatusList.length; ++j)
                    object.filterStatusList[j] = message.filterStatusList[j];
            }
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Trd_GetHistoryOrderList.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Trd_GetHistoryOrderList.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Trd_GetHistoryOrderList
         * @interface IS2C
         * @property {Trd_Common.ITrdHeader} header S2C header
         * @property {Array.<Trd_Common.IOrder>|null} [orderList] S2C orderList
         */

        /**
         * Constructs a new S2C.
         * @memberof Trd_GetHistoryOrderList
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Trd_GetHistoryOrderList.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.orderList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C header.
         * @member {Trd_Common.ITrdHeader} header
         * @memberof Trd_GetHistoryOrderList.S2C
         * @instance
         */
        S2C.prototype.header = null;

        /**
         * S2C orderList.
         * @member {Array.<Trd_Common.IOrder>} orderList
         * @memberof Trd_GetHistoryOrderList.S2C
         * @instance
         */
        S2C.prototype.orderList = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Trd_GetHistoryOrderList.S2C
         * @static
         * @param {Trd_GetHistoryOrderList.IS2C=} [properties] Properties to set
         * @returns {Trd_GetHistoryOrderList.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Trd_GetHistoryOrderList.S2C.verify|verify} messages.
         * @function encode
         * @memberof Trd_GetHistoryOrderList.S2C
         * @static
         * @param {Trd_GetHistoryOrderList.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Trd_Common.TrdHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.orderList != null && message.orderList.length)
                for (var i = 0; i < message.orderList.length; ++i)
                    $root.Trd_Common.Order.encode(message.orderList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Trd_GetHistoryOrderList.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_GetHistoryOrderList.S2C
         * @static
         * @param {Trd_GetHistoryOrderList.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_GetHistoryOrderList.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_GetHistoryOrderList.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_GetHistoryOrderList.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.header = $root.Trd_Common.TrdHeader.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.orderList && message.orderList.length))
                        message.orderList = [];
                    message.orderList.push($root.Trd_Common.Order.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("header"))
                throw $util.ProtocolError("missing required 'header'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_GetHistoryOrderList.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_GetHistoryOrderList.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Trd_GetHistoryOrderList.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Trd_Common.TrdHeader.verify(message.header);
                if (error)
                    return "header." + error;
            }
            if (message.orderList != null && message.hasOwnProperty("orderList")) {
                if (!Array.isArray(message.orderList))
                    return "orderList: array expected";
                for (var i = 0; i < message.orderList.length; ++i) {
                    var error = $root.Trd_Common.Order.verify(message.orderList[i]);
                    if (error)
                        return "orderList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_GetHistoryOrderList.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_GetHistoryOrderList.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_GetHistoryOrderList.S2C)
                return object;
            var message = new $root.Trd_GetHistoryOrderList.S2C();
            if (object.header != null) {
                if (typeof object.header !== "object")
                    throw TypeError(".Trd_GetHistoryOrderList.S2C.header: object expected");
                message.header = $root.Trd_Common.TrdHeader.fromObject(object.header);
            }
            if (object.orderList) {
                if (!Array.isArray(object.orderList))
                    throw TypeError(".Trd_GetHistoryOrderList.S2C.orderList: array expected");
                message.orderList = [];
                for (var i = 0; i < object.orderList.length; ++i) {
                    if (typeof object.orderList[i] !== "object")
                        throw TypeError(".Trd_GetHistoryOrderList.S2C.orderList: object expected");
                    message.orderList[i] = $root.Trd_Common.Order.fromObject(object.orderList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_GetHistoryOrderList.S2C
         * @static
         * @param {Trd_GetHistoryOrderList.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.orderList = [];
            if (options.defaults)
                object.header = null;
            if (message.header != null && message.hasOwnProperty("header"))
                object.header = $root.Trd_Common.TrdHeader.toObject(message.header, options);
            if (message.orderList && message.orderList.length) {
                object.orderList = [];
                for (var j = 0; j < message.orderList.length; ++j)
                    object.orderList[j] = $root.Trd_Common.Order.toObject(message.orderList[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Trd_GetHistoryOrderList.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Trd_GetHistoryOrderList.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Trd_GetHistoryOrderList
         * @interface IRequest
         * @property {Trd_GetHistoryOrderList.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Trd_GetHistoryOrderList
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Trd_GetHistoryOrderList.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Trd_GetHistoryOrderList.IC2S} c2s
         * @memberof Trd_GetHistoryOrderList.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Trd_GetHistoryOrderList.Request
         * @static
         * @param {Trd_GetHistoryOrderList.IRequest=} [properties] Properties to set
         * @returns {Trd_GetHistoryOrderList.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Trd_GetHistoryOrderList.Request.verify|verify} messages.
         * @function encode
         * @memberof Trd_GetHistoryOrderList.Request
         * @static
         * @param {Trd_GetHistoryOrderList.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Trd_GetHistoryOrderList.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Trd_GetHistoryOrderList.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_GetHistoryOrderList.Request
         * @static
         * @param {Trd_GetHistoryOrderList.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_GetHistoryOrderList.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_GetHistoryOrderList.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_GetHistoryOrderList.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Trd_GetHistoryOrderList.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_GetHistoryOrderList.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_GetHistoryOrderList.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Trd_GetHistoryOrderList.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Trd_GetHistoryOrderList.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_GetHistoryOrderList.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_GetHistoryOrderList.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_GetHistoryOrderList.Request)
                return object;
            var message = new $root.Trd_GetHistoryOrderList.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Trd_GetHistoryOrderList.Request.c2s: object expected");
                message.c2s = $root.Trd_GetHistoryOrderList.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_GetHistoryOrderList.Request
         * @static
         * @param {Trd_GetHistoryOrderList.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Trd_GetHistoryOrderList.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Trd_GetHistoryOrderList.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Trd_GetHistoryOrderList.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Trd_GetHistoryOrderList
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Trd_GetHistoryOrderList.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Trd_GetHistoryOrderList
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Trd_GetHistoryOrderList.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Trd_GetHistoryOrderList.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Trd_GetHistoryOrderList.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Trd_GetHistoryOrderList.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Trd_GetHistoryOrderList.IS2C|null|undefined} s2c
         * @memberof Trd_GetHistoryOrderList.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Trd_GetHistoryOrderList.Response
         * @static
         * @param {Trd_GetHistoryOrderList.IResponse=} [properties] Properties to set
         * @returns {Trd_GetHistoryOrderList.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Trd_GetHistoryOrderList.Response.verify|verify} messages.
         * @function encode
         * @memberof Trd_GetHistoryOrderList.Response
         * @static
         * @param {Trd_GetHistoryOrderList.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Trd_GetHistoryOrderList.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Trd_GetHistoryOrderList.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_GetHistoryOrderList.Response
         * @static
         * @param {Trd_GetHistoryOrderList.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_GetHistoryOrderList.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_GetHistoryOrderList.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_GetHistoryOrderList.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Trd_GetHistoryOrderList.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_GetHistoryOrderList.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_GetHistoryOrderList.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Trd_GetHistoryOrderList.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Trd_GetHistoryOrderList.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_GetHistoryOrderList.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_GetHistoryOrderList.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_GetHistoryOrderList.Response)
                return object;
            var message = new $root.Trd_GetHistoryOrderList.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Trd_GetHistoryOrderList.Response.s2c: object expected");
                message.s2c = $root.Trd_GetHistoryOrderList.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_GetHistoryOrderList.Response
         * @static
         * @param {Trd_GetHistoryOrderList.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Trd_GetHistoryOrderList.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Trd_GetHistoryOrderList.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Trd_GetHistoryOrderList;
})();

$root.Trd_GetMaxTrdQtys = (function() {

    /**
     * Namespace Trd_GetMaxTrdQtys.
     * @exports Trd_GetMaxTrdQtys
     * @namespace
     */
    var Trd_GetMaxTrdQtys = {};

    Trd_GetMaxTrdQtys.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Trd_GetMaxTrdQtys
         * @interface IC2S
         * @property {Trd_Common.ITrdHeader} header C2S header
         * @property {number} orderType C2S orderType
         * @property {string} code C2S code
         * @property {number} price C2S price
         * @property {number|Long|null} [orderID] C2S orderID
         * @property {boolean|null} [adjustPrice] C2S adjustPrice
         * @property {number|null} [adjustSideAndLimit] C2S adjustSideAndLimit
         * @property {number|null} [secMarket] C2S secMarket
         */

        /**
         * Constructs a new C2S.
         * @memberof Trd_GetMaxTrdQtys
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Trd_GetMaxTrdQtys.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S header.
         * @member {Trd_Common.ITrdHeader} header
         * @memberof Trd_GetMaxTrdQtys.C2S
         * @instance
         */
        C2S.prototype.header = null;

        /**
         * C2S orderType.
         * @member {number} orderType
         * @memberof Trd_GetMaxTrdQtys.C2S
         * @instance
         */
        C2S.prototype.orderType = 0;

        /**
         * C2S code.
         * @member {string} code
         * @memberof Trd_GetMaxTrdQtys.C2S
         * @instance
         */
        C2S.prototype.code = "";

        /**
         * C2S price.
         * @member {number} price
         * @memberof Trd_GetMaxTrdQtys.C2S
         * @instance
         */
        C2S.prototype.price = 0;

        /**
         * C2S orderID.
         * @member {number|Long} orderID
         * @memberof Trd_GetMaxTrdQtys.C2S
         * @instance
         */
        C2S.prototype.orderID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * C2S adjustPrice.
         * @member {boolean} adjustPrice
         * @memberof Trd_GetMaxTrdQtys.C2S
         * @instance
         */
        C2S.prototype.adjustPrice = false;

        /**
         * C2S adjustSideAndLimit.
         * @member {number} adjustSideAndLimit
         * @memberof Trd_GetMaxTrdQtys.C2S
         * @instance
         */
        C2S.prototype.adjustSideAndLimit = 0;

        /**
         * C2S secMarket.
         * @member {number} secMarket
         * @memberof Trd_GetMaxTrdQtys.C2S
         * @instance
         */
        C2S.prototype.secMarket = 0;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Trd_GetMaxTrdQtys.C2S
         * @static
         * @param {Trd_GetMaxTrdQtys.IC2S=} [properties] Properties to set
         * @returns {Trd_GetMaxTrdQtys.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Trd_GetMaxTrdQtys.C2S.verify|verify} messages.
         * @function encode
         * @memberof Trd_GetMaxTrdQtys.C2S
         * @static
         * @param {Trd_GetMaxTrdQtys.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Trd_Common.TrdHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.orderType);
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.code);
            writer.uint32(/* id 4, wireType 1 =*/33).double(message.price);
            if (message.orderID != null && message.hasOwnProperty("orderID"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.orderID);
            if (message.adjustPrice != null && message.hasOwnProperty("adjustPrice"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.adjustPrice);
            if (message.adjustSideAndLimit != null && message.hasOwnProperty("adjustSideAndLimit"))
                writer.uint32(/* id 7, wireType 1 =*/57).double(message.adjustSideAndLimit);
            if (message.secMarket != null && message.hasOwnProperty("secMarket"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.secMarket);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Trd_GetMaxTrdQtys.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_GetMaxTrdQtys.C2S
         * @static
         * @param {Trd_GetMaxTrdQtys.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_GetMaxTrdQtys.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_GetMaxTrdQtys.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_GetMaxTrdQtys.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.header = $root.Trd_Common.TrdHeader.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.orderType = reader.int32();
                    break;
                case 3:
                    message.code = reader.string();
                    break;
                case 4:
                    message.price = reader.double();
                    break;
                case 5:
                    message.orderID = reader.uint64();
                    break;
                case 6:
                    message.adjustPrice = reader.bool();
                    break;
                case 7:
                    message.adjustSideAndLimit = reader.double();
                    break;
                case 8:
                    message.secMarket = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("header"))
                throw $util.ProtocolError("missing required 'header'", { instance: message });
            if (!message.hasOwnProperty("orderType"))
                throw $util.ProtocolError("missing required 'orderType'", { instance: message });
            if (!message.hasOwnProperty("code"))
                throw $util.ProtocolError("missing required 'code'", { instance: message });
            if (!message.hasOwnProperty("price"))
                throw $util.ProtocolError("missing required 'price'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_GetMaxTrdQtys.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_GetMaxTrdQtys.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Trd_GetMaxTrdQtys.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Trd_Common.TrdHeader.verify(message.header);
                if (error)
                    return "header." + error;
            }
            if (!$util.isInteger(message.orderType))
                return "orderType: integer expected";
            if (!$util.isString(message.code))
                return "code: string expected";
            if (typeof message.price !== "number")
                return "price: number expected";
            if (message.orderID != null && message.hasOwnProperty("orderID"))
                if (!$util.isInteger(message.orderID) && !(message.orderID && $util.isInteger(message.orderID.low) && $util.isInteger(message.orderID.high)))
                    return "orderID: integer|Long expected";
            if (message.adjustPrice != null && message.hasOwnProperty("adjustPrice"))
                if (typeof message.adjustPrice !== "boolean")
                    return "adjustPrice: boolean expected";
            if (message.adjustSideAndLimit != null && message.hasOwnProperty("adjustSideAndLimit"))
                if (typeof message.adjustSideAndLimit !== "number")
                    return "adjustSideAndLimit: number expected";
            if (message.secMarket != null && message.hasOwnProperty("secMarket"))
                if (!$util.isInteger(message.secMarket))
                    return "secMarket: integer expected";
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_GetMaxTrdQtys.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_GetMaxTrdQtys.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_GetMaxTrdQtys.C2S)
                return object;
            var message = new $root.Trd_GetMaxTrdQtys.C2S();
            if (object.header != null) {
                if (typeof object.header !== "object")
                    throw TypeError(".Trd_GetMaxTrdQtys.C2S.header: object expected");
                message.header = $root.Trd_Common.TrdHeader.fromObject(object.header);
            }
            if (object.orderType != null)
                message.orderType = object.orderType | 0;
            if (object.code != null)
                message.code = String(object.code);
            if (object.price != null)
                message.price = Number(object.price);
            if (object.orderID != null)
                if ($util.Long)
                    (message.orderID = $util.Long.fromValue(object.orderID)).unsigned = true;
                else if (typeof object.orderID === "string")
                    message.orderID = parseInt(object.orderID, 10);
                else if (typeof object.orderID === "number")
                    message.orderID = object.orderID;
                else if (typeof object.orderID === "object")
                    message.orderID = new $util.LongBits(object.orderID.low >>> 0, object.orderID.high >>> 0).toNumber(true);
            if (object.adjustPrice != null)
                message.adjustPrice = Boolean(object.adjustPrice);
            if (object.adjustSideAndLimit != null)
                message.adjustSideAndLimit = Number(object.adjustSideAndLimit);
            if (object.secMarket != null)
                message.secMarket = object.secMarket | 0;
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_GetMaxTrdQtys.C2S
         * @static
         * @param {Trd_GetMaxTrdQtys.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.header = null;
                object.orderType = 0;
                object.code = "";
                object.price = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.orderID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.orderID = options.longs === String ? "0" : 0;
                object.adjustPrice = false;
                object.adjustSideAndLimit = 0;
                object.secMarket = 0;
            }
            if (message.header != null && message.hasOwnProperty("header"))
                object.header = $root.Trd_Common.TrdHeader.toObject(message.header, options);
            if (message.orderType != null && message.hasOwnProperty("orderType"))
                object.orderType = message.orderType;
            if (message.code != null && message.hasOwnProperty("code"))
                object.code = message.code;
            if (message.price != null && message.hasOwnProperty("price"))
                object.price = options.json && !isFinite(message.price) ? String(message.price) : message.price;
            if (message.orderID != null && message.hasOwnProperty("orderID"))
                if (typeof message.orderID === "number")
                    object.orderID = options.longs === String ? String(message.orderID) : message.orderID;
                else
                    object.orderID = options.longs === String ? $util.Long.prototype.toString.call(message.orderID) : options.longs === Number ? new $util.LongBits(message.orderID.low >>> 0, message.orderID.high >>> 0).toNumber(true) : message.orderID;
            if (message.adjustPrice != null && message.hasOwnProperty("adjustPrice"))
                object.adjustPrice = message.adjustPrice;
            if (message.adjustSideAndLimit != null && message.hasOwnProperty("adjustSideAndLimit"))
                object.adjustSideAndLimit = options.json && !isFinite(message.adjustSideAndLimit) ? String(message.adjustSideAndLimit) : message.adjustSideAndLimit;
            if (message.secMarket != null && message.hasOwnProperty("secMarket"))
                object.secMarket = message.secMarket;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Trd_GetMaxTrdQtys.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Trd_GetMaxTrdQtys.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Trd_GetMaxTrdQtys
         * @interface IS2C
         * @property {Trd_Common.ITrdHeader} header S2C header
         * @property {Trd_Common.IMaxTrdQtys|null} [maxTrdQtys] S2C maxTrdQtys
         */

        /**
         * Constructs a new S2C.
         * @memberof Trd_GetMaxTrdQtys
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Trd_GetMaxTrdQtys.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C header.
         * @member {Trd_Common.ITrdHeader} header
         * @memberof Trd_GetMaxTrdQtys.S2C
         * @instance
         */
        S2C.prototype.header = null;

        /**
         * S2C maxTrdQtys.
         * @member {Trd_Common.IMaxTrdQtys|null|undefined} maxTrdQtys
         * @memberof Trd_GetMaxTrdQtys.S2C
         * @instance
         */
        S2C.prototype.maxTrdQtys = null;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Trd_GetMaxTrdQtys.S2C
         * @static
         * @param {Trd_GetMaxTrdQtys.IS2C=} [properties] Properties to set
         * @returns {Trd_GetMaxTrdQtys.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Trd_GetMaxTrdQtys.S2C.verify|verify} messages.
         * @function encode
         * @memberof Trd_GetMaxTrdQtys.S2C
         * @static
         * @param {Trd_GetMaxTrdQtys.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Trd_Common.TrdHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.maxTrdQtys != null && message.hasOwnProperty("maxTrdQtys"))
                $root.Trd_Common.MaxTrdQtys.encode(message.maxTrdQtys, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Trd_GetMaxTrdQtys.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_GetMaxTrdQtys.S2C
         * @static
         * @param {Trd_GetMaxTrdQtys.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_GetMaxTrdQtys.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_GetMaxTrdQtys.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_GetMaxTrdQtys.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.header = $root.Trd_Common.TrdHeader.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.maxTrdQtys = $root.Trd_Common.MaxTrdQtys.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("header"))
                throw $util.ProtocolError("missing required 'header'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_GetMaxTrdQtys.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_GetMaxTrdQtys.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Trd_GetMaxTrdQtys.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Trd_Common.TrdHeader.verify(message.header);
                if (error)
                    return "header." + error;
            }
            if (message.maxTrdQtys != null && message.hasOwnProperty("maxTrdQtys")) {
                var error = $root.Trd_Common.MaxTrdQtys.verify(message.maxTrdQtys);
                if (error)
                    return "maxTrdQtys." + error;
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_GetMaxTrdQtys.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_GetMaxTrdQtys.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_GetMaxTrdQtys.S2C)
                return object;
            var message = new $root.Trd_GetMaxTrdQtys.S2C();
            if (object.header != null) {
                if (typeof object.header !== "object")
                    throw TypeError(".Trd_GetMaxTrdQtys.S2C.header: object expected");
                message.header = $root.Trd_Common.TrdHeader.fromObject(object.header);
            }
            if (object.maxTrdQtys != null) {
                if (typeof object.maxTrdQtys !== "object")
                    throw TypeError(".Trd_GetMaxTrdQtys.S2C.maxTrdQtys: object expected");
                message.maxTrdQtys = $root.Trd_Common.MaxTrdQtys.fromObject(object.maxTrdQtys);
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_GetMaxTrdQtys.S2C
         * @static
         * @param {Trd_GetMaxTrdQtys.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.header = null;
                object.maxTrdQtys = null;
            }
            if (message.header != null && message.hasOwnProperty("header"))
                object.header = $root.Trd_Common.TrdHeader.toObject(message.header, options);
            if (message.maxTrdQtys != null && message.hasOwnProperty("maxTrdQtys"))
                object.maxTrdQtys = $root.Trd_Common.MaxTrdQtys.toObject(message.maxTrdQtys, options);
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Trd_GetMaxTrdQtys.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Trd_GetMaxTrdQtys.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Trd_GetMaxTrdQtys
         * @interface IRequest
         * @property {Trd_GetMaxTrdQtys.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Trd_GetMaxTrdQtys
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Trd_GetMaxTrdQtys.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Trd_GetMaxTrdQtys.IC2S} c2s
         * @memberof Trd_GetMaxTrdQtys.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Trd_GetMaxTrdQtys.Request
         * @static
         * @param {Trd_GetMaxTrdQtys.IRequest=} [properties] Properties to set
         * @returns {Trd_GetMaxTrdQtys.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Trd_GetMaxTrdQtys.Request.verify|verify} messages.
         * @function encode
         * @memberof Trd_GetMaxTrdQtys.Request
         * @static
         * @param {Trd_GetMaxTrdQtys.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Trd_GetMaxTrdQtys.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Trd_GetMaxTrdQtys.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_GetMaxTrdQtys.Request
         * @static
         * @param {Trd_GetMaxTrdQtys.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_GetMaxTrdQtys.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_GetMaxTrdQtys.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_GetMaxTrdQtys.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Trd_GetMaxTrdQtys.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_GetMaxTrdQtys.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_GetMaxTrdQtys.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Trd_GetMaxTrdQtys.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Trd_GetMaxTrdQtys.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_GetMaxTrdQtys.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_GetMaxTrdQtys.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_GetMaxTrdQtys.Request)
                return object;
            var message = new $root.Trd_GetMaxTrdQtys.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Trd_GetMaxTrdQtys.Request.c2s: object expected");
                message.c2s = $root.Trd_GetMaxTrdQtys.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_GetMaxTrdQtys.Request
         * @static
         * @param {Trd_GetMaxTrdQtys.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Trd_GetMaxTrdQtys.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Trd_GetMaxTrdQtys.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Trd_GetMaxTrdQtys.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Trd_GetMaxTrdQtys
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Trd_GetMaxTrdQtys.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Trd_GetMaxTrdQtys
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Trd_GetMaxTrdQtys.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Trd_GetMaxTrdQtys.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Trd_GetMaxTrdQtys.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Trd_GetMaxTrdQtys.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Trd_GetMaxTrdQtys.IS2C|null|undefined} s2c
         * @memberof Trd_GetMaxTrdQtys.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Trd_GetMaxTrdQtys.Response
         * @static
         * @param {Trd_GetMaxTrdQtys.IResponse=} [properties] Properties to set
         * @returns {Trd_GetMaxTrdQtys.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Trd_GetMaxTrdQtys.Response.verify|verify} messages.
         * @function encode
         * @memberof Trd_GetMaxTrdQtys.Response
         * @static
         * @param {Trd_GetMaxTrdQtys.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Trd_GetMaxTrdQtys.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Trd_GetMaxTrdQtys.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_GetMaxTrdQtys.Response
         * @static
         * @param {Trd_GetMaxTrdQtys.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_GetMaxTrdQtys.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_GetMaxTrdQtys.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_GetMaxTrdQtys.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Trd_GetMaxTrdQtys.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_GetMaxTrdQtys.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_GetMaxTrdQtys.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Trd_GetMaxTrdQtys.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Trd_GetMaxTrdQtys.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_GetMaxTrdQtys.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_GetMaxTrdQtys.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_GetMaxTrdQtys.Response)
                return object;
            var message = new $root.Trd_GetMaxTrdQtys.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Trd_GetMaxTrdQtys.Response.s2c: object expected");
                message.s2c = $root.Trd_GetMaxTrdQtys.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_GetMaxTrdQtys.Response
         * @static
         * @param {Trd_GetMaxTrdQtys.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Trd_GetMaxTrdQtys.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Trd_GetMaxTrdQtys.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Trd_GetMaxTrdQtys;
})();

$root.Trd_GetOrderFillList = (function() {

    /**
     * Namespace Trd_GetOrderFillList.
     * @exports Trd_GetOrderFillList
     * @namespace
     */
    var Trd_GetOrderFillList = {};

    Trd_GetOrderFillList.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Trd_GetOrderFillList
         * @interface IC2S
         * @property {Trd_Common.ITrdHeader} header C2S header
         * @property {Trd_Common.ITrdFilterConditions|null} [filterConditions] C2S filterConditions
         */

        /**
         * Constructs a new C2S.
         * @memberof Trd_GetOrderFillList
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Trd_GetOrderFillList.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S header.
         * @member {Trd_Common.ITrdHeader} header
         * @memberof Trd_GetOrderFillList.C2S
         * @instance
         */
        C2S.prototype.header = null;

        /**
         * C2S filterConditions.
         * @member {Trd_Common.ITrdFilterConditions|null|undefined} filterConditions
         * @memberof Trd_GetOrderFillList.C2S
         * @instance
         */
        C2S.prototype.filterConditions = null;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Trd_GetOrderFillList.C2S
         * @static
         * @param {Trd_GetOrderFillList.IC2S=} [properties] Properties to set
         * @returns {Trd_GetOrderFillList.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Trd_GetOrderFillList.C2S.verify|verify} messages.
         * @function encode
         * @memberof Trd_GetOrderFillList.C2S
         * @static
         * @param {Trd_GetOrderFillList.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Trd_Common.TrdHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.filterConditions != null && message.hasOwnProperty("filterConditions"))
                $root.Trd_Common.TrdFilterConditions.encode(message.filterConditions, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Trd_GetOrderFillList.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_GetOrderFillList.C2S
         * @static
         * @param {Trd_GetOrderFillList.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_GetOrderFillList.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_GetOrderFillList.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_GetOrderFillList.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.header = $root.Trd_Common.TrdHeader.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.filterConditions = $root.Trd_Common.TrdFilterConditions.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("header"))
                throw $util.ProtocolError("missing required 'header'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_GetOrderFillList.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_GetOrderFillList.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Trd_GetOrderFillList.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Trd_Common.TrdHeader.verify(message.header);
                if (error)
                    return "header." + error;
            }
            if (message.filterConditions != null && message.hasOwnProperty("filterConditions")) {
                var error = $root.Trd_Common.TrdFilterConditions.verify(message.filterConditions);
                if (error)
                    return "filterConditions." + error;
            }
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_GetOrderFillList.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_GetOrderFillList.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_GetOrderFillList.C2S)
                return object;
            var message = new $root.Trd_GetOrderFillList.C2S();
            if (object.header != null) {
                if (typeof object.header !== "object")
                    throw TypeError(".Trd_GetOrderFillList.C2S.header: object expected");
                message.header = $root.Trd_Common.TrdHeader.fromObject(object.header);
            }
            if (object.filterConditions != null) {
                if (typeof object.filterConditions !== "object")
                    throw TypeError(".Trd_GetOrderFillList.C2S.filterConditions: object expected");
                message.filterConditions = $root.Trd_Common.TrdFilterConditions.fromObject(object.filterConditions);
            }
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_GetOrderFillList.C2S
         * @static
         * @param {Trd_GetOrderFillList.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.header = null;
                object.filterConditions = null;
            }
            if (message.header != null && message.hasOwnProperty("header"))
                object.header = $root.Trd_Common.TrdHeader.toObject(message.header, options);
            if (message.filterConditions != null && message.hasOwnProperty("filterConditions"))
                object.filterConditions = $root.Trd_Common.TrdFilterConditions.toObject(message.filterConditions, options);
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Trd_GetOrderFillList.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Trd_GetOrderFillList.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Trd_GetOrderFillList
         * @interface IS2C
         * @property {Trd_Common.ITrdHeader} header S2C header
         * @property {Array.<Trd_Common.IOrderFill>|null} [orderFillList] S2C orderFillList
         */

        /**
         * Constructs a new S2C.
         * @memberof Trd_GetOrderFillList
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Trd_GetOrderFillList.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.orderFillList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C header.
         * @member {Trd_Common.ITrdHeader} header
         * @memberof Trd_GetOrderFillList.S2C
         * @instance
         */
        S2C.prototype.header = null;

        /**
         * S2C orderFillList.
         * @member {Array.<Trd_Common.IOrderFill>} orderFillList
         * @memberof Trd_GetOrderFillList.S2C
         * @instance
         */
        S2C.prototype.orderFillList = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Trd_GetOrderFillList.S2C
         * @static
         * @param {Trd_GetOrderFillList.IS2C=} [properties] Properties to set
         * @returns {Trd_GetOrderFillList.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Trd_GetOrderFillList.S2C.verify|verify} messages.
         * @function encode
         * @memberof Trd_GetOrderFillList.S2C
         * @static
         * @param {Trd_GetOrderFillList.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Trd_Common.TrdHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.orderFillList != null && message.orderFillList.length)
                for (var i = 0; i < message.orderFillList.length; ++i)
                    $root.Trd_Common.OrderFill.encode(message.orderFillList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Trd_GetOrderFillList.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_GetOrderFillList.S2C
         * @static
         * @param {Trd_GetOrderFillList.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_GetOrderFillList.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_GetOrderFillList.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_GetOrderFillList.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.header = $root.Trd_Common.TrdHeader.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.orderFillList && message.orderFillList.length))
                        message.orderFillList = [];
                    message.orderFillList.push($root.Trd_Common.OrderFill.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("header"))
                throw $util.ProtocolError("missing required 'header'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_GetOrderFillList.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_GetOrderFillList.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Trd_GetOrderFillList.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Trd_Common.TrdHeader.verify(message.header);
                if (error)
                    return "header." + error;
            }
            if (message.orderFillList != null && message.hasOwnProperty("orderFillList")) {
                if (!Array.isArray(message.orderFillList))
                    return "orderFillList: array expected";
                for (var i = 0; i < message.orderFillList.length; ++i) {
                    var error = $root.Trd_Common.OrderFill.verify(message.orderFillList[i]);
                    if (error)
                        return "orderFillList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_GetOrderFillList.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_GetOrderFillList.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_GetOrderFillList.S2C)
                return object;
            var message = new $root.Trd_GetOrderFillList.S2C();
            if (object.header != null) {
                if (typeof object.header !== "object")
                    throw TypeError(".Trd_GetOrderFillList.S2C.header: object expected");
                message.header = $root.Trd_Common.TrdHeader.fromObject(object.header);
            }
            if (object.orderFillList) {
                if (!Array.isArray(object.orderFillList))
                    throw TypeError(".Trd_GetOrderFillList.S2C.orderFillList: array expected");
                message.orderFillList = [];
                for (var i = 0; i < object.orderFillList.length; ++i) {
                    if (typeof object.orderFillList[i] !== "object")
                        throw TypeError(".Trd_GetOrderFillList.S2C.orderFillList: object expected");
                    message.orderFillList[i] = $root.Trd_Common.OrderFill.fromObject(object.orderFillList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_GetOrderFillList.S2C
         * @static
         * @param {Trd_GetOrderFillList.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.orderFillList = [];
            if (options.defaults)
                object.header = null;
            if (message.header != null && message.hasOwnProperty("header"))
                object.header = $root.Trd_Common.TrdHeader.toObject(message.header, options);
            if (message.orderFillList && message.orderFillList.length) {
                object.orderFillList = [];
                for (var j = 0; j < message.orderFillList.length; ++j)
                    object.orderFillList[j] = $root.Trd_Common.OrderFill.toObject(message.orderFillList[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Trd_GetOrderFillList.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Trd_GetOrderFillList.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Trd_GetOrderFillList
         * @interface IRequest
         * @property {Trd_GetOrderFillList.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Trd_GetOrderFillList
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Trd_GetOrderFillList.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Trd_GetOrderFillList.IC2S} c2s
         * @memberof Trd_GetOrderFillList.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Trd_GetOrderFillList.Request
         * @static
         * @param {Trd_GetOrderFillList.IRequest=} [properties] Properties to set
         * @returns {Trd_GetOrderFillList.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Trd_GetOrderFillList.Request.verify|verify} messages.
         * @function encode
         * @memberof Trd_GetOrderFillList.Request
         * @static
         * @param {Trd_GetOrderFillList.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Trd_GetOrderFillList.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Trd_GetOrderFillList.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_GetOrderFillList.Request
         * @static
         * @param {Trd_GetOrderFillList.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_GetOrderFillList.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_GetOrderFillList.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_GetOrderFillList.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Trd_GetOrderFillList.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_GetOrderFillList.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_GetOrderFillList.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Trd_GetOrderFillList.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Trd_GetOrderFillList.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_GetOrderFillList.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_GetOrderFillList.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_GetOrderFillList.Request)
                return object;
            var message = new $root.Trd_GetOrderFillList.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Trd_GetOrderFillList.Request.c2s: object expected");
                message.c2s = $root.Trd_GetOrderFillList.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_GetOrderFillList.Request
         * @static
         * @param {Trd_GetOrderFillList.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Trd_GetOrderFillList.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Trd_GetOrderFillList.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Trd_GetOrderFillList.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Trd_GetOrderFillList
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Trd_GetOrderFillList.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Trd_GetOrderFillList
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Trd_GetOrderFillList.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Trd_GetOrderFillList.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Trd_GetOrderFillList.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Trd_GetOrderFillList.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Trd_GetOrderFillList.IS2C|null|undefined} s2c
         * @memberof Trd_GetOrderFillList.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Trd_GetOrderFillList.Response
         * @static
         * @param {Trd_GetOrderFillList.IResponse=} [properties] Properties to set
         * @returns {Trd_GetOrderFillList.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Trd_GetOrderFillList.Response.verify|verify} messages.
         * @function encode
         * @memberof Trd_GetOrderFillList.Response
         * @static
         * @param {Trd_GetOrderFillList.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Trd_GetOrderFillList.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Trd_GetOrderFillList.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_GetOrderFillList.Response
         * @static
         * @param {Trd_GetOrderFillList.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_GetOrderFillList.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_GetOrderFillList.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_GetOrderFillList.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Trd_GetOrderFillList.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_GetOrderFillList.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_GetOrderFillList.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Trd_GetOrderFillList.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Trd_GetOrderFillList.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_GetOrderFillList.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_GetOrderFillList.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_GetOrderFillList.Response)
                return object;
            var message = new $root.Trd_GetOrderFillList.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Trd_GetOrderFillList.Response.s2c: object expected");
                message.s2c = $root.Trd_GetOrderFillList.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_GetOrderFillList.Response
         * @static
         * @param {Trd_GetOrderFillList.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Trd_GetOrderFillList.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Trd_GetOrderFillList.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Trd_GetOrderFillList;
})();

$root.Trd_GetOrderList = (function() {

    /**
     * Namespace Trd_GetOrderList.
     * @exports Trd_GetOrderList
     * @namespace
     */
    var Trd_GetOrderList = {};

    Trd_GetOrderList.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Trd_GetOrderList
         * @interface IC2S
         * @property {Trd_Common.ITrdHeader} header C2S header
         * @property {Trd_Common.ITrdFilterConditions|null} [filterConditions] C2S filterConditions
         * @property {Array.<number>|null} [filterStatusList] C2S filterStatusList
         */

        /**
         * Constructs a new C2S.
         * @memberof Trd_GetOrderList
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Trd_GetOrderList.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            this.filterStatusList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S header.
         * @member {Trd_Common.ITrdHeader} header
         * @memberof Trd_GetOrderList.C2S
         * @instance
         */
        C2S.prototype.header = null;

        /**
         * C2S filterConditions.
         * @member {Trd_Common.ITrdFilterConditions|null|undefined} filterConditions
         * @memberof Trd_GetOrderList.C2S
         * @instance
         */
        C2S.prototype.filterConditions = null;

        /**
         * C2S filterStatusList.
         * @member {Array.<number>} filterStatusList
         * @memberof Trd_GetOrderList.C2S
         * @instance
         */
        C2S.prototype.filterStatusList = $util.emptyArray;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Trd_GetOrderList.C2S
         * @static
         * @param {Trd_GetOrderList.IC2S=} [properties] Properties to set
         * @returns {Trd_GetOrderList.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Trd_GetOrderList.C2S.verify|verify} messages.
         * @function encode
         * @memberof Trd_GetOrderList.C2S
         * @static
         * @param {Trd_GetOrderList.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Trd_Common.TrdHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.filterConditions != null && message.hasOwnProperty("filterConditions"))
                $root.Trd_Common.TrdFilterConditions.encode(message.filterConditions, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.filterStatusList != null && message.filterStatusList.length)
                for (var i = 0; i < message.filterStatusList.length; ++i)
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.filterStatusList[i]);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Trd_GetOrderList.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_GetOrderList.C2S
         * @static
         * @param {Trd_GetOrderList.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_GetOrderList.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_GetOrderList.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_GetOrderList.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.header = $root.Trd_Common.TrdHeader.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.filterConditions = $root.Trd_Common.TrdFilterConditions.decode(reader, reader.uint32());
                    break;
                case 3:
                    if (!(message.filterStatusList && message.filterStatusList.length))
                        message.filterStatusList = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.filterStatusList.push(reader.int32());
                    } else
                        message.filterStatusList.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("header"))
                throw $util.ProtocolError("missing required 'header'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_GetOrderList.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_GetOrderList.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Trd_GetOrderList.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Trd_Common.TrdHeader.verify(message.header);
                if (error)
                    return "header." + error;
            }
            if (message.filterConditions != null && message.hasOwnProperty("filterConditions")) {
                var error = $root.Trd_Common.TrdFilterConditions.verify(message.filterConditions);
                if (error)
                    return "filterConditions." + error;
            }
            if (message.filterStatusList != null && message.hasOwnProperty("filterStatusList")) {
                if (!Array.isArray(message.filterStatusList))
                    return "filterStatusList: array expected";
                for (var i = 0; i < message.filterStatusList.length; ++i)
                    if (!$util.isInteger(message.filterStatusList[i]))
                        return "filterStatusList: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_GetOrderList.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_GetOrderList.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_GetOrderList.C2S)
                return object;
            var message = new $root.Trd_GetOrderList.C2S();
            if (object.header != null) {
                if (typeof object.header !== "object")
                    throw TypeError(".Trd_GetOrderList.C2S.header: object expected");
                message.header = $root.Trd_Common.TrdHeader.fromObject(object.header);
            }
            if (object.filterConditions != null) {
                if (typeof object.filterConditions !== "object")
                    throw TypeError(".Trd_GetOrderList.C2S.filterConditions: object expected");
                message.filterConditions = $root.Trd_Common.TrdFilterConditions.fromObject(object.filterConditions);
            }
            if (object.filterStatusList) {
                if (!Array.isArray(object.filterStatusList))
                    throw TypeError(".Trd_GetOrderList.C2S.filterStatusList: array expected");
                message.filterStatusList = [];
                for (var i = 0; i < object.filterStatusList.length; ++i)
                    message.filterStatusList[i] = object.filterStatusList[i] | 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_GetOrderList.C2S
         * @static
         * @param {Trd_GetOrderList.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.filterStatusList = [];
            if (options.defaults) {
                object.header = null;
                object.filterConditions = null;
            }
            if (message.header != null && message.hasOwnProperty("header"))
                object.header = $root.Trd_Common.TrdHeader.toObject(message.header, options);
            if (message.filterConditions != null && message.hasOwnProperty("filterConditions"))
                object.filterConditions = $root.Trd_Common.TrdFilterConditions.toObject(message.filterConditions, options);
            if (message.filterStatusList && message.filterStatusList.length) {
                object.filterStatusList = [];
                for (var j = 0; j < message.filterStatusList.length; ++j)
                    object.filterStatusList[j] = message.filterStatusList[j];
            }
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Trd_GetOrderList.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Trd_GetOrderList.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Trd_GetOrderList
         * @interface IS2C
         * @property {Trd_Common.ITrdHeader} header S2C header
         * @property {Array.<Trd_Common.IOrder>|null} [orderList] S2C orderList
         */

        /**
         * Constructs a new S2C.
         * @memberof Trd_GetOrderList
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Trd_GetOrderList.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.orderList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C header.
         * @member {Trd_Common.ITrdHeader} header
         * @memberof Trd_GetOrderList.S2C
         * @instance
         */
        S2C.prototype.header = null;

        /**
         * S2C orderList.
         * @member {Array.<Trd_Common.IOrder>} orderList
         * @memberof Trd_GetOrderList.S2C
         * @instance
         */
        S2C.prototype.orderList = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Trd_GetOrderList.S2C
         * @static
         * @param {Trd_GetOrderList.IS2C=} [properties] Properties to set
         * @returns {Trd_GetOrderList.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Trd_GetOrderList.S2C.verify|verify} messages.
         * @function encode
         * @memberof Trd_GetOrderList.S2C
         * @static
         * @param {Trd_GetOrderList.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Trd_Common.TrdHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.orderList != null && message.orderList.length)
                for (var i = 0; i < message.orderList.length; ++i)
                    $root.Trd_Common.Order.encode(message.orderList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Trd_GetOrderList.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_GetOrderList.S2C
         * @static
         * @param {Trd_GetOrderList.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_GetOrderList.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_GetOrderList.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_GetOrderList.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.header = $root.Trd_Common.TrdHeader.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.orderList && message.orderList.length))
                        message.orderList = [];
                    message.orderList.push($root.Trd_Common.Order.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("header"))
                throw $util.ProtocolError("missing required 'header'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_GetOrderList.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_GetOrderList.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Trd_GetOrderList.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Trd_Common.TrdHeader.verify(message.header);
                if (error)
                    return "header." + error;
            }
            if (message.orderList != null && message.hasOwnProperty("orderList")) {
                if (!Array.isArray(message.orderList))
                    return "orderList: array expected";
                for (var i = 0; i < message.orderList.length; ++i) {
                    var error = $root.Trd_Common.Order.verify(message.orderList[i]);
                    if (error)
                        return "orderList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_GetOrderList.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_GetOrderList.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_GetOrderList.S2C)
                return object;
            var message = new $root.Trd_GetOrderList.S2C();
            if (object.header != null) {
                if (typeof object.header !== "object")
                    throw TypeError(".Trd_GetOrderList.S2C.header: object expected");
                message.header = $root.Trd_Common.TrdHeader.fromObject(object.header);
            }
            if (object.orderList) {
                if (!Array.isArray(object.orderList))
                    throw TypeError(".Trd_GetOrderList.S2C.orderList: array expected");
                message.orderList = [];
                for (var i = 0; i < object.orderList.length; ++i) {
                    if (typeof object.orderList[i] !== "object")
                        throw TypeError(".Trd_GetOrderList.S2C.orderList: object expected");
                    message.orderList[i] = $root.Trd_Common.Order.fromObject(object.orderList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_GetOrderList.S2C
         * @static
         * @param {Trd_GetOrderList.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.orderList = [];
            if (options.defaults)
                object.header = null;
            if (message.header != null && message.hasOwnProperty("header"))
                object.header = $root.Trd_Common.TrdHeader.toObject(message.header, options);
            if (message.orderList && message.orderList.length) {
                object.orderList = [];
                for (var j = 0; j < message.orderList.length; ++j)
                    object.orderList[j] = $root.Trd_Common.Order.toObject(message.orderList[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Trd_GetOrderList.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Trd_GetOrderList.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Trd_GetOrderList
         * @interface IRequest
         * @property {Trd_GetOrderList.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Trd_GetOrderList
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Trd_GetOrderList.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Trd_GetOrderList.IC2S} c2s
         * @memberof Trd_GetOrderList.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Trd_GetOrderList.Request
         * @static
         * @param {Trd_GetOrderList.IRequest=} [properties] Properties to set
         * @returns {Trd_GetOrderList.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Trd_GetOrderList.Request.verify|verify} messages.
         * @function encode
         * @memberof Trd_GetOrderList.Request
         * @static
         * @param {Trd_GetOrderList.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Trd_GetOrderList.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Trd_GetOrderList.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_GetOrderList.Request
         * @static
         * @param {Trd_GetOrderList.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_GetOrderList.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_GetOrderList.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_GetOrderList.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Trd_GetOrderList.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_GetOrderList.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_GetOrderList.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Trd_GetOrderList.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Trd_GetOrderList.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_GetOrderList.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_GetOrderList.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_GetOrderList.Request)
                return object;
            var message = new $root.Trd_GetOrderList.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Trd_GetOrderList.Request.c2s: object expected");
                message.c2s = $root.Trd_GetOrderList.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_GetOrderList.Request
         * @static
         * @param {Trd_GetOrderList.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Trd_GetOrderList.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Trd_GetOrderList.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Trd_GetOrderList.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Trd_GetOrderList
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Trd_GetOrderList.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Trd_GetOrderList
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Trd_GetOrderList.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Trd_GetOrderList.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Trd_GetOrderList.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Trd_GetOrderList.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Trd_GetOrderList.IS2C|null|undefined} s2c
         * @memberof Trd_GetOrderList.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Trd_GetOrderList.Response
         * @static
         * @param {Trd_GetOrderList.IResponse=} [properties] Properties to set
         * @returns {Trd_GetOrderList.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Trd_GetOrderList.Response.verify|verify} messages.
         * @function encode
         * @memberof Trd_GetOrderList.Response
         * @static
         * @param {Trd_GetOrderList.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Trd_GetOrderList.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Trd_GetOrderList.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_GetOrderList.Response
         * @static
         * @param {Trd_GetOrderList.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_GetOrderList.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_GetOrderList.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_GetOrderList.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Trd_GetOrderList.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_GetOrderList.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_GetOrderList.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Trd_GetOrderList.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Trd_GetOrderList.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_GetOrderList.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_GetOrderList.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_GetOrderList.Response)
                return object;
            var message = new $root.Trd_GetOrderList.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Trd_GetOrderList.Response.s2c: object expected");
                message.s2c = $root.Trd_GetOrderList.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_GetOrderList.Response
         * @static
         * @param {Trd_GetOrderList.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Trd_GetOrderList.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Trd_GetOrderList.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Trd_GetOrderList;
})();

$root.Trd_GetPositionList = (function() {

    /**
     * Namespace Trd_GetPositionList.
     * @exports Trd_GetPositionList
     * @namespace
     */
    var Trd_GetPositionList = {};

    Trd_GetPositionList.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Trd_GetPositionList
         * @interface IC2S
         * @property {Trd_Common.ITrdHeader} header C2S header
         * @property {Trd_Common.ITrdFilterConditions|null} [filterConditions] C2S filterConditions
         * @property {number|null} [filterPLRatioMin] C2S filterPLRatioMin
         * @property {number|null} [filterPLRatioMax] C2S filterPLRatioMax
         */

        /**
         * Constructs a new C2S.
         * @memberof Trd_GetPositionList
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Trd_GetPositionList.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S header.
         * @member {Trd_Common.ITrdHeader} header
         * @memberof Trd_GetPositionList.C2S
         * @instance
         */
        C2S.prototype.header = null;

        /**
         * C2S filterConditions.
         * @member {Trd_Common.ITrdFilterConditions|null|undefined} filterConditions
         * @memberof Trd_GetPositionList.C2S
         * @instance
         */
        C2S.prototype.filterConditions = null;

        /**
         * C2S filterPLRatioMin.
         * @member {number} filterPLRatioMin
         * @memberof Trd_GetPositionList.C2S
         * @instance
         */
        C2S.prototype.filterPLRatioMin = 0;

        /**
         * C2S filterPLRatioMax.
         * @member {number} filterPLRatioMax
         * @memberof Trd_GetPositionList.C2S
         * @instance
         */
        C2S.prototype.filterPLRatioMax = 0;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Trd_GetPositionList.C2S
         * @static
         * @param {Trd_GetPositionList.IC2S=} [properties] Properties to set
         * @returns {Trd_GetPositionList.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Trd_GetPositionList.C2S.verify|verify} messages.
         * @function encode
         * @memberof Trd_GetPositionList.C2S
         * @static
         * @param {Trd_GetPositionList.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Trd_Common.TrdHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.filterConditions != null && message.hasOwnProperty("filterConditions"))
                $root.Trd_Common.TrdFilterConditions.encode(message.filterConditions, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.filterPLRatioMin != null && message.hasOwnProperty("filterPLRatioMin"))
                writer.uint32(/* id 3, wireType 1 =*/25).double(message.filterPLRatioMin);
            if (message.filterPLRatioMax != null && message.hasOwnProperty("filterPLRatioMax"))
                writer.uint32(/* id 4, wireType 1 =*/33).double(message.filterPLRatioMax);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Trd_GetPositionList.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_GetPositionList.C2S
         * @static
         * @param {Trd_GetPositionList.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_GetPositionList.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_GetPositionList.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_GetPositionList.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.header = $root.Trd_Common.TrdHeader.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.filterConditions = $root.Trd_Common.TrdFilterConditions.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.filterPLRatioMin = reader.double();
                    break;
                case 4:
                    message.filterPLRatioMax = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("header"))
                throw $util.ProtocolError("missing required 'header'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_GetPositionList.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_GetPositionList.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Trd_GetPositionList.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Trd_Common.TrdHeader.verify(message.header);
                if (error)
                    return "header." + error;
            }
            if (message.filterConditions != null && message.hasOwnProperty("filterConditions")) {
                var error = $root.Trd_Common.TrdFilterConditions.verify(message.filterConditions);
                if (error)
                    return "filterConditions." + error;
            }
            if (message.filterPLRatioMin != null && message.hasOwnProperty("filterPLRatioMin"))
                if (typeof message.filterPLRatioMin !== "number")
                    return "filterPLRatioMin: number expected";
            if (message.filterPLRatioMax != null && message.hasOwnProperty("filterPLRatioMax"))
                if (typeof message.filterPLRatioMax !== "number")
                    return "filterPLRatioMax: number expected";
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_GetPositionList.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_GetPositionList.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_GetPositionList.C2S)
                return object;
            var message = new $root.Trd_GetPositionList.C2S();
            if (object.header != null) {
                if (typeof object.header !== "object")
                    throw TypeError(".Trd_GetPositionList.C2S.header: object expected");
                message.header = $root.Trd_Common.TrdHeader.fromObject(object.header);
            }
            if (object.filterConditions != null) {
                if (typeof object.filterConditions !== "object")
                    throw TypeError(".Trd_GetPositionList.C2S.filterConditions: object expected");
                message.filterConditions = $root.Trd_Common.TrdFilterConditions.fromObject(object.filterConditions);
            }
            if (object.filterPLRatioMin != null)
                message.filterPLRatioMin = Number(object.filterPLRatioMin);
            if (object.filterPLRatioMax != null)
                message.filterPLRatioMax = Number(object.filterPLRatioMax);
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_GetPositionList.C2S
         * @static
         * @param {Trd_GetPositionList.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.header = null;
                object.filterConditions = null;
                object.filterPLRatioMin = 0;
                object.filterPLRatioMax = 0;
            }
            if (message.header != null && message.hasOwnProperty("header"))
                object.header = $root.Trd_Common.TrdHeader.toObject(message.header, options);
            if (message.filterConditions != null && message.hasOwnProperty("filterConditions"))
                object.filterConditions = $root.Trd_Common.TrdFilterConditions.toObject(message.filterConditions, options);
            if (message.filterPLRatioMin != null && message.hasOwnProperty("filterPLRatioMin"))
                object.filterPLRatioMin = options.json && !isFinite(message.filterPLRatioMin) ? String(message.filterPLRatioMin) : message.filterPLRatioMin;
            if (message.filterPLRatioMax != null && message.hasOwnProperty("filterPLRatioMax"))
                object.filterPLRatioMax = options.json && !isFinite(message.filterPLRatioMax) ? String(message.filterPLRatioMax) : message.filterPLRatioMax;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Trd_GetPositionList.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Trd_GetPositionList.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Trd_GetPositionList
         * @interface IS2C
         * @property {Trd_Common.ITrdHeader} header S2C header
         * @property {Array.<Trd_Common.IPosition>|null} [positionList] S2C positionList
         */

        /**
         * Constructs a new S2C.
         * @memberof Trd_GetPositionList
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Trd_GetPositionList.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            this.positionList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C header.
         * @member {Trd_Common.ITrdHeader} header
         * @memberof Trd_GetPositionList.S2C
         * @instance
         */
        S2C.prototype.header = null;

        /**
         * S2C positionList.
         * @member {Array.<Trd_Common.IPosition>} positionList
         * @memberof Trd_GetPositionList.S2C
         * @instance
         */
        S2C.prototype.positionList = $util.emptyArray;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Trd_GetPositionList.S2C
         * @static
         * @param {Trd_GetPositionList.IS2C=} [properties] Properties to set
         * @returns {Trd_GetPositionList.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Trd_GetPositionList.S2C.verify|verify} messages.
         * @function encode
         * @memberof Trd_GetPositionList.S2C
         * @static
         * @param {Trd_GetPositionList.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Trd_Common.TrdHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.positionList != null && message.positionList.length)
                for (var i = 0; i < message.positionList.length; ++i)
                    $root.Trd_Common.Position.encode(message.positionList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Trd_GetPositionList.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_GetPositionList.S2C
         * @static
         * @param {Trd_GetPositionList.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_GetPositionList.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_GetPositionList.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_GetPositionList.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.header = $root.Trd_Common.TrdHeader.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.positionList && message.positionList.length))
                        message.positionList = [];
                    message.positionList.push($root.Trd_Common.Position.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("header"))
                throw $util.ProtocolError("missing required 'header'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_GetPositionList.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_GetPositionList.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Trd_GetPositionList.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Trd_Common.TrdHeader.verify(message.header);
                if (error)
                    return "header." + error;
            }
            if (message.positionList != null && message.hasOwnProperty("positionList")) {
                if (!Array.isArray(message.positionList))
                    return "positionList: array expected";
                for (var i = 0; i < message.positionList.length; ++i) {
                    var error = $root.Trd_Common.Position.verify(message.positionList[i]);
                    if (error)
                        return "positionList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_GetPositionList.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_GetPositionList.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_GetPositionList.S2C)
                return object;
            var message = new $root.Trd_GetPositionList.S2C();
            if (object.header != null) {
                if (typeof object.header !== "object")
                    throw TypeError(".Trd_GetPositionList.S2C.header: object expected");
                message.header = $root.Trd_Common.TrdHeader.fromObject(object.header);
            }
            if (object.positionList) {
                if (!Array.isArray(object.positionList))
                    throw TypeError(".Trd_GetPositionList.S2C.positionList: array expected");
                message.positionList = [];
                for (var i = 0; i < object.positionList.length; ++i) {
                    if (typeof object.positionList[i] !== "object")
                        throw TypeError(".Trd_GetPositionList.S2C.positionList: object expected");
                    message.positionList[i] = $root.Trd_Common.Position.fromObject(object.positionList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_GetPositionList.S2C
         * @static
         * @param {Trd_GetPositionList.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.positionList = [];
            if (options.defaults)
                object.header = null;
            if (message.header != null && message.hasOwnProperty("header"))
                object.header = $root.Trd_Common.TrdHeader.toObject(message.header, options);
            if (message.positionList && message.positionList.length) {
                object.positionList = [];
                for (var j = 0; j < message.positionList.length; ++j)
                    object.positionList[j] = $root.Trd_Common.Position.toObject(message.positionList[j], options);
            }
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Trd_GetPositionList.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Trd_GetPositionList.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Trd_GetPositionList
         * @interface IRequest
         * @property {Trd_GetPositionList.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Trd_GetPositionList
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Trd_GetPositionList.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Trd_GetPositionList.IC2S} c2s
         * @memberof Trd_GetPositionList.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Trd_GetPositionList.Request
         * @static
         * @param {Trd_GetPositionList.IRequest=} [properties] Properties to set
         * @returns {Trd_GetPositionList.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Trd_GetPositionList.Request.verify|verify} messages.
         * @function encode
         * @memberof Trd_GetPositionList.Request
         * @static
         * @param {Trd_GetPositionList.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Trd_GetPositionList.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Trd_GetPositionList.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_GetPositionList.Request
         * @static
         * @param {Trd_GetPositionList.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_GetPositionList.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_GetPositionList.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_GetPositionList.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Trd_GetPositionList.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_GetPositionList.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_GetPositionList.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Trd_GetPositionList.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Trd_GetPositionList.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_GetPositionList.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_GetPositionList.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_GetPositionList.Request)
                return object;
            var message = new $root.Trd_GetPositionList.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Trd_GetPositionList.Request.c2s: object expected");
                message.c2s = $root.Trd_GetPositionList.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_GetPositionList.Request
         * @static
         * @param {Trd_GetPositionList.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Trd_GetPositionList.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Trd_GetPositionList.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Trd_GetPositionList.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Trd_GetPositionList
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Trd_GetPositionList.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Trd_GetPositionList
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Trd_GetPositionList.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Trd_GetPositionList.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Trd_GetPositionList.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Trd_GetPositionList.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Trd_GetPositionList.IS2C|null|undefined} s2c
         * @memberof Trd_GetPositionList.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Trd_GetPositionList.Response
         * @static
         * @param {Trd_GetPositionList.IResponse=} [properties] Properties to set
         * @returns {Trd_GetPositionList.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Trd_GetPositionList.Response.verify|verify} messages.
         * @function encode
         * @memberof Trd_GetPositionList.Response
         * @static
         * @param {Trd_GetPositionList.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Trd_GetPositionList.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Trd_GetPositionList.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_GetPositionList.Response
         * @static
         * @param {Trd_GetPositionList.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_GetPositionList.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_GetPositionList.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_GetPositionList.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Trd_GetPositionList.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_GetPositionList.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_GetPositionList.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Trd_GetPositionList.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Trd_GetPositionList.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_GetPositionList.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_GetPositionList.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_GetPositionList.Response)
                return object;
            var message = new $root.Trd_GetPositionList.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Trd_GetPositionList.Response.s2c: object expected");
                message.s2c = $root.Trd_GetPositionList.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_GetPositionList.Response
         * @static
         * @param {Trd_GetPositionList.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Trd_GetPositionList.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Trd_GetPositionList.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Trd_GetPositionList;
})();

$root.Trd_ModifyOrder = (function() {

    /**
     * Namespace Trd_ModifyOrder.
     * @exports Trd_ModifyOrder
     * @namespace
     */
    var Trd_ModifyOrder = {};

    Trd_ModifyOrder.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Trd_ModifyOrder
         * @interface IC2S
         * @property {Common.IPacketID} packetID C2S packetID
         * @property {Trd_Common.ITrdHeader} header C2S header
         * @property {number|Long} orderID C2S orderID
         * @property {number} modifyOrderOp C2S modifyOrderOp
         * @property {boolean|null} [forAll] C2S forAll
         * @property {number|null} [qty] C2S qty
         * @property {number|null} [price] C2S price
         * @property {boolean|null} [adjustPrice] C2S adjustPrice
         * @property {number|null} [adjustSideAndLimit] C2S adjustSideAndLimit
         */

        /**
         * Constructs a new C2S.
         * @memberof Trd_ModifyOrder
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Trd_ModifyOrder.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S packetID.
         * @member {Common.IPacketID} packetID
         * @memberof Trd_ModifyOrder.C2S
         * @instance
         */
        C2S.prototype.packetID = null;

        /**
         * C2S header.
         * @member {Trd_Common.ITrdHeader} header
         * @memberof Trd_ModifyOrder.C2S
         * @instance
         */
        C2S.prototype.header = null;

        /**
         * C2S orderID.
         * @member {number|Long} orderID
         * @memberof Trd_ModifyOrder.C2S
         * @instance
         */
        C2S.prototype.orderID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * C2S modifyOrderOp.
         * @member {number} modifyOrderOp
         * @memberof Trd_ModifyOrder.C2S
         * @instance
         */
        C2S.prototype.modifyOrderOp = 0;

        /**
         * C2S forAll.
         * @member {boolean} forAll
         * @memberof Trd_ModifyOrder.C2S
         * @instance
         */
        C2S.prototype.forAll = false;

        /**
         * C2S qty.
         * @member {number} qty
         * @memberof Trd_ModifyOrder.C2S
         * @instance
         */
        C2S.prototype.qty = 0;

        /**
         * C2S price.
         * @member {number} price
         * @memberof Trd_ModifyOrder.C2S
         * @instance
         */
        C2S.prototype.price = 0;

        /**
         * C2S adjustPrice.
         * @member {boolean} adjustPrice
         * @memberof Trd_ModifyOrder.C2S
         * @instance
         */
        C2S.prototype.adjustPrice = false;

        /**
         * C2S adjustSideAndLimit.
         * @member {number} adjustSideAndLimit
         * @memberof Trd_ModifyOrder.C2S
         * @instance
         */
        C2S.prototype.adjustSideAndLimit = 0;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Trd_ModifyOrder.C2S
         * @static
         * @param {Trd_ModifyOrder.IC2S=} [properties] Properties to set
         * @returns {Trd_ModifyOrder.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Trd_ModifyOrder.C2S.verify|verify} messages.
         * @function encode
         * @memberof Trd_ModifyOrder.C2S
         * @static
         * @param {Trd_ModifyOrder.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Common.PacketID.encode(message.packetID, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            $root.Trd_Common.TrdHeader.encode(message.header, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.orderID);
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.modifyOrderOp);
            if (message.forAll != null && message.hasOwnProperty("forAll"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.forAll);
            if (message.qty != null && message.hasOwnProperty("qty"))
                writer.uint32(/* id 8, wireType 1 =*/65).double(message.qty);
            if (message.price != null && message.hasOwnProperty("price"))
                writer.uint32(/* id 9, wireType 1 =*/73).double(message.price);
            if (message.adjustPrice != null && message.hasOwnProperty("adjustPrice"))
                writer.uint32(/* id 10, wireType 0 =*/80).bool(message.adjustPrice);
            if (message.adjustSideAndLimit != null && message.hasOwnProperty("adjustSideAndLimit"))
                writer.uint32(/* id 11, wireType 1 =*/89).double(message.adjustSideAndLimit);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Trd_ModifyOrder.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_ModifyOrder.C2S
         * @static
         * @param {Trd_ModifyOrder.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_ModifyOrder.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_ModifyOrder.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_ModifyOrder.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.packetID = $root.Common.PacketID.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.header = $root.Trd_Common.TrdHeader.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.orderID = reader.uint64();
                    break;
                case 4:
                    message.modifyOrderOp = reader.int32();
                    break;
                case 5:
                    message.forAll = reader.bool();
                    break;
                case 8:
                    message.qty = reader.double();
                    break;
                case 9:
                    message.price = reader.double();
                    break;
                case 10:
                    message.adjustPrice = reader.bool();
                    break;
                case 11:
                    message.adjustSideAndLimit = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("packetID"))
                throw $util.ProtocolError("missing required 'packetID'", { instance: message });
            if (!message.hasOwnProperty("header"))
                throw $util.ProtocolError("missing required 'header'", { instance: message });
            if (!message.hasOwnProperty("orderID"))
                throw $util.ProtocolError("missing required 'orderID'", { instance: message });
            if (!message.hasOwnProperty("modifyOrderOp"))
                throw $util.ProtocolError("missing required 'modifyOrderOp'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_ModifyOrder.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_ModifyOrder.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Trd_ModifyOrder.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Common.PacketID.verify(message.packetID);
                if (error)
                    return "packetID." + error;
            }
            {
                var error = $root.Trd_Common.TrdHeader.verify(message.header);
                if (error)
                    return "header." + error;
            }
            if (!$util.isInteger(message.orderID) && !(message.orderID && $util.isInteger(message.orderID.low) && $util.isInteger(message.orderID.high)))
                return "orderID: integer|Long expected";
            if (!$util.isInteger(message.modifyOrderOp))
                return "modifyOrderOp: integer expected";
            if (message.forAll != null && message.hasOwnProperty("forAll"))
                if (typeof message.forAll !== "boolean")
                    return "forAll: boolean expected";
            if (message.qty != null && message.hasOwnProperty("qty"))
                if (typeof message.qty !== "number")
                    return "qty: number expected";
            if (message.price != null && message.hasOwnProperty("price"))
                if (typeof message.price !== "number")
                    return "price: number expected";
            if (message.adjustPrice != null && message.hasOwnProperty("adjustPrice"))
                if (typeof message.adjustPrice !== "boolean")
                    return "adjustPrice: boolean expected";
            if (message.adjustSideAndLimit != null && message.hasOwnProperty("adjustSideAndLimit"))
                if (typeof message.adjustSideAndLimit !== "number")
                    return "adjustSideAndLimit: number expected";
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_ModifyOrder.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_ModifyOrder.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_ModifyOrder.C2S)
                return object;
            var message = new $root.Trd_ModifyOrder.C2S();
            if (object.packetID != null) {
                if (typeof object.packetID !== "object")
                    throw TypeError(".Trd_ModifyOrder.C2S.packetID: object expected");
                message.packetID = $root.Common.PacketID.fromObject(object.packetID);
            }
            if (object.header != null) {
                if (typeof object.header !== "object")
                    throw TypeError(".Trd_ModifyOrder.C2S.header: object expected");
                message.header = $root.Trd_Common.TrdHeader.fromObject(object.header);
            }
            if (object.orderID != null)
                if ($util.Long)
                    (message.orderID = $util.Long.fromValue(object.orderID)).unsigned = true;
                else if (typeof object.orderID === "string")
                    message.orderID = parseInt(object.orderID, 10);
                else if (typeof object.orderID === "number")
                    message.orderID = object.orderID;
                else if (typeof object.orderID === "object")
                    message.orderID = new $util.LongBits(object.orderID.low >>> 0, object.orderID.high >>> 0).toNumber(true);
            if (object.modifyOrderOp != null)
                message.modifyOrderOp = object.modifyOrderOp | 0;
            if (object.forAll != null)
                message.forAll = Boolean(object.forAll);
            if (object.qty != null)
                message.qty = Number(object.qty);
            if (object.price != null)
                message.price = Number(object.price);
            if (object.adjustPrice != null)
                message.adjustPrice = Boolean(object.adjustPrice);
            if (object.adjustSideAndLimit != null)
                message.adjustSideAndLimit = Number(object.adjustSideAndLimit);
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_ModifyOrder.C2S
         * @static
         * @param {Trd_ModifyOrder.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.packetID = null;
                object.header = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.orderID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.orderID = options.longs === String ? "0" : 0;
                object.modifyOrderOp = 0;
                object.forAll = false;
                object.qty = 0;
                object.price = 0;
                object.adjustPrice = false;
                object.adjustSideAndLimit = 0;
            }
            if (message.packetID != null && message.hasOwnProperty("packetID"))
                object.packetID = $root.Common.PacketID.toObject(message.packetID, options);
            if (message.header != null && message.hasOwnProperty("header"))
                object.header = $root.Trd_Common.TrdHeader.toObject(message.header, options);
            if (message.orderID != null && message.hasOwnProperty("orderID"))
                if (typeof message.orderID === "number")
                    object.orderID = options.longs === String ? String(message.orderID) : message.orderID;
                else
                    object.orderID = options.longs === String ? $util.Long.prototype.toString.call(message.orderID) : options.longs === Number ? new $util.LongBits(message.orderID.low >>> 0, message.orderID.high >>> 0).toNumber(true) : message.orderID;
            if (message.modifyOrderOp != null && message.hasOwnProperty("modifyOrderOp"))
                object.modifyOrderOp = message.modifyOrderOp;
            if (message.forAll != null && message.hasOwnProperty("forAll"))
                object.forAll = message.forAll;
            if (message.qty != null && message.hasOwnProperty("qty"))
                object.qty = options.json && !isFinite(message.qty) ? String(message.qty) : message.qty;
            if (message.price != null && message.hasOwnProperty("price"))
                object.price = options.json && !isFinite(message.price) ? String(message.price) : message.price;
            if (message.adjustPrice != null && message.hasOwnProperty("adjustPrice"))
                object.adjustPrice = message.adjustPrice;
            if (message.adjustSideAndLimit != null && message.hasOwnProperty("adjustSideAndLimit"))
                object.adjustSideAndLimit = options.json && !isFinite(message.adjustSideAndLimit) ? String(message.adjustSideAndLimit) : message.adjustSideAndLimit;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Trd_ModifyOrder.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Trd_ModifyOrder.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Trd_ModifyOrder
         * @interface IS2C
         * @property {Trd_Common.ITrdHeader} header S2C header
         * @property {number|Long} orderID S2C orderID
         */

        /**
         * Constructs a new S2C.
         * @memberof Trd_ModifyOrder
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Trd_ModifyOrder.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C header.
         * @member {Trd_Common.ITrdHeader} header
         * @memberof Trd_ModifyOrder.S2C
         * @instance
         */
        S2C.prototype.header = null;

        /**
         * S2C orderID.
         * @member {number|Long} orderID
         * @memberof Trd_ModifyOrder.S2C
         * @instance
         */
        S2C.prototype.orderID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Trd_ModifyOrder.S2C
         * @static
         * @param {Trd_ModifyOrder.IS2C=} [properties] Properties to set
         * @returns {Trd_ModifyOrder.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Trd_ModifyOrder.S2C.verify|verify} messages.
         * @function encode
         * @memberof Trd_ModifyOrder.S2C
         * @static
         * @param {Trd_ModifyOrder.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Trd_Common.TrdHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.orderID);
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Trd_ModifyOrder.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_ModifyOrder.S2C
         * @static
         * @param {Trd_ModifyOrder.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_ModifyOrder.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_ModifyOrder.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_ModifyOrder.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.header = $root.Trd_Common.TrdHeader.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.orderID = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("header"))
                throw $util.ProtocolError("missing required 'header'", { instance: message });
            if (!message.hasOwnProperty("orderID"))
                throw $util.ProtocolError("missing required 'orderID'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_ModifyOrder.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_ModifyOrder.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Trd_ModifyOrder.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Trd_Common.TrdHeader.verify(message.header);
                if (error)
                    return "header." + error;
            }
            if (!$util.isInteger(message.orderID) && !(message.orderID && $util.isInteger(message.orderID.low) && $util.isInteger(message.orderID.high)))
                return "orderID: integer|Long expected";
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_ModifyOrder.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_ModifyOrder.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_ModifyOrder.S2C)
                return object;
            var message = new $root.Trd_ModifyOrder.S2C();
            if (object.header != null) {
                if (typeof object.header !== "object")
                    throw TypeError(".Trd_ModifyOrder.S2C.header: object expected");
                message.header = $root.Trd_Common.TrdHeader.fromObject(object.header);
            }
            if (object.orderID != null)
                if ($util.Long)
                    (message.orderID = $util.Long.fromValue(object.orderID)).unsigned = true;
                else if (typeof object.orderID === "string")
                    message.orderID = parseInt(object.orderID, 10);
                else if (typeof object.orderID === "number")
                    message.orderID = object.orderID;
                else if (typeof object.orderID === "object")
                    message.orderID = new $util.LongBits(object.orderID.low >>> 0, object.orderID.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_ModifyOrder.S2C
         * @static
         * @param {Trd_ModifyOrder.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.header = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.orderID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.orderID = options.longs === String ? "0" : 0;
            }
            if (message.header != null && message.hasOwnProperty("header"))
                object.header = $root.Trd_Common.TrdHeader.toObject(message.header, options);
            if (message.orderID != null && message.hasOwnProperty("orderID"))
                if (typeof message.orderID === "number")
                    object.orderID = options.longs === String ? String(message.orderID) : message.orderID;
                else
                    object.orderID = options.longs === String ? $util.Long.prototype.toString.call(message.orderID) : options.longs === Number ? new $util.LongBits(message.orderID.low >>> 0, message.orderID.high >>> 0).toNumber(true) : message.orderID;
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Trd_ModifyOrder.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Trd_ModifyOrder.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Trd_ModifyOrder
         * @interface IRequest
         * @property {Trd_ModifyOrder.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Trd_ModifyOrder
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Trd_ModifyOrder.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Trd_ModifyOrder.IC2S} c2s
         * @memberof Trd_ModifyOrder.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Trd_ModifyOrder.Request
         * @static
         * @param {Trd_ModifyOrder.IRequest=} [properties] Properties to set
         * @returns {Trd_ModifyOrder.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Trd_ModifyOrder.Request.verify|verify} messages.
         * @function encode
         * @memberof Trd_ModifyOrder.Request
         * @static
         * @param {Trd_ModifyOrder.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Trd_ModifyOrder.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Trd_ModifyOrder.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_ModifyOrder.Request
         * @static
         * @param {Trd_ModifyOrder.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_ModifyOrder.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_ModifyOrder.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_ModifyOrder.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Trd_ModifyOrder.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_ModifyOrder.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_ModifyOrder.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Trd_ModifyOrder.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Trd_ModifyOrder.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_ModifyOrder.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_ModifyOrder.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_ModifyOrder.Request)
                return object;
            var message = new $root.Trd_ModifyOrder.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Trd_ModifyOrder.Request.c2s: object expected");
                message.c2s = $root.Trd_ModifyOrder.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_ModifyOrder.Request
         * @static
         * @param {Trd_ModifyOrder.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Trd_ModifyOrder.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Trd_ModifyOrder.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Trd_ModifyOrder.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Trd_ModifyOrder
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Trd_ModifyOrder.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Trd_ModifyOrder
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Trd_ModifyOrder.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Trd_ModifyOrder.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Trd_ModifyOrder.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Trd_ModifyOrder.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Trd_ModifyOrder.IS2C|null|undefined} s2c
         * @memberof Trd_ModifyOrder.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Trd_ModifyOrder.Response
         * @static
         * @param {Trd_ModifyOrder.IResponse=} [properties] Properties to set
         * @returns {Trd_ModifyOrder.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Trd_ModifyOrder.Response.verify|verify} messages.
         * @function encode
         * @memberof Trd_ModifyOrder.Response
         * @static
         * @param {Trd_ModifyOrder.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Trd_ModifyOrder.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Trd_ModifyOrder.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_ModifyOrder.Response
         * @static
         * @param {Trd_ModifyOrder.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_ModifyOrder.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_ModifyOrder.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_ModifyOrder.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Trd_ModifyOrder.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_ModifyOrder.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_ModifyOrder.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Trd_ModifyOrder.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Trd_ModifyOrder.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_ModifyOrder.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_ModifyOrder.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_ModifyOrder.Response)
                return object;
            var message = new $root.Trd_ModifyOrder.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Trd_ModifyOrder.Response.s2c: object expected");
                message.s2c = $root.Trd_ModifyOrder.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_ModifyOrder.Response
         * @static
         * @param {Trd_ModifyOrder.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Trd_ModifyOrder.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Trd_ModifyOrder.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Trd_ModifyOrder;
})();

$root.Trd_Notify = (function() {

    /**
     * Namespace Trd_Notify.
     * @exports Trd_Notify
     * @namespace
     */
    var Trd_Notify = {};

    Trd_Notify.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Trd_Notify
         * @interface IS2C
         * @property {Trd_Common.ITrdHeader} header S2C header
         * @property {number} type S2C type
         */

        /**
         * Constructs a new S2C.
         * @memberof Trd_Notify
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Trd_Notify.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C header.
         * @member {Trd_Common.ITrdHeader} header
         * @memberof Trd_Notify.S2C
         * @instance
         */
        S2C.prototype.header = null;

        /**
         * S2C type.
         * @member {number} type
         * @memberof Trd_Notify.S2C
         * @instance
         */
        S2C.prototype.type = 0;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Trd_Notify.S2C
         * @static
         * @param {Trd_Notify.IS2C=} [properties] Properties to set
         * @returns {Trd_Notify.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Trd_Notify.S2C.verify|verify} messages.
         * @function encode
         * @memberof Trd_Notify.S2C
         * @static
         * @param {Trd_Notify.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Trd_Common.TrdHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Trd_Notify.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_Notify.S2C
         * @static
         * @param {Trd_Notify.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_Notify.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_Notify.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_Notify.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.header = $root.Trd_Common.TrdHeader.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("header"))
                throw $util.ProtocolError("missing required 'header'", { instance: message });
            if (!message.hasOwnProperty("type"))
                throw $util.ProtocolError("missing required 'type'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_Notify.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_Notify.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Trd_Notify.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Trd_Common.TrdHeader.verify(message.header);
                if (error)
                    return "header." + error;
            }
            if (!$util.isInteger(message.type))
                return "type: integer expected";
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_Notify.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_Notify.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_Notify.S2C)
                return object;
            var message = new $root.Trd_Notify.S2C();
            if (object.header != null) {
                if (typeof object.header !== "object")
                    throw TypeError(".Trd_Notify.S2C.header: object expected");
                message.header = $root.Trd_Common.TrdHeader.fromObject(object.header);
            }
            if (object.type != null)
                message.type = object.type | 0;
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_Notify.S2C
         * @static
         * @param {Trd_Notify.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.header = null;
                object.type = 0;
            }
            if (message.header != null && message.hasOwnProperty("header"))
                object.header = $root.Trd_Common.TrdHeader.toObject(message.header, options);
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Trd_Notify.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Trd_Notify.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Trd_Notify
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Trd_Notify.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Trd_Notify
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Trd_Notify.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Trd_Notify.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Trd_Notify.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Trd_Notify.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Trd_Notify.IS2C|null|undefined} s2c
         * @memberof Trd_Notify.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Trd_Notify.Response
         * @static
         * @param {Trd_Notify.IResponse=} [properties] Properties to set
         * @returns {Trd_Notify.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Trd_Notify.Response.verify|verify} messages.
         * @function encode
         * @memberof Trd_Notify.Response
         * @static
         * @param {Trd_Notify.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Trd_Notify.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Trd_Notify.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_Notify.Response
         * @static
         * @param {Trd_Notify.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_Notify.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_Notify.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_Notify.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Trd_Notify.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_Notify.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_Notify.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Trd_Notify.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Trd_Notify.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_Notify.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_Notify.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_Notify.Response)
                return object;
            var message = new $root.Trd_Notify.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Trd_Notify.Response.s2c: object expected");
                message.s2c = $root.Trd_Notify.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_Notify.Response
         * @static
         * @param {Trd_Notify.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Trd_Notify.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Trd_Notify.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Trd_Notify;
})();

$root.Trd_PlaceOrder = (function() {

    /**
     * Namespace Trd_PlaceOrder.
     * @exports Trd_PlaceOrder
     * @namespace
     */
    var Trd_PlaceOrder = {};

    Trd_PlaceOrder.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Trd_PlaceOrder
         * @interface IC2S
         * @property {Common.IPacketID} packetID C2S packetID
         * @property {Trd_Common.ITrdHeader} header C2S header
         * @property {number} trdSide C2S trdSide
         * @property {number} orderType C2S orderType
         * @property {string} code C2S code
         * @property {number} qty C2S qty
         * @property {number|null} [price] C2S price
         * @property {boolean|null} [adjustPrice] C2S adjustPrice
         * @property {number|null} [adjustSideAndLimit] C2S adjustSideAndLimit
         * @property {number|null} [secMarket] C2S secMarket
         */

        /**
         * Constructs a new C2S.
         * @memberof Trd_PlaceOrder
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Trd_PlaceOrder.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S packetID.
         * @member {Common.IPacketID} packetID
         * @memberof Trd_PlaceOrder.C2S
         * @instance
         */
        C2S.prototype.packetID = null;

        /**
         * C2S header.
         * @member {Trd_Common.ITrdHeader} header
         * @memberof Trd_PlaceOrder.C2S
         * @instance
         */
        C2S.prototype.header = null;

        /**
         * C2S trdSide.
         * @member {number} trdSide
         * @memberof Trd_PlaceOrder.C2S
         * @instance
         */
        C2S.prototype.trdSide = 0;

        /**
         * C2S orderType.
         * @member {number} orderType
         * @memberof Trd_PlaceOrder.C2S
         * @instance
         */
        C2S.prototype.orderType = 0;

        /**
         * C2S code.
         * @member {string} code
         * @memberof Trd_PlaceOrder.C2S
         * @instance
         */
        C2S.prototype.code = "";

        /**
         * C2S qty.
         * @member {number} qty
         * @memberof Trd_PlaceOrder.C2S
         * @instance
         */
        C2S.prototype.qty = 0;

        /**
         * C2S price.
         * @member {number} price
         * @memberof Trd_PlaceOrder.C2S
         * @instance
         */
        C2S.prototype.price = 0;

        /**
         * C2S adjustPrice.
         * @member {boolean} adjustPrice
         * @memberof Trd_PlaceOrder.C2S
         * @instance
         */
        C2S.prototype.adjustPrice = false;

        /**
         * C2S adjustSideAndLimit.
         * @member {number} adjustSideAndLimit
         * @memberof Trd_PlaceOrder.C2S
         * @instance
         */
        C2S.prototype.adjustSideAndLimit = 0;

        /**
         * C2S secMarket.
         * @member {number} secMarket
         * @memberof Trd_PlaceOrder.C2S
         * @instance
         */
        C2S.prototype.secMarket = 0;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Trd_PlaceOrder.C2S
         * @static
         * @param {Trd_PlaceOrder.IC2S=} [properties] Properties to set
         * @returns {Trd_PlaceOrder.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Trd_PlaceOrder.C2S.verify|verify} messages.
         * @function encode
         * @memberof Trd_PlaceOrder.C2S
         * @static
         * @param {Trd_PlaceOrder.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Common.PacketID.encode(message.packetID, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            $root.Trd_Common.TrdHeader.encode(message.header, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.trdSide);
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.orderType);
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.code);
            writer.uint32(/* id 6, wireType 1 =*/49).double(message.qty);
            if (message.price != null && message.hasOwnProperty("price"))
                writer.uint32(/* id 7, wireType 1 =*/57).double(message.price);
            if (message.adjustPrice != null && message.hasOwnProperty("adjustPrice"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.adjustPrice);
            if (message.adjustSideAndLimit != null && message.hasOwnProperty("adjustSideAndLimit"))
                writer.uint32(/* id 9, wireType 1 =*/73).double(message.adjustSideAndLimit);
            if (message.secMarket != null && message.hasOwnProperty("secMarket"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.secMarket);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Trd_PlaceOrder.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_PlaceOrder.C2S
         * @static
         * @param {Trd_PlaceOrder.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_PlaceOrder.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_PlaceOrder.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_PlaceOrder.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.packetID = $root.Common.PacketID.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.header = $root.Trd_Common.TrdHeader.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.trdSide = reader.int32();
                    break;
                case 4:
                    message.orderType = reader.int32();
                    break;
                case 5:
                    message.code = reader.string();
                    break;
                case 6:
                    message.qty = reader.double();
                    break;
                case 7:
                    message.price = reader.double();
                    break;
                case 8:
                    message.adjustPrice = reader.bool();
                    break;
                case 9:
                    message.adjustSideAndLimit = reader.double();
                    break;
                case 10:
                    message.secMarket = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("packetID"))
                throw $util.ProtocolError("missing required 'packetID'", { instance: message });
            if (!message.hasOwnProperty("header"))
                throw $util.ProtocolError("missing required 'header'", { instance: message });
            if (!message.hasOwnProperty("trdSide"))
                throw $util.ProtocolError("missing required 'trdSide'", { instance: message });
            if (!message.hasOwnProperty("orderType"))
                throw $util.ProtocolError("missing required 'orderType'", { instance: message });
            if (!message.hasOwnProperty("code"))
                throw $util.ProtocolError("missing required 'code'", { instance: message });
            if (!message.hasOwnProperty("qty"))
                throw $util.ProtocolError("missing required 'qty'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_PlaceOrder.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_PlaceOrder.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Trd_PlaceOrder.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Common.PacketID.verify(message.packetID);
                if (error)
                    return "packetID." + error;
            }
            {
                var error = $root.Trd_Common.TrdHeader.verify(message.header);
                if (error)
                    return "header." + error;
            }
            if (!$util.isInteger(message.trdSide))
                return "trdSide: integer expected";
            if (!$util.isInteger(message.orderType))
                return "orderType: integer expected";
            if (!$util.isString(message.code))
                return "code: string expected";
            if (typeof message.qty !== "number")
                return "qty: number expected";
            if (message.price != null && message.hasOwnProperty("price"))
                if (typeof message.price !== "number")
                    return "price: number expected";
            if (message.adjustPrice != null && message.hasOwnProperty("adjustPrice"))
                if (typeof message.adjustPrice !== "boolean")
                    return "adjustPrice: boolean expected";
            if (message.adjustSideAndLimit != null && message.hasOwnProperty("adjustSideAndLimit"))
                if (typeof message.adjustSideAndLimit !== "number")
                    return "adjustSideAndLimit: number expected";
            if (message.secMarket != null && message.hasOwnProperty("secMarket"))
                if (!$util.isInteger(message.secMarket))
                    return "secMarket: integer expected";
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_PlaceOrder.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_PlaceOrder.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_PlaceOrder.C2S)
                return object;
            var message = new $root.Trd_PlaceOrder.C2S();
            if (object.packetID != null) {
                if (typeof object.packetID !== "object")
                    throw TypeError(".Trd_PlaceOrder.C2S.packetID: object expected");
                message.packetID = $root.Common.PacketID.fromObject(object.packetID);
            }
            if (object.header != null) {
                if (typeof object.header !== "object")
                    throw TypeError(".Trd_PlaceOrder.C2S.header: object expected");
                message.header = $root.Trd_Common.TrdHeader.fromObject(object.header);
            }
            if (object.trdSide != null)
                message.trdSide = object.trdSide | 0;
            if (object.orderType != null)
                message.orderType = object.orderType | 0;
            if (object.code != null)
                message.code = String(object.code);
            if (object.qty != null)
                message.qty = Number(object.qty);
            if (object.price != null)
                message.price = Number(object.price);
            if (object.adjustPrice != null)
                message.adjustPrice = Boolean(object.adjustPrice);
            if (object.adjustSideAndLimit != null)
                message.adjustSideAndLimit = Number(object.adjustSideAndLimit);
            if (object.secMarket != null)
                message.secMarket = object.secMarket | 0;
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_PlaceOrder.C2S
         * @static
         * @param {Trd_PlaceOrder.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.packetID = null;
                object.header = null;
                object.trdSide = 0;
                object.orderType = 0;
                object.code = "";
                object.qty = 0;
                object.price = 0;
                object.adjustPrice = false;
                object.adjustSideAndLimit = 0;
                object.secMarket = 0;
            }
            if (message.packetID != null && message.hasOwnProperty("packetID"))
                object.packetID = $root.Common.PacketID.toObject(message.packetID, options);
            if (message.header != null && message.hasOwnProperty("header"))
                object.header = $root.Trd_Common.TrdHeader.toObject(message.header, options);
            if (message.trdSide != null && message.hasOwnProperty("trdSide"))
                object.trdSide = message.trdSide;
            if (message.orderType != null && message.hasOwnProperty("orderType"))
                object.orderType = message.orderType;
            if (message.code != null && message.hasOwnProperty("code"))
                object.code = message.code;
            if (message.qty != null && message.hasOwnProperty("qty"))
                object.qty = options.json && !isFinite(message.qty) ? String(message.qty) : message.qty;
            if (message.price != null && message.hasOwnProperty("price"))
                object.price = options.json && !isFinite(message.price) ? String(message.price) : message.price;
            if (message.adjustPrice != null && message.hasOwnProperty("adjustPrice"))
                object.adjustPrice = message.adjustPrice;
            if (message.adjustSideAndLimit != null && message.hasOwnProperty("adjustSideAndLimit"))
                object.adjustSideAndLimit = options.json && !isFinite(message.adjustSideAndLimit) ? String(message.adjustSideAndLimit) : message.adjustSideAndLimit;
            if (message.secMarket != null && message.hasOwnProperty("secMarket"))
                object.secMarket = message.secMarket;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Trd_PlaceOrder.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Trd_PlaceOrder.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Trd_PlaceOrder
         * @interface IS2C
         * @property {Trd_Common.ITrdHeader} header S2C header
         * @property {number|Long|null} [orderID] S2C orderID
         */

        /**
         * Constructs a new S2C.
         * @memberof Trd_PlaceOrder
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Trd_PlaceOrder.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C header.
         * @member {Trd_Common.ITrdHeader} header
         * @memberof Trd_PlaceOrder.S2C
         * @instance
         */
        S2C.prototype.header = null;

        /**
         * S2C orderID.
         * @member {number|Long} orderID
         * @memberof Trd_PlaceOrder.S2C
         * @instance
         */
        S2C.prototype.orderID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Trd_PlaceOrder.S2C
         * @static
         * @param {Trd_PlaceOrder.IS2C=} [properties] Properties to set
         * @returns {Trd_PlaceOrder.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Trd_PlaceOrder.S2C.verify|verify} messages.
         * @function encode
         * @memberof Trd_PlaceOrder.S2C
         * @static
         * @param {Trd_PlaceOrder.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Trd_Common.TrdHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.orderID != null && message.hasOwnProperty("orderID"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.orderID);
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Trd_PlaceOrder.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_PlaceOrder.S2C
         * @static
         * @param {Trd_PlaceOrder.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_PlaceOrder.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_PlaceOrder.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_PlaceOrder.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.header = $root.Trd_Common.TrdHeader.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.orderID = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("header"))
                throw $util.ProtocolError("missing required 'header'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_PlaceOrder.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_PlaceOrder.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Trd_PlaceOrder.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Trd_Common.TrdHeader.verify(message.header);
                if (error)
                    return "header." + error;
            }
            if (message.orderID != null && message.hasOwnProperty("orderID"))
                if (!$util.isInteger(message.orderID) && !(message.orderID && $util.isInteger(message.orderID.low) && $util.isInteger(message.orderID.high)))
                    return "orderID: integer|Long expected";
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_PlaceOrder.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_PlaceOrder.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_PlaceOrder.S2C)
                return object;
            var message = new $root.Trd_PlaceOrder.S2C();
            if (object.header != null) {
                if (typeof object.header !== "object")
                    throw TypeError(".Trd_PlaceOrder.S2C.header: object expected");
                message.header = $root.Trd_Common.TrdHeader.fromObject(object.header);
            }
            if (object.orderID != null)
                if ($util.Long)
                    (message.orderID = $util.Long.fromValue(object.orderID)).unsigned = true;
                else if (typeof object.orderID === "string")
                    message.orderID = parseInt(object.orderID, 10);
                else if (typeof object.orderID === "number")
                    message.orderID = object.orderID;
                else if (typeof object.orderID === "object")
                    message.orderID = new $util.LongBits(object.orderID.low >>> 0, object.orderID.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_PlaceOrder.S2C
         * @static
         * @param {Trd_PlaceOrder.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.header = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.orderID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.orderID = options.longs === String ? "0" : 0;
            }
            if (message.header != null && message.hasOwnProperty("header"))
                object.header = $root.Trd_Common.TrdHeader.toObject(message.header, options);
            if (message.orderID != null && message.hasOwnProperty("orderID"))
                if (typeof message.orderID === "number")
                    object.orderID = options.longs === String ? String(message.orderID) : message.orderID;
                else
                    object.orderID = options.longs === String ? $util.Long.prototype.toString.call(message.orderID) : options.longs === Number ? new $util.LongBits(message.orderID.low >>> 0, message.orderID.high >>> 0).toNumber(true) : message.orderID;
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Trd_PlaceOrder.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Trd_PlaceOrder.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Trd_PlaceOrder
         * @interface IRequest
         * @property {Trd_PlaceOrder.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Trd_PlaceOrder
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Trd_PlaceOrder.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Trd_PlaceOrder.IC2S} c2s
         * @memberof Trd_PlaceOrder.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Trd_PlaceOrder.Request
         * @static
         * @param {Trd_PlaceOrder.IRequest=} [properties] Properties to set
         * @returns {Trd_PlaceOrder.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Trd_PlaceOrder.Request.verify|verify} messages.
         * @function encode
         * @memberof Trd_PlaceOrder.Request
         * @static
         * @param {Trd_PlaceOrder.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Trd_PlaceOrder.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Trd_PlaceOrder.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_PlaceOrder.Request
         * @static
         * @param {Trd_PlaceOrder.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_PlaceOrder.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_PlaceOrder.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_PlaceOrder.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Trd_PlaceOrder.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_PlaceOrder.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_PlaceOrder.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Trd_PlaceOrder.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Trd_PlaceOrder.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_PlaceOrder.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_PlaceOrder.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_PlaceOrder.Request)
                return object;
            var message = new $root.Trd_PlaceOrder.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Trd_PlaceOrder.Request.c2s: object expected");
                message.c2s = $root.Trd_PlaceOrder.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_PlaceOrder.Request
         * @static
         * @param {Trd_PlaceOrder.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Trd_PlaceOrder.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Trd_PlaceOrder.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Trd_PlaceOrder.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Trd_PlaceOrder
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Trd_PlaceOrder.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Trd_PlaceOrder
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Trd_PlaceOrder.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Trd_PlaceOrder.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Trd_PlaceOrder.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Trd_PlaceOrder.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Trd_PlaceOrder.IS2C|null|undefined} s2c
         * @memberof Trd_PlaceOrder.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Trd_PlaceOrder.Response
         * @static
         * @param {Trd_PlaceOrder.IResponse=} [properties] Properties to set
         * @returns {Trd_PlaceOrder.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Trd_PlaceOrder.Response.verify|verify} messages.
         * @function encode
         * @memberof Trd_PlaceOrder.Response
         * @static
         * @param {Trd_PlaceOrder.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Trd_PlaceOrder.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Trd_PlaceOrder.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_PlaceOrder.Response
         * @static
         * @param {Trd_PlaceOrder.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_PlaceOrder.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_PlaceOrder.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_PlaceOrder.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Trd_PlaceOrder.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_PlaceOrder.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_PlaceOrder.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Trd_PlaceOrder.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Trd_PlaceOrder.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_PlaceOrder.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_PlaceOrder.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_PlaceOrder.Response)
                return object;
            var message = new $root.Trd_PlaceOrder.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Trd_PlaceOrder.Response.s2c: object expected");
                message.s2c = $root.Trd_PlaceOrder.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_PlaceOrder.Response
         * @static
         * @param {Trd_PlaceOrder.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Trd_PlaceOrder.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Trd_PlaceOrder.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Trd_PlaceOrder;
})();

$root.Trd_ReconfirmOrder = (function() {

    /**
     * Namespace Trd_ReconfirmOrder.
     * @exports Trd_ReconfirmOrder
     * @namespace
     */
    var Trd_ReconfirmOrder = {};

    Trd_ReconfirmOrder.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Trd_ReconfirmOrder
         * @interface IC2S
         * @property {Common.IPacketID} packetID C2S packetID
         * @property {Trd_Common.ITrdHeader} header C2S header
         * @property {number|Long} orderID C2S orderID
         * @property {number} reconfirmReason C2S reconfirmReason
         */

        /**
         * Constructs a new C2S.
         * @memberof Trd_ReconfirmOrder
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Trd_ReconfirmOrder.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S packetID.
         * @member {Common.IPacketID} packetID
         * @memberof Trd_ReconfirmOrder.C2S
         * @instance
         */
        C2S.prototype.packetID = null;

        /**
         * C2S header.
         * @member {Trd_Common.ITrdHeader} header
         * @memberof Trd_ReconfirmOrder.C2S
         * @instance
         */
        C2S.prototype.header = null;

        /**
         * C2S orderID.
         * @member {number|Long} orderID
         * @memberof Trd_ReconfirmOrder.C2S
         * @instance
         */
        C2S.prototype.orderID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * C2S reconfirmReason.
         * @member {number} reconfirmReason
         * @memberof Trd_ReconfirmOrder.C2S
         * @instance
         */
        C2S.prototype.reconfirmReason = 0;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Trd_ReconfirmOrder.C2S
         * @static
         * @param {Trd_ReconfirmOrder.IC2S=} [properties] Properties to set
         * @returns {Trd_ReconfirmOrder.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Trd_ReconfirmOrder.C2S.verify|verify} messages.
         * @function encode
         * @memberof Trd_ReconfirmOrder.C2S
         * @static
         * @param {Trd_ReconfirmOrder.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Common.PacketID.encode(message.packetID, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            $root.Trd_Common.TrdHeader.encode(message.header, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.orderID);
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.reconfirmReason);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Trd_ReconfirmOrder.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_ReconfirmOrder.C2S
         * @static
         * @param {Trd_ReconfirmOrder.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_ReconfirmOrder.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_ReconfirmOrder.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_ReconfirmOrder.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.packetID = $root.Common.PacketID.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.header = $root.Trd_Common.TrdHeader.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.orderID = reader.uint64();
                    break;
                case 4:
                    message.reconfirmReason = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("packetID"))
                throw $util.ProtocolError("missing required 'packetID'", { instance: message });
            if (!message.hasOwnProperty("header"))
                throw $util.ProtocolError("missing required 'header'", { instance: message });
            if (!message.hasOwnProperty("orderID"))
                throw $util.ProtocolError("missing required 'orderID'", { instance: message });
            if (!message.hasOwnProperty("reconfirmReason"))
                throw $util.ProtocolError("missing required 'reconfirmReason'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_ReconfirmOrder.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_ReconfirmOrder.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Trd_ReconfirmOrder.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Common.PacketID.verify(message.packetID);
                if (error)
                    return "packetID." + error;
            }
            {
                var error = $root.Trd_Common.TrdHeader.verify(message.header);
                if (error)
                    return "header." + error;
            }
            if (!$util.isInteger(message.orderID) && !(message.orderID && $util.isInteger(message.orderID.low) && $util.isInteger(message.orderID.high)))
                return "orderID: integer|Long expected";
            if (!$util.isInteger(message.reconfirmReason))
                return "reconfirmReason: integer expected";
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_ReconfirmOrder.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_ReconfirmOrder.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_ReconfirmOrder.C2S)
                return object;
            var message = new $root.Trd_ReconfirmOrder.C2S();
            if (object.packetID != null) {
                if (typeof object.packetID !== "object")
                    throw TypeError(".Trd_ReconfirmOrder.C2S.packetID: object expected");
                message.packetID = $root.Common.PacketID.fromObject(object.packetID);
            }
            if (object.header != null) {
                if (typeof object.header !== "object")
                    throw TypeError(".Trd_ReconfirmOrder.C2S.header: object expected");
                message.header = $root.Trd_Common.TrdHeader.fromObject(object.header);
            }
            if (object.orderID != null)
                if ($util.Long)
                    (message.orderID = $util.Long.fromValue(object.orderID)).unsigned = true;
                else if (typeof object.orderID === "string")
                    message.orderID = parseInt(object.orderID, 10);
                else if (typeof object.orderID === "number")
                    message.orderID = object.orderID;
                else if (typeof object.orderID === "object")
                    message.orderID = new $util.LongBits(object.orderID.low >>> 0, object.orderID.high >>> 0).toNumber(true);
            if (object.reconfirmReason != null)
                message.reconfirmReason = object.reconfirmReason | 0;
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_ReconfirmOrder.C2S
         * @static
         * @param {Trd_ReconfirmOrder.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.packetID = null;
                object.header = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.orderID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.orderID = options.longs === String ? "0" : 0;
                object.reconfirmReason = 0;
            }
            if (message.packetID != null && message.hasOwnProperty("packetID"))
                object.packetID = $root.Common.PacketID.toObject(message.packetID, options);
            if (message.header != null && message.hasOwnProperty("header"))
                object.header = $root.Trd_Common.TrdHeader.toObject(message.header, options);
            if (message.orderID != null && message.hasOwnProperty("orderID"))
                if (typeof message.orderID === "number")
                    object.orderID = options.longs === String ? String(message.orderID) : message.orderID;
                else
                    object.orderID = options.longs === String ? $util.Long.prototype.toString.call(message.orderID) : options.longs === Number ? new $util.LongBits(message.orderID.low >>> 0, message.orderID.high >>> 0).toNumber(true) : message.orderID;
            if (message.reconfirmReason != null && message.hasOwnProperty("reconfirmReason"))
                object.reconfirmReason = message.reconfirmReason;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Trd_ReconfirmOrder.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Trd_ReconfirmOrder.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Trd_ReconfirmOrder
         * @interface IS2C
         * @property {Trd_Common.ITrdHeader} header S2C header
         * @property {number|Long} orderID S2C orderID
         */

        /**
         * Constructs a new S2C.
         * @memberof Trd_ReconfirmOrder
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Trd_ReconfirmOrder.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C header.
         * @member {Trd_Common.ITrdHeader} header
         * @memberof Trd_ReconfirmOrder.S2C
         * @instance
         */
        S2C.prototype.header = null;

        /**
         * S2C orderID.
         * @member {number|Long} orderID
         * @memberof Trd_ReconfirmOrder.S2C
         * @instance
         */
        S2C.prototype.orderID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Trd_ReconfirmOrder.S2C
         * @static
         * @param {Trd_ReconfirmOrder.IS2C=} [properties] Properties to set
         * @returns {Trd_ReconfirmOrder.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Trd_ReconfirmOrder.S2C.verify|verify} messages.
         * @function encode
         * @memberof Trd_ReconfirmOrder.S2C
         * @static
         * @param {Trd_ReconfirmOrder.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Trd_Common.TrdHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.orderID);
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Trd_ReconfirmOrder.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_ReconfirmOrder.S2C
         * @static
         * @param {Trd_ReconfirmOrder.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_ReconfirmOrder.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_ReconfirmOrder.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_ReconfirmOrder.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.header = $root.Trd_Common.TrdHeader.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.orderID = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("header"))
                throw $util.ProtocolError("missing required 'header'", { instance: message });
            if (!message.hasOwnProperty("orderID"))
                throw $util.ProtocolError("missing required 'orderID'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_ReconfirmOrder.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_ReconfirmOrder.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Trd_ReconfirmOrder.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Trd_Common.TrdHeader.verify(message.header);
                if (error)
                    return "header." + error;
            }
            if (!$util.isInteger(message.orderID) && !(message.orderID && $util.isInteger(message.orderID.low) && $util.isInteger(message.orderID.high)))
                return "orderID: integer|Long expected";
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_ReconfirmOrder.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_ReconfirmOrder.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_ReconfirmOrder.S2C)
                return object;
            var message = new $root.Trd_ReconfirmOrder.S2C();
            if (object.header != null) {
                if (typeof object.header !== "object")
                    throw TypeError(".Trd_ReconfirmOrder.S2C.header: object expected");
                message.header = $root.Trd_Common.TrdHeader.fromObject(object.header);
            }
            if (object.orderID != null)
                if ($util.Long)
                    (message.orderID = $util.Long.fromValue(object.orderID)).unsigned = true;
                else if (typeof object.orderID === "string")
                    message.orderID = parseInt(object.orderID, 10);
                else if (typeof object.orderID === "number")
                    message.orderID = object.orderID;
                else if (typeof object.orderID === "object")
                    message.orderID = new $util.LongBits(object.orderID.low >>> 0, object.orderID.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_ReconfirmOrder.S2C
         * @static
         * @param {Trd_ReconfirmOrder.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.header = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.orderID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.orderID = options.longs === String ? "0" : 0;
            }
            if (message.header != null && message.hasOwnProperty("header"))
                object.header = $root.Trd_Common.TrdHeader.toObject(message.header, options);
            if (message.orderID != null && message.hasOwnProperty("orderID"))
                if (typeof message.orderID === "number")
                    object.orderID = options.longs === String ? String(message.orderID) : message.orderID;
                else
                    object.orderID = options.longs === String ? $util.Long.prototype.toString.call(message.orderID) : options.longs === Number ? new $util.LongBits(message.orderID.low >>> 0, message.orderID.high >>> 0).toNumber(true) : message.orderID;
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Trd_ReconfirmOrder.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Trd_ReconfirmOrder.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Trd_ReconfirmOrder
         * @interface IRequest
         * @property {Trd_ReconfirmOrder.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Trd_ReconfirmOrder
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Trd_ReconfirmOrder.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Trd_ReconfirmOrder.IC2S} c2s
         * @memberof Trd_ReconfirmOrder.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Trd_ReconfirmOrder.Request
         * @static
         * @param {Trd_ReconfirmOrder.IRequest=} [properties] Properties to set
         * @returns {Trd_ReconfirmOrder.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Trd_ReconfirmOrder.Request.verify|verify} messages.
         * @function encode
         * @memberof Trd_ReconfirmOrder.Request
         * @static
         * @param {Trd_ReconfirmOrder.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Trd_ReconfirmOrder.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Trd_ReconfirmOrder.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_ReconfirmOrder.Request
         * @static
         * @param {Trd_ReconfirmOrder.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_ReconfirmOrder.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_ReconfirmOrder.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_ReconfirmOrder.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Trd_ReconfirmOrder.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_ReconfirmOrder.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_ReconfirmOrder.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Trd_ReconfirmOrder.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Trd_ReconfirmOrder.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_ReconfirmOrder.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_ReconfirmOrder.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_ReconfirmOrder.Request)
                return object;
            var message = new $root.Trd_ReconfirmOrder.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Trd_ReconfirmOrder.Request.c2s: object expected");
                message.c2s = $root.Trd_ReconfirmOrder.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_ReconfirmOrder.Request
         * @static
         * @param {Trd_ReconfirmOrder.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Trd_ReconfirmOrder.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Trd_ReconfirmOrder.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Trd_ReconfirmOrder.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Trd_ReconfirmOrder
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Trd_ReconfirmOrder.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Trd_ReconfirmOrder
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Trd_ReconfirmOrder.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Trd_ReconfirmOrder.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Trd_ReconfirmOrder.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Trd_ReconfirmOrder.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Trd_ReconfirmOrder.IS2C|null|undefined} s2c
         * @memberof Trd_ReconfirmOrder.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Trd_ReconfirmOrder.Response
         * @static
         * @param {Trd_ReconfirmOrder.IResponse=} [properties] Properties to set
         * @returns {Trd_ReconfirmOrder.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Trd_ReconfirmOrder.Response.verify|verify} messages.
         * @function encode
         * @memberof Trd_ReconfirmOrder.Response
         * @static
         * @param {Trd_ReconfirmOrder.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Trd_ReconfirmOrder.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Trd_ReconfirmOrder.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_ReconfirmOrder.Response
         * @static
         * @param {Trd_ReconfirmOrder.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_ReconfirmOrder.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_ReconfirmOrder.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_ReconfirmOrder.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Trd_ReconfirmOrder.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_ReconfirmOrder.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_ReconfirmOrder.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Trd_ReconfirmOrder.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Trd_ReconfirmOrder.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_ReconfirmOrder.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_ReconfirmOrder.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_ReconfirmOrder.Response)
                return object;
            var message = new $root.Trd_ReconfirmOrder.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Trd_ReconfirmOrder.Response.s2c: object expected");
                message.s2c = $root.Trd_ReconfirmOrder.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_ReconfirmOrder.Response
         * @static
         * @param {Trd_ReconfirmOrder.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Trd_ReconfirmOrder.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Trd_ReconfirmOrder.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Trd_ReconfirmOrder;
})();

$root.Trd_SubAccPush = (function() {

    /**
     * Namespace Trd_SubAccPush.
     * @exports Trd_SubAccPush
     * @namespace
     */
    var Trd_SubAccPush = {};

    Trd_SubAccPush.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Trd_SubAccPush
         * @interface IC2S
         * @property {Array.<number|Long>|null} [accIDList] C2S accIDList
         */

        /**
         * Constructs a new C2S.
         * @memberof Trd_SubAccPush
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Trd_SubAccPush.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            this.accIDList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S accIDList.
         * @member {Array.<number|Long>} accIDList
         * @memberof Trd_SubAccPush.C2S
         * @instance
         */
        C2S.prototype.accIDList = $util.emptyArray;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Trd_SubAccPush.C2S
         * @static
         * @param {Trd_SubAccPush.IC2S=} [properties] Properties to set
         * @returns {Trd_SubAccPush.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Trd_SubAccPush.C2S.verify|verify} messages.
         * @function encode
         * @memberof Trd_SubAccPush.C2S
         * @static
         * @param {Trd_SubAccPush.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.accIDList != null && message.accIDList.length)
                for (var i = 0; i < message.accIDList.length; ++i)
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.accIDList[i]);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Trd_SubAccPush.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_SubAccPush.C2S
         * @static
         * @param {Trd_SubAccPush.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_SubAccPush.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_SubAccPush.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_SubAccPush.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.accIDList && message.accIDList.length))
                        message.accIDList = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.accIDList.push(reader.uint64());
                    } else
                        message.accIDList.push(reader.uint64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_SubAccPush.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_SubAccPush.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Trd_SubAccPush.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.accIDList != null && message.hasOwnProperty("accIDList")) {
                if (!Array.isArray(message.accIDList))
                    return "accIDList: array expected";
                for (var i = 0; i < message.accIDList.length; ++i)
                    if (!$util.isInteger(message.accIDList[i]) && !(message.accIDList[i] && $util.isInteger(message.accIDList[i].low) && $util.isInteger(message.accIDList[i].high)))
                        return "accIDList: integer|Long[] expected";
            }
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_SubAccPush.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_SubAccPush.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_SubAccPush.C2S)
                return object;
            var message = new $root.Trd_SubAccPush.C2S();
            if (object.accIDList) {
                if (!Array.isArray(object.accIDList))
                    throw TypeError(".Trd_SubAccPush.C2S.accIDList: array expected");
                message.accIDList = [];
                for (var i = 0; i < object.accIDList.length; ++i)
                    if ($util.Long)
                        (message.accIDList[i] = $util.Long.fromValue(object.accIDList[i])).unsigned = true;
                    else if (typeof object.accIDList[i] === "string")
                        message.accIDList[i] = parseInt(object.accIDList[i], 10);
                    else if (typeof object.accIDList[i] === "number")
                        message.accIDList[i] = object.accIDList[i];
                    else if (typeof object.accIDList[i] === "object")
                        message.accIDList[i] = new $util.LongBits(object.accIDList[i].low >>> 0, object.accIDList[i].high >>> 0).toNumber(true);
            }
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_SubAccPush.C2S
         * @static
         * @param {Trd_SubAccPush.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.accIDList = [];
            if (message.accIDList && message.accIDList.length) {
                object.accIDList = [];
                for (var j = 0; j < message.accIDList.length; ++j)
                    if (typeof message.accIDList[j] === "number")
                        object.accIDList[j] = options.longs === String ? String(message.accIDList[j]) : message.accIDList[j];
                    else
                        object.accIDList[j] = options.longs === String ? $util.Long.prototype.toString.call(message.accIDList[j]) : options.longs === Number ? new $util.LongBits(message.accIDList[j].low >>> 0, message.accIDList[j].high >>> 0).toNumber(true) : message.accIDList[j];
            }
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Trd_SubAccPush.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Trd_SubAccPush.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Trd_SubAccPush
         * @interface IS2C
         */

        /**
         * Constructs a new S2C.
         * @memberof Trd_SubAccPush
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Trd_SubAccPush.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Trd_SubAccPush.S2C
         * @static
         * @param {Trd_SubAccPush.IS2C=} [properties] Properties to set
         * @returns {Trd_SubAccPush.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Trd_SubAccPush.S2C.verify|verify} messages.
         * @function encode
         * @memberof Trd_SubAccPush.S2C
         * @static
         * @param {Trd_SubAccPush.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Trd_SubAccPush.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_SubAccPush.S2C
         * @static
         * @param {Trd_SubAccPush.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_SubAccPush.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_SubAccPush.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_SubAccPush.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_SubAccPush.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_SubAccPush.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Trd_SubAccPush.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_SubAccPush.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_SubAccPush.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_SubAccPush.S2C)
                return object;
            return new $root.Trd_SubAccPush.S2C();
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_SubAccPush.S2C
         * @static
         * @param {Trd_SubAccPush.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Trd_SubAccPush.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Trd_SubAccPush.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Trd_SubAccPush
         * @interface IRequest
         * @property {Trd_SubAccPush.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Trd_SubAccPush
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Trd_SubAccPush.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Trd_SubAccPush.IC2S} c2s
         * @memberof Trd_SubAccPush.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Trd_SubAccPush.Request
         * @static
         * @param {Trd_SubAccPush.IRequest=} [properties] Properties to set
         * @returns {Trd_SubAccPush.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Trd_SubAccPush.Request.verify|verify} messages.
         * @function encode
         * @memberof Trd_SubAccPush.Request
         * @static
         * @param {Trd_SubAccPush.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Trd_SubAccPush.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Trd_SubAccPush.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_SubAccPush.Request
         * @static
         * @param {Trd_SubAccPush.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_SubAccPush.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_SubAccPush.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_SubAccPush.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Trd_SubAccPush.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_SubAccPush.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_SubAccPush.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Trd_SubAccPush.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Trd_SubAccPush.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_SubAccPush.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_SubAccPush.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_SubAccPush.Request)
                return object;
            var message = new $root.Trd_SubAccPush.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Trd_SubAccPush.Request.c2s: object expected");
                message.c2s = $root.Trd_SubAccPush.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_SubAccPush.Request
         * @static
         * @param {Trd_SubAccPush.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Trd_SubAccPush.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Trd_SubAccPush.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Trd_SubAccPush.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Trd_SubAccPush
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Trd_SubAccPush.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Trd_SubAccPush
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Trd_SubAccPush.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Trd_SubAccPush.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Trd_SubAccPush.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Trd_SubAccPush.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Trd_SubAccPush.IS2C|null|undefined} s2c
         * @memberof Trd_SubAccPush.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Trd_SubAccPush.Response
         * @static
         * @param {Trd_SubAccPush.IResponse=} [properties] Properties to set
         * @returns {Trd_SubAccPush.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Trd_SubAccPush.Response.verify|verify} messages.
         * @function encode
         * @memberof Trd_SubAccPush.Response
         * @static
         * @param {Trd_SubAccPush.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Trd_SubAccPush.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Trd_SubAccPush.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_SubAccPush.Response
         * @static
         * @param {Trd_SubAccPush.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_SubAccPush.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_SubAccPush.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_SubAccPush.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Trd_SubAccPush.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_SubAccPush.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_SubAccPush.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Trd_SubAccPush.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Trd_SubAccPush.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_SubAccPush.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_SubAccPush.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_SubAccPush.Response)
                return object;
            var message = new $root.Trd_SubAccPush.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Trd_SubAccPush.Response.s2c: object expected");
                message.s2c = $root.Trd_SubAccPush.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_SubAccPush.Response
         * @static
         * @param {Trd_SubAccPush.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Trd_SubAccPush.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Trd_SubAccPush.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Trd_SubAccPush;
})();

$root.Trd_UnlockTrade = (function() {

    /**
     * Namespace Trd_UnlockTrade.
     * @exports Trd_UnlockTrade
     * @namespace
     */
    var Trd_UnlockTrade = {};

    Trd_UnlockTrade.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Trd_UnlockTrade
         * @interface IC2S
         * @property {boolean} unlock C2S unlock
         * @property {string|null} [pwdMD5] C2S pwdMD5
         */

        /**
         * Constructs a new C2S.
         * @memberof Trd_UnlockTrade
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Trd_UnlockTrade.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S unlock.
         * @member {boolean} unlock
         * @memberof Trd_UnlockTrade.C2S
         * @instance
         */
        C2S.prototype.unlock = false;

        /**
         * C2S pwdMD5.
         * @member {string} pwdMD5
         * @memberof Trd_UnlockTrade.C2S
         * @instance
         */
        C2S.prototype.pwdMD5 = "";

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Trd_UnlockTrade.C2S
         * @static
         * @param {Trd_UnlockTrade.IC2S=} [properties] Properties to set
         * @returns {Trd_UnlockTrade.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Trd_UnlockTrade.C2S.verify|verify} messages.
         * @function encode
         * @memberof Trd_UnlockTrade.C2S
         * @static
         * @param {Trd_UnlockTrade.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).bool(message.unlock);
            if (message.pwdMD5 != null && message.hasOwnProperty("pwdMD5"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.pwdMD5);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Trd_UnlockTrade.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_UnlockTrade.C2S
         * @static
         * @param {Trd_UnlockTrade.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_UnlockTrade.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_UnlockTrade.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_UnlockTrade.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.unlock = reader.bool();
                    break;
                case 2:
                    message.pwdMD5 = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("unlock"))
                throw $util.ProtocolError("missing required 'unlock'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_UnlockTrade.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_UnlockTrade.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Trd_UnlockTrade.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (typeof message.unlock !== "boolean")
                return "unlock: boolean expected";
            if (message.pwdMD5 != null && message.hasOwnProperty("pwdMD5"))
                if (!$util.isString(message.pwdMD5))
                    return "pwdMD5: string expected";
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_UnlockTrade.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_UnlockTrade.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_UnlockTrade.C2S)
                return object;
            var message = new $root.Trd_UnlockTrade.C2S();
            if (object.unlock != null)
                message.unlock = Boolean(object.unlock);
            if (object.pwdMD5 != null)
                message.pwdMD5 = String(object.pwdMD5);
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_UnlockTrade.C2S
         * @static
         * @param {Trd_UnlockTrade.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.unlock = false;
                object.pwdMD5 = "";
            }
            if (message.unlock != null && message.hasOwnProperty("unlock"))
                object.unlock = message.unlock;
            if (message.pwdMD5 != null && message.hasOwnProperty("pwdMD5"))
                object.pwdMD5 = message.pwdMD5;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Trd_UnlockTrade.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Trd_UnlockTrade.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Trd_UnlockTrade
         * @interface IS2C
         */

        /**
         * Constructs a new S2C.
         * @memberof Trd_UnlockTrade
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Trd_UnlockTrade.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Trd_UnlockTrade.S2C
         * @static
         * @param {Trd_UnlockTrade.IS2C=} [properties] Properties to set
         * @returns {Trd_UnlockTrade.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Trd_UnlockTrade.S2C.verify|verify} messages.
         * @function encode
         * @memberof Trd_UnlockTrade.S2C
         * @static
         * @param {Trd_UnlockTrade.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Trd_UnlockTrade.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_UnlockTrade.S2C
         * @static
         * @param {Trd_UnlockTrade.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_UnlockTrade.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_UnlockTrade.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_UnlockTrade.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_UnlockTrade.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_UnlockTrade.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Trd_UnlockTrade.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_UnlockTrade.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_UnlockTrade.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_UnlockTrade.S2C)
                return object;
            return new $root.Trd_UnlockTrade.S2C();
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_UnlockTrade.S2C
         * @static
         * @param {Trd_UnlockTrade.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Trd_UnlockTrade.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Trd_UnlockTrade.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Trd_UnlockTrade
         * @interface IRequest
         * @property {Trd_UnlockTrade.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Trd_UnlockTrade
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Trd_UnlockTrade.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Trd_UnlockTrade.IC2S} c2s
         * @memberof Trd_UnlockTrade.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Trd_UnlockTrade.Request
         * @static
         * @param {Trd_UnlockTrade.IRequest=} [properties] Properties to set
         * @returns {Trd_UnlockTrade.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Trd_UnlockTrade.Request.verify|verify} messages.
         * @function encode
         * @memberof Trd_UnlockTrade.Request
         * @static
         * @param {Trd_UnlockTrade.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Trd_UnlockTrade.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Trd_UnlockTrade.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_UnlockTrade.Request
         * @static
         * @param {Trd_UnlockTrade.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_UnlockTrade.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_UnlockTrade.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_UnlockTrade.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Trd_UnlockTrade.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_UnlockTrade.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_UnlockTrade.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Trd_UnlockTrade.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Trd_UnlockTrade.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_UnlockTrade.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_UnlockTrade.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_UnlockTrade.Request)
                return object;
            var message = new $root.Trd_UnlockTrade.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Trd_UnlockTrade.Request.c2s: object expected");
                message.c2s = $root.Trd_UnlockTrade.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_UnlockTrade.Request
         * @static
         * @param {Trd_UnlockTrade.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Trd_UnlockTrade.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Trd_UnlockTrade.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Trd_UnlockTrade.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Trd_UnlockTrade
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Trd_UnlockTrade.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Trd_UnlockTrade
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Trd_UnlockTrade.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Trd_UnlockTrade.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Trd_UnlockTrade.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Trd_UnlockTrade.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Trd_UnlockTrade.IS2C|null|undefined} s2c
         * @memberof Trd_UnlockTrade.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Trd_UnlockTrade.Response
         * @static
         * @param {Trd_UnlockTrade.IResponse=} [properties] Properties to set
         * @returns {Trd_UnlockTrade.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Trd_UnlockTrade.Response.verify|verify} messages.
         * @function encode
         * @memberof Trd_UnlockTrade.Response
         * @static
         * @param {Trd_UnlockTrade.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Trd_UnlockTrade.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Trd_UnlockTrade.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_UnlockTrade.Response
         * @static
         * @param {Trd_UnlockTrade.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_UnlockTrade.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_UnlockTrade.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_UnlockTrade.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Trd_UnlockTrade.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_UnlockTrade.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_UnlockTrade.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Trd_UnlockTrade.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Trd_UnlockTrade.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_UnlockTrade.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_UnlockTrade.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_UnlockTrade.Response)
                return object;
            var message = new $root.Trd_UnlockTrade.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Trd_UnlockTrade.Response.s2c: object expected");
                message.s2c = $root.Trd_UnlockTrade.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_UnlockTrade.Response
         * @static
         * @param {Trd_UnlockTrade.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Trd_UnlockTrade.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Trd_UnlockTrade.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Trd_UnlockTrade;
})();

$root.Trd_UpdateOrder = (function() {

    /**
     * Namespace Trd_UpdateOrder.
     * @exports Trd_UpdateOrder
     * @namespace
     */
    var Trd_UpdateOrder = {};

    Trd_UpdateOrder.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Trd_UpdateOrder
         * @interface IS2C
         * @property {Trd_Common.ITrdHeader} header S2C header
         * @property {Trd_Common.IOrder} order S2C order
         */

        /**
         * Constructs a new S2C.
         * @memberof Trd_UpdateOrder
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Trd_UpdateOrder.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C header.
         * @member {Trd_Common.ITrdHeader} header
         * @memberof Trd_UpdateOrder.S2C
         * @instance
         */
        S2C.prototype.header = null;

        /**
         * S2C order.
         * @member {Trd_Common.IOrder} order
         * @memberof Trd_UpdateOrder.S2C
         * @instance
         */
        S2C.prototype.order = null;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Trd_UpdateOrder.S2C
         * @static
         * @param {Trd_UpdateOrder.IS2C=} [properties] Properties to set
         * @returns {Trd_UpdateOrder.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Trd_UpdateOrder.S2C.verify|verify} messages.
         * @function encode
         * @memberof Trd_UpdateOrder.S2C
         * @static
         * @param {Trd_UpdateOrder.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Trd_Common.TrdHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            $root.Trd_Common.Order.encode(message.order, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Trd_UpdateOrder.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_UpdateOrder.S2C
         * @static
         * @param {Trd_UpdateOrder.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_UpdateOrder.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_UpdateOrder.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_UpdateOrder.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.header = $root.Trd_Common.TrdHeader.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.order = $root.Trd_Common.Order.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("header"))
                throw $util.ProtocolError("missing required 'header'", { instance: message });
            if (!message.hasOwnProperty("order"))
                throw $util.ProtocolError("missing required 'order'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_UpdateOrder.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_UpdateOrder.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Trd_UpdateOrder.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Trd_Common.TrdHeader.verify(message.header);
                if (error)
                    return "header." + error;
            }
            {
                var error = $root.Trd_Common.Order.verify(message.order);
                if (error)
                    return "order." + error;
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_UpdateOrder.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_UpdateOrder.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_UpdateOrder.S2C)
                return object;
            var message = new $root.Trd_UpdateOrder.S2C();
            if (object.header != null) {
                if (typeof object.header !== "object")
                    throw TypeError(".Trd_UpdateOrder.S2C.header: object expected");
                message.header = $root.Trd_Common.TrdHeader.fromObject(object.header);
            }
            if (object.order != null) {
                if (typeof object.order !== "object")
                    throw TypeError(".Trd_UpdateOrder.S2C.order: object expected");
                message.order = $root.Trd_Common.Order.fromObject(object.order);
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_UpdateOrder.S2C
         * @static
         * @param {Trd_UpdateOrder.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.header = null;
                object.order = null;
            }
            if (message.header != null && message.hasOwnProperty("header"))
                object.header = $root.Trd_Common.TrdHeader.toObject(message.header, options);
            if (message.order != null && message.hasOwnProperty("order"))
                object.order = $root.Trd_Common.Order.toObject(message.order, options);
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Trd_UpdateOrder.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Trd_UpdateOrder.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Trd_UpdateOrder
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Trd_UpdateOrder.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Trd_UpdateOrder
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Trd_UpdateOrder.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Trd_UpdateOrder.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Trd_UpdateOrder.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Trd_UpdateOrder.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Trd_UpdateOrder.IS2C|null|undefined} s2c
         * @memberof Trd_UpdateOrder.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Trd_UpdateOrder.Response
         * @static
         * @param {Trd_UpdateOrder.IResponse=} [properties] Properties to set
         * @returns {Trd_UpdateOrder.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Trd_UpdateOrder.Response.verify|verify} messages.
         * @function encode
         * @memberof Trd_UpdateOrder.Response
         * @static
         * @param {Trd_UpdateOrder.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Trd_UpdateOrder.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Trd_UpdateOrder.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_UpdateOrder.Response
         * @static
         * @param {Trd_UpdateOrder.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_UpdateOrder.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_UpdateOrder.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_UpdateOrder.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Trd_UpdateOrder.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_UpdateOrder.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_UpdateOrder.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Trd_UpdateOrder.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Trd_UpdateOrder.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_UpdateOrder.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_UpdateOrder.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_UpdateOrder.Response)
                return object;
            var message = new $root.Trd_UpdateOrder.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Trd_UpdateOrder.Response.s2c: object expected");
                message.s2c = $root.Trd_UpdateOrder.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_UpdateOrder.Response
         * @static
         * @param {Trd_UpdateOrder.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Trd_UpdateOrder.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Trd_UpdateOrder.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Trd_UpdateOrder;
})();

$root.Trd_UpdateOrderFill = (function() {

    /**
     * Namespace Trd_UpdateOrderFill.
     * @exports Trd_UpdateOrderFill
     * @namespace
     */
    var Trd_UpdateOrderFill = {};

    Trd_UpdateOrderFill.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Trd_UpdateOrderFill
         * @interface IS2C
         * @property {Trd_Common.ITrdHeader} header S2C header
         * @property {Trd_Common.IOrderFill} orderFill S2C orderFill
         */

        /**
         * Constructs a new S2C.
         * @memberof Trd_UpdateOrderFill
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Trd_UpdateOrderFill.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * S2C header.
         * @member {Trd_Common.ITrdHeader} header
         * @memberof Trd_UpdateOrderFill.S2C
         * @instance
         */
        S2C.prototype.header = null;

        /**
         * S2C orderFill.
         * @member {Trd_Common.IOrderFill} orderFill
         * @memberof Trd_UpdateOrderFill.S2C
         * @instance
         */
        S2C.prototype.orderFill = null;

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Trd_UpdateOrderFill.S2C
         * @static
         * @param {Trd_UpdateOrderFill.IS2C=} [properties] Properties to set
         * @returns {Trd_UpdateOrderFill.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Trd_UpdateOrderFill.S2C.verify|verify} messages.
         * @function encode
         * @memberof Trd_UpdateOrderFill.S2C
         * @static
         * @param {Trd_UpdateOrderFill.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Trd_Common.TrdHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            $root.Trd_Common.OrderFill.encode(message.orderFill, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Trd_UpdateOrderFill.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_UpdateOrderFill.S2C
         * @static
         * @param {Trd_UpdateOrderFill.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_UpdateOrderFill.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_UpdateOrderFill.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_UpdateOrderFill.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.header = $root.Trd_Common.TrdHeader.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.orderFill = $root.Trd_Common.OrderFill.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("header"))
                throw $util.ProtocolError("missing required 'header'", { instance: message });
            if (!message.hasOwnProperty("orderFill"))
                throw $util.ProtocolError("missing required 'orderFill'", { instance: message });
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_UpdateOrderFill.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_UpdateOrderFill.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Trd_UpdateOrderFill.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Trd_Common.TrdHeader.verify(message.header);
                if (error)
                    return "header." + error;
            }
            {
                var error = $root.Trd_Common.OrderFill.verify(message.orderFill);
                if (error)
                    return "orderFill." + error;
            }
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_UpdateOrderFill.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_UpdateOrderFill.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_UpdateOrderFill.S2C)
                return object;
            var message = new $root.Trd_UpdateOrderFill.S2C();
            if (object.header != null) {
                if (typeof object.header !== "object")
                    throw TypeError(".Trd_UpdateOrderFill.S2C.header: object expected");
                message.header = $root.Trd_Common.TrdHeader.fromObject(object.header);
            }
            if (object.orderFill != null) {
                if (typeof object.orderFill !== "object")
                    throw TypeError(".Trd_UpdateOrderFill.S2C.orderFill: object expected");
                message.orderFill = $root.Trd_Common.OrderFill.fromObject(object.orderFill);
            }
            return message;
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_UpdateOrderFill.S2C
         * @static
         * @param {Trd_UpdateOrderFill.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.header = null;
                object.orderFill = null;
            }
            if (message.header != null && message.hasOwnProperty("header"))
                object.header = $root.Trd_Common.TrdHeader.toObject(message.header, options);
            if (message.orderFill != null && message.hasOwnProperty("orderFill"))
                object.orderFill = $root.Trd_Common.OrderFill.toObject(message.orderFill, options);
            return object;
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Trd_UpdateOrderFill.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Trd_UpdateOrderFill.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Trd_UpdateOrderFill
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Trd_UpdateOrderFill.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Trd_UpdateOrderFill
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Trd_UpdateOrderFill.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Trd_UpdateOrderFill.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Trd_UpdateOrderFill.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Trd_UpdateOrderFill.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Trd_UpdateOrderFill.IS2C|null|undefined} s2c
         * @memberof Trd_UpdateOrderFill.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Trd_UpdateOrderFill.Response
         * @static
         * @param {Trd_UpdateOrderFill.IResponse=} [properties] Properties to set
         * @returns {Trd_UpdateOrderFill.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Trd_UpdateOrderFill.Response.verify|verify} messages.
         * @function encode
         * @memberof Trd_UpdateOrderFill.Response
         * @static
         * @param {Trd_UpdateOrderFill.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Trd_UpdateOrderFill.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Trd_UpdateOrderFill.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Trd_UpdateOrderFill.Response
         * @static
         * @param {Trd_UpdateOrderFill.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Trd_UpdateOrderFill.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Trd_UpdateOrderFill.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trd_UpdateOrderFill.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Trd_UpdateOrderFill.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Trd_UpdateOrderFill.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Trd_UpdateOrderFill.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Trd_UpdateOrderFill.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Trd_UpdateOrderFill.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Trd_UpdateOrderFill.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Trd_UpdateOrderFill.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Trd_UpdateOrderFill.Response)
                return object;
            var message = new $root.Trd_UpdateOrderFill.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Trd_UpdateOrderFill.Response.s2c: object expected");
                message.s2c = $root.Trd_UpdateOrderFill.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Trd_UpdateOrderFill.Response
         * @static
         * @param {Trd_UpdateOrderFill.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Trd_UpdateOrderFill.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Trd_UpdateOrderFill.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Trd_UpdateOrderFill;
})();

$root.Verification = (function() {

    /**
     * Namespace Verification.
     * @exports Verification
     * @namespace
     */
    var Verification = {};

    /**
     * VerificationType enum.
     * @name Verification.VerificationType
     * @enum {string}
     * @property {number} VerificationType_Unknow=0 VerificationType_Unknow value
     * @property {number} VerificationType_Picture=1 VerificationType_Picture value
     * @property {number} VerificationType_Phone=2 VerificationType_Phone value
     */
    Verification.VerificationType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "VerificationType_Unknow"] = 0;
        values[valuesById[1] = "VerificationType_Picture"] = 1;
        values[valuesById[2] = "VerificationType_Phone"] = 2;
        return values;
    })();

    /**
     * VerificationOp enum.
     * @name Verification.VerificationOp
     * @enum {string}
     * @property {number} VerificationOp_Unknow=0 VerificationOp_Unknow value
     * @property {number} VerificationOp_Request=1 VerificationOp_Request value
     * @property {number} VerificationOp_InputAndLogin=2 VerificationOp_InputAndLogin value
     */
    Verification.VerificationOp = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "VerificationOp_Unknow"] = 0;
        values[valuesById[1] = "VerificationOp_Request"] = 1;
        values[valuesById[2] = "VerificationOp_InputAndLogin"] = 2;
        return values;
    })();

    Verification.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof Verification
         * @interface IC2S
         * @property {number} type C2S type
         * @property {number} op C2S op
         * @property {string|null} [code] C2S code
         */

        /**
         * Constructs a new C2S.
         * @memberof Verification
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {Verification.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S type.
         * @member {number} type
         * @memberof Verification.C2S
         * @instance
         */
        C2S.prototype.type = 0;

        /**
         * C2S op.
         * @member {number} op
         * @memberof Verification.C2S
         * @instance
         */
        C2S.prototype.op = 0;

        /**
         * C2S code.
         * @member {string} code
         * @memberof Verification.C2S
         * @instance
         */
        C2S.prototype.code = "";

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof Verification.C2S
         * @static
         * @param {Verification.IC2S=} [properties] Properties to set
         * @returns {Verification.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link Verification.C2S.verify|verify} messages.
         * @function encode
         * @memberof Verification.C2S
         * @static
         * @param {Verification.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.op);
            if (message.code != null && message.hasOwnProperty("code"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.code);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link Verification.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Verification.C2S
         * @static
         * @param {Verification.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof Verification.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Verification.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Verification.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.op = reader.int32();
                    break;
                case 3:
                    message.code = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("type"))
                throw $util.ProtocolError("missing required 'type'", { instance: message });
            if (!message.hasOwnProperty("op"))
                throw $util.ProtocolError("missing required 'op'", { instance: message });
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Verification.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Verification.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof Verification.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.type))
                return "type: integer expected";
            if (!$util.isInteger(message.op))
                return "op: integer expected";
            if (message.code != null && message.hasOwnProperty("code"))
                if (!$util.isString(message.code))
                    return "code: string expected";
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Verification.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Verification.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.Verification.C2S)
                return object;
            var message = new $root.Verification.C2S();
            if (object.type != null)
                message.type = object.type | 0;
            if (object.op != null)
                message.op = object.op | 0;
            if (object.code != null)
                message.code = String(object.code);
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Verification.C2S
         * @static
         * @param {Verification.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = 0;
                object.op = 0;
                object.code = "";
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.op != null && message.hasOwnProperty("op"))
                object.op = message.op;
            if (message.code != null && message.hasOwnProperty("code"))
                object.code = message.code;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof Verification.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2S;
    })();

    Verification.S2C = (function() {

        /**
         * Properties of a S2C.
         * @memberof Verification
         * @interface IS2C
         */

        /**
         * Constructs a new S2C.
         * @memberof Verification
         * @classdesc Represents a S2C.
         * @implements IS2C
         * @constructor
         * @param {Verification.IS2C=} [properties] Properties to set
         */
        function S2C(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new S2C instance using the specified properties.
         * @function create
         * @memberof Verification.S2C
         * @static
         * @param {Verification.IS2C=} [properties] Properties to set
         * @returns {Verification.S2C} S2C instance
         */
        S2C.create = function create(properties) {
            return new S2C(properties);
        };

        /**
         * Encodes the specified S2C message. Does not implicitly {@link Verification.S2C.verify|verify} messages.
         * @function encode
         * @memberof Verification.S2C
         * @static
         * @param {Verification.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified S2C message, length delimited. Does not implicitly {@link Verification.S2C.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Verification.S2C
         * @static
         * @param {Verification.IS2C} message S2C message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        S2C.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a S2C message from the specified reader or buffer.
         * @function decode
         * @memberof Verification.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Verification.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Verification.S2C();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a S2C message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Verification.S2C
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Verification.S2C} S2C
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        S2C.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a S2C message.
         * @function verify
         * @memberof Verification.S2C
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        S2C.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a S2C message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Verification.S2C
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Verification.S2C} S2C
         */
        S2C.fromObject = function fromObject(object) {
            if (object instanceof $root.Verification.S2C)
                return object;
            return new $root.Verification.S2C();
        };

        /**
         * Creates a plain object from a S2C message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Verification.S2C
         * @static
         * @param {Verification.S2C} message S2C
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        S2C.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this S2C to JSON.
         * @function toJSON
         * @memberof Verification.S2C
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        S2C.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return S2C;
    })();

    Verification.Request = (function() {

        /**
         * Properties of a Request.
         * @memberof Verification
         * @interface IRequest
         * @property {Verification.IC2S} c2s Request c2s
         */

        /**
         * Constructs a new Request.
         * @memberof Verification
         * @classdesc Represents a Request.
         * @implements IRequest
         * @constructor
         * @param {Verification.IRequest=} [properties] Properties to set
         */
        function Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Request c2s.
         * @member {Verification.IC2S} c2s
         * @memberof Verification.Request
         * @instance
         */
        Request.prototype.c2s = null;

        /**
         * Creates a new Request instance using the specified properties.
         * @function create
         * @memberof Verification.Request
         * @static
         * @param {Verification.IRequest=} [properties] Properties to set
         * @returns {Verification.Request} Request instance
         */
        Request.create = function create(properties) {
            return new Request(properties);
        };

        /**
         * Encodes the specified Request message. Does not implicitly {@link Verification.Request.verify|verify} messages.
         * @function encode
         * @memberof Verification.Request
         * @static
         * @param {Verification.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Verification.C2S.encode(message.c2s, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Request message, length delimited. Does not implicitly {@link Verification.Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Verification.Request
         * @static
         * @param {Verification.IRequest} message Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Request message from the specified reader or buffer.
         * @function decode
         * @memberof Verification.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Verification.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Verification.Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.c2s = $root.Verification.C2S.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("c2s"))
                throw $util.ProtocolError("missing required 'c2s'", { instance: message });
            return message;
        };

        /**
         * Decodes a Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Verification.Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Verification.Request} Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Request message.
         * @function verify
         * @memberof Verification.Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Verification.C2S.verify(message.c2s);
                if (error)
                    return "c2s." + error;
            }
            return null;
        };

        /**
         * Creates a Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Verification.Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Verification.Request} Request
         */
        Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Verification.Request)
                return object;
            var message = new $root.Verification.Request();
            if (object.c2s != null) {
                if (typeof object.c2s !== "object")
                    throw TypeError(".Verification.Request.c2s: object expected");
                message.c2s = $root.Verification.C2S.fromObject(object.c2s);
            }
            return message;
        };

        /**
         * Creates a plain object from a Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Verification.Request
         * @static
         * @param {Verification.Request} message Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.c2s = null;
            if (message.c2s != null && message.hasOwnProperty("c2s"))
                object.c2s = $root.Verification.C2S.toObject(message.c2s, options);
            return object;
        };

        /**
         * Converts this Request to JSON.
         * @function toJSON
         * @memberof Verification.Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Request;
    })();

    Verification.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof Verification
         * @interface IResponse
         * @property {number} retType Response retType
         * @property {string|null} [retMsg] Response retMsg
         * @property {number|null} [errCode] Response errCode
         * @property {Verification.IS2C|null} [s2c] Response s2c
         */

        /**
         * Constructs a new Response.
         * @memberof Verification
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {Verification.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response retType.
         * @member {number} retType
         * @memberof Verification.Response
         * @instance
         */
        Response.prototype.retType = -400;

        /**
         * Response retMsg.
         * @member {string} retMsg
         * @memberof Verification.Response
         * @instance
         */
        Response.prototype.retMsg = "";

        /**
         * Response errCode.
         * @member {number} errCode
         * @memberof Verification.Response
         * @instance
         */
        Response.prototype.errCode = 0;

        /**
         * Response s2c.
         * @member {Verification.IS2C|null|undefined} s2c
         * @memberof Verification.Response
         * @instance
         */
        Response.prototype.s2c = null;

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof Verification.Response
         * @static
         * @param {Verification.IResponse=} [properties] Properties to set
         * @returns {Verification.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link Verification.Response.verify|verify} messages.
         * @function encode
         * @memberof Verification.Response
         * @static
         * @param {Verification.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.retMsg);
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errCode);
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                $root.Verification.S2C.encode(message.s2c, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link Verification.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Verification.Response
         * @static
         * @param {Verification.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof Verification.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Verification.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Verification.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    message.retMsg = reader.string();
                    break;
                case 3:
                    message.errCode = reader.int32();
                    break;
                case 4:
                    message.s2c = $root.Verification.S2C.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("retType"))
                throw $util.ProtocolError("missing required 'retType'", { instance: message });
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Verification.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Verification.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Response message.
         * @function verify
         * @memberof Verification.Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.retType))
                return "retType: integer expected";
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                if (!$util.isString(message.retMsg))
                    return "retMsg: string expected";
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                if (!$util.isInteger(message.errCode))
                    return "errCode: integer expected";
            if (message.s2c != null && message.hasOwnProperty("s2c")) {
                var error = $root.Verification.S2C.verify(message.s2c);
                if (error)
                    return "s2c." + error;
            }
            return null;
        };

        /**
         * Creates a Response message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Verification.Response
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Verification.Response} Response
         */
        Response.fromObject = function fromObject(object) {
            if (object instanceof $root.Verification.Response)
                return object;
            var message = new $root.Verification.Response();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retMsg != null)
                message.retMsg = String(object.retMsg);
            if (object.errCode != null)
                message.errCode = object.errCode | 0;
            if (object.s2c != null) {
                if (typeof object.s2c !== "object")
                    throw TypeError(".Verification.Response.s2c: object expected");
                message.s2c = $root.Verification.S2C.fromObject(object.s2c);
            }
            return message;
        };

        /**
         * Creates a plain object from a Response message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Verification.Response
         * @static
         * @param {Verification.Response} message Response
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Response.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.retType = -400;
                object.retMsg = "";
                object.errCode = 0;
                object.s2c = null;
            }
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retMsg != null && message.hasOwnProperty("retMsg"))
                object.retMsg = message.retMsg;
            if (message.errCode != null && message.hasOwnProperty("errCode"))
                object.errCode = message.errCode;
            if (message.s2c != null && message.hasOwnProperty("s2c"))
                object.s2c = $root.Verification.S2C.toObject(message.s2c, options);
            return object;
        };

        /**
         * Converts this Response to JSON.
         * @function toJSON
         * @memberof Verification.Response
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Response.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Response;
    })();

    return Verification;
})();

module.exports = $root;
